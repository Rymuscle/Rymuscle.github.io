[{"title":"「数据结构与算法」堆 （中篇）","date":"2020-11-03T14:43:20.000Z","path":"2020/11/03/data-structure-algorithm/11-2.heap/","text":"建堆操作参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」堆 （上篇）⭐️","date":"2020-11-02T13:16:14.000Z","path":"2020/11/02/data-structure-algorithm/11-1.heap/","text":"堆 lant:之所以树这种数据结构学完紧接着就是堆，是因为其实堆也是树，不过是一种特殊的树，怎么个特殊法呢?首先它得是一棵完全二叉树；其次，堆中的每个节点的值都必须 大于等于&#x2F;小于等于 其子树中每个节点的值；(前者叫大顶堆，后者叫小顶堆)对于大顶堆（小顶堆），堆顶元素（即根节点）的值分别是最大（最小）的。 根据堆的特性区判断下面这几个二叉树是不是堆其中第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。 堆的应用在熟悉堆这种数据结构的常用操作前，我们还是先了解下堆一般被用到哪些场景吧。 首先就是 优先队列：堆通常作为实现优先队列的首选数据结构，其入队和出队操作的时间复杂度均为 O(logn)，而建队操作为 O(n)，这些操作都非常高效。 堆排序：给定一组数据，我们可以用它们建立一个堆，然后不断地执行元素出堆操作，从而得到有序数据。然而，我们通常会使用一种更优雅的方式实现堆排序，详见后续的堆排序章节。 求解 Top K (即获取最大的K个元素)：这是一个经典的算法问题，同时也是一种典型应用，例如选择热度前 10 的新闻作为微博热搜，选取销量前 10 的商品等。 堆的实现堆的存储与表示之前在学二叉树时，已经了解到完全二叉树非常适合用数组来存储。而堆正是一种完全二叉树，所以我们也将采用数组来存储堆。 当使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。节点指针通过索引映射公式来实现。如下图，给定索引 i，其左子节点索引为 2i，右子节点索引为 2i+1，父节点索引为 i&#x2F;2（向下取整）。当索引越界时，表示空节点或节点不存在。 我们可以将索引映射公式封装成函数，方便后续使用 1234567891011121314/* 获取左子节点索引 */int left(int i) &#123; return 2 * i + 1;&#125;/* 获取右子节点索引 */int right(int i) &#123; return 2 * i + 2;&#125;/* 获取父节点索引 */int parent(int i) &#123; return (i - 1) / 2; // 向下整除&#125; 访问堆顶元素堆顶元素即为二叉树的根节点，也就是数组的首个元素 1234/* 访问堆顶元素 */int peek() &#123; return maxHeap.get(0);&#125; 元素入堆 - - heapify 堆化操作我们首先将元素添加到堆底。 之后，由于元素值可能大于堆中其他元素，堆的成立条件可能会被破坏。因此，需要修复从插入节点到根节点的路径上的各个节点，这个操作被称为「堆化 heapify」。 考虑从入堆节点开始，从底至顶执行堆化。如下图所示，我们比较插入节点与其父节点的值，如果插入节点更大，则将它们交换。然后继续执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无须交换的节点时结束。 设节点总数为n，则树的高度为log(n)。由此可知，堆化操作的循环轮数最多为O(logn)，元素入堆操作的时间复杂度为O(logn)。代码参考hello-algo 堆顶元素出堆堆顶元素是二叉树的根节点，即数组首元素。 如果我们直接从数组中删除首元素，那最后堆化出来的堆可能并不满足完全二叉树的特性。如下图案例： 因此我们需要改变一下思路，比如以下这个巧妙的步骤: 123交换堆顶元素与堆底元素（即交换根节点与最右叶节点）。交换完成后，将堆底从列表中删除（由于已经交换，实际上删除的是原来的堆顶元素）。从根节点开始，从顶至底执行堆化。 因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。 如下图，“从顶至底堆化”的操作方向与“从底至顶堆化”相反，我们将根节点的值与其两个子节点的值进行比较，将最大的子节点与根节点交换。然后循环执行此操作，直到越过叶节点或遇到无须交换的节点时结束。 与元素入堆操作相似，堆顶元素出堆操作的时间复杂度也为 O(logn)。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」红黑树 Red-Black Tree","date":"2020-10-31T06:06:23.000Z","path":"2020/10/31/data-structure-algorithm/10-9.red-blackTree/","text":"参考文献 《数据结构与算法之美》王争 https://blog.csdn.net/yang_yulei/article/details/26066409","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」2-3树","date":"2020-10-30T15:13:09.000Z","path":"2020/10/30/data-structure-algorithm/10-8.2-3Tree/","text":"参考文献 《数据结构与算法之美》王争 从2-3树到 红黑树","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」平衡二叉搜索树--AVL树（下）","date":"2020-10-29T15:13:09.000Z","path":"2020/10/29/data-structure-algorithm/10-7.AVL/","text":"AVL 树常用操作插入操作AVL 树的节点插入操作与二叉搜索树在主体上类似。唯一的区别在于，在 AVL 树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。因此，我们需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡。 删除操作类似地，在二叉搜索树的删除节点方法的基础上，需要从底至顶地执行旋转操作，使所有失衡节点恢复平衡 查找节点AVL 树的节点查找操作与二叉搜索树一致，在此不再赘述。 AVL 树典型应用组织和存储大型数据，适用于高频查找、低频增删的场景。用于构建数据库中的索引系统。红黑树在许多应用中比 AVL 树更受欢迎。这是因为红黑树的平衡条件相对宽松，在红黑树中插入与删除节点所需的旋转操作相对较少，其节点增删操作的平均效率更高。 参考文献 hello-algo 《数据结构与算法之美》王争 https://blog.csdn.net/yang_yulei/article/details/26066409 https://zhuanlan.zhihu.com/p/594775323 https://zhuanlan.zhihu.com/p/604835603?utm_id=0","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」平衡二叉搜索树--AVL树（上）","date":"2020-10-29T14:09:21.000Z","path":"2020/10/29/data-structure-algorithm/10-6.AVL/","text":"lant：通过上一篇对 BST 和 hash表 这两种数据结构的对比，我们知道虽然 BST在平衡状态下的 查、插、删 时间复杂度能达到O(logn)，但相比 hash表的 O(1)常量级时间复杂度还是逊色一点，不过它有hash表无法做到的，所以有存在的必要性和合理性。但上面也提到了，BST需要在平衡状态下才能发挥出威力，否则它的操作效率会逐渐降低到O(n)级。为了解决极端情况下，二叉树会退化为链表的情况，我们就需要设计一种平衡二叉查找树，也就是今天要讲的这种数据结构。通俗的讲，平衡二叉查找树就是说，一棵二叉查找树在频繁地增删改查操作后，它依然能不断通过自我修复来维护自身的平衡性，从而始终保持高效的数据操作性能。 自平衡二叉查找树其实平衡二叉查找树有挺多，常见的比如 AVL树，SplayTree(伸展树)、Treap(树堆)、红黑树。不过你可能留意到，每当提到平衡二叉查找树，听到的基本都是红黑树。它的出镜率甚至要高于“平衡二叉查找 树”这几个字，有时候，我们甚至默认平衡二叉查找树就是红黑树，不过本篇暂时不聊这个明星树，后面会专门再聊。下面先看最早的AVL树。 AVL树 AVL树是最先被发明的自平衡二叉查找树, 它严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。 AVL 树既是二叉搜索树也是平衡二叉树，同时满足这两类二叉树的所有性质，因此也被称为「平衡二叉搜索树 balanced binary search tree」。 AVL树如何实现自平衡 AVL 树之所以在不断地增删改查操作后，依然能保持自身的平衡，就是因为它的“旋转”操作。它的旋转操做能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”。 在介绍AVL树的旋转操作之前，我们先了解一个概念叫 平衡因子， 它用来标识当前节点是否是失衡节点，如果是，就需要对其做旋转操作来保证二叉树的平衡。 当发现失衡因子时，如何对其进行旋转才能保证二叉树的平衡呢？下面根据节点失衡情况的不同，将旋转操作分为四种：右旋、左旋、先右旋后左旋、先左旋后右旋。下面我们将详细介绍这些旋转操作。 lant: 其实我们可以想下，为什么是四种旋转操作呢？其实很简单，平衡的条件是 任意节点**的左子树和右子树的高度之差的绝对值不超过 1 ，那就意味着，当你插入一个节点时，只要破坏了这个条件，就得做旋转操作。所以，我们只用看插入节点后，破坏平衡的状况有哪几种，无非就四种：父是左节点，自己是左节点，父左,自己右; 父右,自己左，父左,字节右每种失衡情况有各自对应的旋转操作。 另外 ，在学习具体的旋转操作之前，我们切记要做到有的放矢，不要太执迷于一些玄学，比如陷入”为什么这么转就能保持平衡，怎么能论证这个结论?”、“这么神奇的操作是怎么想出来的，为什么我就想不出这个方法?” …..可以你看看技术大咖们对此的看法： 旋转操作右旋https://www.hello-algo.com/chapter_tree/avl_tree/#1_1 左旋https://www.hello-algo.com/chapter_tree/avl_tree/#2_1 先左旋后右旋https://www.hello-algo.com/chapter_tree/avl_tree/#3 先右旋后左旋https://www.hello-algo.com/chapter_tree/avl_tree/#4 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」二叉搜索树 binary search tree","date":"2020-10-28T13:35:43.000Z","path":"2020/10/28/data-structure-algorithm/10-5.bst/","text":"前言说到二叉查找树，从名字你也能猜出这种数据结构的估计就是用二叉树来做快速查找的。事实上二叉搜索树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。而我们之前学过的散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。既然有了这么高效的散列表，还要二叉查找树干啥？有没有哪些地方是散列表做不了，必须要用二叉查找树来做的呢？ 带着这些问题，下面来学习今天的内容，二叉查找树！ 二叉搜索树 binary search tree首先二叉查找树是建立在二叉树的基础上的，不过，它在二叉树的基础上又新增了自己的特性：二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。下面是几个二叉查找树的例子，估计你一看应该就清楚了 TODO 初始化一棵平衡的二叉查找树 学到本篇,目前还有难度 😰lant: 回忆之前我们的二叉树一直都是把一些节点通过指针随意串连起来的，只不过在串连的时候，我们会尽量让它更像一棵树(你要是追求完美的话，还能让它更像一棵 完美二叉树)。而现在的二叉搜索树不一样了，它要求我们在串连节点时，除了尽量更像一棵树，还要遵循它的额外特性。 所以，如果你使用一组数据来初始化一棵 二叉查找树，你可能要花费点时间了，你除了要保证二叉查找树的特性，又要尽可能让树平衡… 还是要花费点时间的 (可以点击这个数据结构可视化站点试试) 比如给你一组数 [1~10] 做节点，让你做个二叉搜索树如果你直接挨个拿出节点连接，企图构建一棵二叉树，那效果就尴尬了：而一棵平衡的二叉查找树应该像下面这样：如果让你手动将这些节点连接成一棵平衡的二叉查找树，怕是不告诉你用什么技巧，你可能要连一阵子了 😝 我们暂时先不考虑如何能初始化一棵平衡的二叉搜索树，这个问题后面再聊…下面先假设我们已经有了一棵平衡的 二叉搜索树，然后看我们能用它做些什么操作，时间复杂度怎么样。 二叉搜索树的操作查找节点 假设我们现在已经有了一棵平衡的二叉查找树，那如何在二叉查找树中查找一个节点？ 从根节点开始，如果它等于我们要查找的数据，那就返回;如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。 二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用 O(log n)时间。 123456789101112131415161718/* 查找节点 */TreeNode search(int num) &#123; TreeNode cur = root; // 循环查找，越过叶节点后跳出 while (cur != null) &#123; // 目标节点在 cur 的右子树中 if (cur.val &lt; num) cur = cur.right; // 目标节点在 cur 的左子树中 else if (cur.val &gt; num) cur = cur.left; // 找到目标节点，跳出循环 else break; &#125; // 返回目标节点 return cur;&#125; 插入节点 如何在二叉查找树中插入节点？ 二叉查找树的插入过程有点类似查找操作。 我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置； 如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。代码参考 这里 很显然，即便你最初拥有一棵非常平衡的二叉查找树，随着你不断地插入节点(或者后面的删除节点)，你原本的 平衡二叉查找树 可能就逐渐退化成了链表。这时各种操作的时间复杂度也会退化为 O(n)。 删除节点如何在二叉查找树中删除节点？参考 这里 二叉搜索树 中序遍历 的 福利由于 二叉查找树 有 任意节点左子节点 &lt; 根节点 &lt; 右子节点的特性。而二叉树中序遍历的遍历顺序正好又是左-&gt;根-&gt;右。所以，对于二查找叉树来说，它的中序遍历得到的序列就是个升序序列。 利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需O(n)时间，无须进行额外的排序操作，非常高效。 二叉搜索树的效率在理想情况下，二叉搜索树是“平衡”的，这样就可以在 O(log n) 的时间复杂度下，查、插、删 节点。 开头的问题之前我们学过，散列表 的插入、删除、查找操作的时间复杂度可以做到常量级的O(1)，非常高效;而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn); 相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？ 我认为有下面几个原因： 第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。 比如，如果做索引的话(如mysql)，用户一般会有排序要求，散列表当然不能满足了。 第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)。 第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。 第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。 最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。 二叉搜索树常见应用用作系统中的多级索引，实现高效的查找、插入、删除操作。作为某些搜索算法的底层数据结构。用于存储数据流，以保持其有序状态。 lant:所以我们现在的问题是 如果我们有了一棵平衡的二叉搜索树，我们只能对树上现有的静态数据做查询操作，如果频繁地做插入，删除操作，我们目前还没办法保持树继续平衡，极端情况下，树有可能退化为链表。 即便我们只是想对一组静态数据进行查询操作，我们目前也还没办法先将他们逻辑地组成一棵平衡的 二叉搜索树 😓。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」用数组表示(存储)二叉树","date":"2020-10-28T12:57:19.000Z","path":"2020/10/28/data-structure-algorithm/10-4.binary-tree/","text":"之前我们的二叉树是使用链表这种最基本的数据结构来存储的（链式存储）。 而本篇我们将使用数组这种最基本的结构来存储二叉树（顺序存储）。 尝试用数组存储一棵二叉树 如果将根节点A存储在下标 i = 1 的位置，那左子节点B会存储在下标 2 * i = 2 的位置，右子节点C会存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点D会存储在 2 * i = 2 * 2 = 4 的位置，右子节点E存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。……最终的二叉树和数组的对应关系如下图:总结一下，就是，如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是它的左子节点，下标为 2 * i + 1 的位置存储的就是它的右子节点。反过来，下标为 i&#x2F;2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。 比较遗憾的是，刚刚我们举的例子是将一棵完全二叉树存储到了数组中，为了方便通过下标计算树中各节点位置，所以“浪费”了一个下标为 0 的存储位置。但如果我们往数组中存储的是一棵非完全二叉树，那就会浪费比较多的数组存储空间了。 可以看到，我们为了使 根节点下标为i, 左子节点下标为2 * i, 右子节点下标为 2 * i + 1 这个公式来仍然生效(方便计算各节点位置从而串起整棵树)，就不得不将一些None节点的位置也在数组中留出来。 这样就会浪费比较多的数组存储空间。 以下代码实现了一个基于数组表示的二叉树，包括以下几种操作 给定某节点，获取它的值、左（右）子节点、父节点。 获取前序遍历、中序遍历、后序遍历、层序遍历序列。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 数组表示下的二叉树类 */class ArrayBinaryTree &#123; private List&lt;Integer&gt; tree; /* 构造方法 */ public ArrayBinaryTree(List&lt;Integer&gt; arr) &#123; tree = new ArrayList&lt;&gt;(arr); &#125; /* 节点数量 */ public int size() &#123; return tree.size(); &#125; /* 获取索引为 i 节点的值 */ public Integer val(int i) &#123; // 若索引越界，则返回 null ，代表空位 if (i &lt; 0 || i &gt;= size()) return null; return tree.get(i); &#125; /* 获取索引为 i 节点的左子节点的索引 */ public Integer left(int i) &#123; return 2 * i + 1; &#125; /* 获取索引为 i 节点的右子节点的索引 */ public Integer right(int i) &#123; return 2 * i + 2; &#125; /* 获取索引为 i 节点的父节点的索引 */ public Integer parent(int i) &#123; return (i - 1) / 2; &#125; /* 层序遍历 */ public List&lt;Integer&gt; levelOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 直接遍历数组 for (int i = 0; i &lt; size(); i++) &#123; if (val(i) != null) res.add(val(i)); &#125; return res; &#125; /* 深度优先遍历 */ private void dfs(Integer i, String order, List&lt;Integer&gt; res) &#123; // 若为空位，则返回 if (val(i) == null) return; // 前序遍历 if (order == &quot;pre&quot;) res.add(val(i)); dfs(left(i), order, res); // 中序遍历 if (order == &quot;in&quot;) res.add(val(i)); dfs(right(i), order, res); // 后序遍历 if (order == &quot;post&quot;) res.add(val(i)); &#125; /* 前序遍历 */ public List&lt;Integer&gt; preOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(0, &quot;pre&quot;, res); return res; &#125; /* 中序遍历 */ public List&lt;Integer&gt; inOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(0, &quot;in&quot;, res); return res; &#125; /* 后序遍历 */ public List&lt;Integer&gt; postOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(0, &quot;post&quot;, res); return res; &#125;&#125; lant: 所以，其实二叉树中，也就完全二叉树比较适合用 数组来存储。 因为如果一棵二叉树是一棵完全二叉树，那它用数组存储就会非常节省空间，它不需要像链式存储那样要存储额外的左右子节点的指针。这也是为什么完全二叉树要求最后一层的子节点都靠左的原因，因为右边的None节点会一起排在数组的末尾，可以直接省略，也不影响 数组存储二叉树的公式 计算。 优势与局限性二叉树的数组表示主要有以下优点： 数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。 不需要存储指针，比较节省空间。 允许随机访问节点。 然而，数组表示也存在一些局限性： 数组存储需要连续内存空间，因此不适合存储数据量过大的树。 增删节点需要通过数组插入与删除操作实现，效率较低。 当二叉树中存在大量None时，数组中包含的节点数据比重较低，空间利用率较低。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」二叉树遍历","date":"2020-10-27T13:52:36.000Z","path":"2020/10/27/data-structure-algorithm/10-3.binary-tree/","text":"到目前为止，我们的二叉树从下层的物理结构角度来看, 仍然是使用链表这种最基本的的数据结构进行的存储，因此其遍历方式仍是通过指针逐个访问节点。 然而，从上层的逻辑角度来看，二叉树是一种非线性数据结构，这就使得二叉树(在应用层逻辑上)的遍历要比遍历链表更加复杂，需要借助搜索算法来实现。 二叉树常见的遍历方式包括 层序遍历、前序遍历、中序遍历 和 后序遍历 等。 广度优先遍历 – 「层序遍历 level-order traversal」原理从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。层序遍历本质上属于 「广度优先遍历 breadth-first traversal」 ，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。 代码仔细看上图的 广度优先遍历 方式，你会发现它遍历节点时，节点出现的方式 和 队列的“先进先出”规则很像，因此广度优先遍历也通常借助“队列”来实现 1234567891011121314151617/* 层序遍历 */List&lt;Integer&gt; levelOrder(TreeNode root) &#123; // 初始化队列，加入根节点 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); // 初始化一个列表，用于保存遍历序列 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); // 队列出队 list.add(node.val); // 保存节点值 if (node.left != null) queue.offer(node.left); // 左子节点入队 if (node.right != null) queue.offer(node.right); // 右子节点入队 &#125; return list;&#125; 时间复杂度O(n)：所有节点被访问一次，使用 O(n) 时间，其中 n 为节点数量。空间复杂度O(n)：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 (n+1)/2 个节点，占用 O(n) 空间。二叉树的层数越往下，每层的节点越多，所以 只有二叉树是满二叉树时，最底层的节点数会达到最大。此时，当最底层节点(叶子节点)全部放入队列时，也是队列占用空间最大时。此时叶子结点数量为 (n+1)/2 深度优先遍历 - 前、中、后 序遍历原理 “前序”、”中序”、”后序” 是基于遍历时 “根节点” 的顺序来说的。前序：根在前；中序：根在中；后序：根在后; 代码1234567891011121314151617181920212223242526272829/* 前序遍历 */void preOrder(TreeNode root) &#123; if (root == null) return; // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树 list.add(root.val); preOrder(root.left); preOrder(root.right);&#125;/* 中序遍历 */void inOrder(TreeNode root) &#123; if (root == null) return; // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树 inOrder(root.left); list.add(root.val); inOrder(root.right);&#125;/* 后序遍历 */void postOrder(TreeNode root) &#123; if (root == null) return; // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点 postOrder(root.left); postOrder(root.right); list.add(root.val);&#125; 时间复杂度 O(n)：所有节点被访问一次，使用 O(n) 时间。空间复杂度 O(n)：在最差情况下，即树退化为链表时，递归深度达到 n，系统占用 O(n) 栈帧空间。 lant:到目前为止，我们的二叉树都还只是自己手动将一些 数据节点 随意串连起来的，父子节点之间也没什么大小顺序之分，节点们的组合还没什么规律可言。我们也只是在串连时尽量保证它们连起来像一棵二叉树，尽量完全 或 完美。 但即便我们好手动连出了一棵完美二叉树，由于各节点之间并没有什么规则，这棵树貌似既不能帮我们完成排序，也无法帮我们完成某种快速检索。 貌似还没什么用…… 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」常见二叉树类型","date":"2020-10-27T13:23:19.000Z","path":"2020/10/27/data-structure-algorithm/10-2.binary-tree/","text":"「完美二叉树 perfect binary tree」所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 0，其余所有节点的度都为 2；若树高度为 h，则节点总数为 $2^{h+1}-1$ 。呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。 「完全二叉树 complete binary tree」只有最底层的节点未被填满，且最底层节点尽量靠左填充。 「完满二叉树 full binary tree」除了叶节点之外，其余所有节点都有两个子节点 「平衡二叉树 balanced binary tree」任意节点的左子树和右子树的高度之差的绝对值不超过 1 二叉树的退化当二叉树的每层节点都被填满时，达到 完美二叉树，完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。而当所有节点都偏向一侧时，二叉树退化为 链表，链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n)。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」二叉树 binary tree","date":"2020-10-27T12:15:32.000Z","path":"2020/10/27/data-structure-algorithm/10-1.binary-tree/","text":"认识二叉树 「二叉树 binary tree」是一种非线性数据结构，体现着“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。 常见术语12345678根节点 root node」：位于二叉树顶层的节点，没有父节点。「叶节点 leaf node」：没有子节点的节点，其两个指针均指向。「边 edge」：连接两个节点的线段，即节点引用（指针）。节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。节点的「深度 depth」：从根节点到该节点所经过的边的数量。节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。 二叉树 (链式存储) 基本操作初始化二叉树 从二叉树的结构图来看，它的节点和链表的节点非常像，因此用链表来存储二叉树也挺顺理成章的 😝。而且链式存储也比较简单、直观，很方便地通过节点的左右指针就能将整棵树串起来，大部分二叉树代码都是通过这种结构来实现的。 其实初始化二叉树的过程和初始化一个链表没什么区别(将一些节点用指针串联起来)。只不过串联的逻辑稍有不同。 1234567891011// 初始化节点TreeNode n1 = new TreeNode(1);TreeNode n2 = new TreeNode(2);TreeNode n3 = new TreeNode(3);TreeNode n4 = new TreeNode(4);TreeNode n5 = new TreeNode(5);// 构建引用指向（即指针）n1.left = n2;n1.right = n3;n2.left = n4;n2.right = n5; 这棵二叉树的逻辑结构如下： 当然，对于上面的多个节点，你有多种不同的连接方式，将它们连成多种不同的二叉树： 插入、删除 节点与链表类似， 在二叉树中 插入、删除节点 ，可以通过修改指针来实现 123456TreeNode P = new TreeNode(0);// 在 n1 -&gt; n2 中间插入节点 Pn1.left = P;P.left = n2;// 删除节点 Pn1.left = n2; 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「数据结构与算法」数据结构分类","date":"2020-10-11T12:15:32.000Z","path":"2020/10/11/data-structure-algorithm/01.dataStructure-type/","text":"数据结构分类数据结构可以从两个维度分为： 逻辑结构 和 物理结构。 逻辑结构 揭示了数据元素之间的逻辑关系，是抽象意义上的结构（也是我们后面重点关注和讨论的）； 物理结构 则反映了 按一定逻辑结构组成的数据元素 在计算机内存中真正的存储结构；在算法运行过程中，相关数据都存储在内存中, 这些数据的存储方式可分为 连续空间存储（数组） 和 分散空间存储（链表） 逻辑结构 逻辑结构 又可被分为 线性 和 非线性 两大类 线性结构比较直观，指数据在逻辑关系上呈线性排列；如：数组、链表、栈、队列、哈希表。 非线性结构则相反，呈非线性排列。如：树、堆、图、哈希表。 所有数据结构都是基于 数组、链表 或二者的组合实现的，例如 基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度&gt;&#x3D;3的数组）等。基于链表可实现：栈、队列、哈希表、树、堆、图等。 lant: 数组 和 链表这两种逻辑数据结构，对应了内存上的两个最基本的物理存储结构 连续存储、分散存储，因此 数组 和 链表是最基本的逻辑数据结构，其他更为复杂的逻辑数据结构要使用哪种物理结构进行存储时，都需要基于这两个最基础的逻辑数据结构进行选择。 可以简单认为，对于一组数据，无论它们逻辑上是用哪种结构组合起来的。它们最终在物理介质上都是两种存储方式 连续存储、分散存储。 而这两种物理存储方式对应了最基础的两个数据结构 数组、链表。 所以无论你的数据是哪种逻辑结构的组合，最终也要选择基于什么样的物理结构进行存储，而 数组 和 链表 这两种基础数据结构分别对应了不同的物理存储结构。 如，下图中对于 堆 这种数据结构(逻辑上的)，可以采用 链表 或 数组 两种不同的 数据结构(物理上的) 进行存储。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}]