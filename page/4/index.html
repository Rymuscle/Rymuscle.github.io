<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>rymuscle的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="rymuscle的技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
    
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">rymuscle的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一切美好都如约而至!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> 首页</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> 归档</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> 关于</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> 订阅</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  <article id="post-MySQL知识点整理/5.1 数据页结构 之 User Records、Free Space 部分" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/23/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/5.1%20%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84%20%E4%B9%8B%20User%20Records%E3%80%81Free%20Space%20%E9%83%A8%E5%88%86/">5.1 `数据页` 结构 之 User Records、Free Space 部分</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-23T15:12:10.000Z" itemprop="datePublished">2021年09月23日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/23/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/5.1%20%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84%20%E4%B9%8B%20User%20Records%E3%80%81Free%20Space%20%E9%83%A8%E5%88%86/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据页-结构-之-User-Records、Free-Space-部分"><a href="#数据页-结构-之-User-Records、Free-Space-部分" class="headerlink" title="数据页 结构 之 User Records、Free Space 部分"></a><code>数据页</code> 结构 之 <code>User Records</code>、<code>Free Space</code> 部分</h1><blockquote>
<p>在<code>索引⻚</code>的7个组成部分中，我们自己存储的记录会按照我们指定的<code>行格式</code>存储到 <code>User Records 部分</code>。</p>
</blockquote>
<blockquote>
<p>但是在一开始生成⻚的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 <code>Free Space 部分</code>(也就是尚未使用的存储空间中)申请一个记录大小的空间划分到 <code>User Records 部分</code>，当 <code>Free Space 部分</code>的空间全部被 <code>User Records 部分</code>替代掉之后，也就意味着这个⻚使用完了，如果还有新的记录插入的话，就需要去申请新的⻚了，这个过程的图示如下:<br><img src="/images/MySQL/5.1/1.jpg"></p>
</blockquote>
<blockquote>
<p>为了更好的管理 User Records中的这些记录，InnoDB可费了一番力气呢，在哪费力气了呢? 不就是把记录按照指定的行格式一条一条摆在User Records部分么?</p>
<p>其实这话还得从<code>记录行格式</code>的<code>记录头信息</code>中说起。(回顾：<a href="/2021/09/18/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.1%20compact%20%E8%A1%8C%E6%A0%BC%E5%BC%8F/">4.1 compact 行格式</a>，当时在提到 记录头信息 时，只是简单地了解了 记录头信息 的基本构成)，下面就着重看下之前学的行格式的知识中的<code>记录头信息</code>部分的秘密吧。</p>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/5.0 盛放记录的大盒子 - InnoDB的数据页结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/23/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/5.0%20%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90%20-%20InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/">5.0 盛放记录的大盒子 - InnoDB的数据页结构</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-23T13:25:09.000Z" itemprop="datePublished">2021年09月23日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/23/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/5.0%20%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90%20-%20InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="不同类型的页简介"><a href="#不同类型的页简介" class="headerlink" title="不同类型的页简介"></a>不同类型的页简介</h1><blockquote>
<p>前边已经简单提到过 <code>⻚</code> 的概念了， <strong><code>它是InnoDB管理存储空间的基本单位</code></strong> ，一个⻚的大小一般是16KB。</p>
</blockquote>
<blockquote>
<p>InnoDB为了不同的目的而设计了许多种不同类型的⻚，比如 <code>存放 表空间头部信息 的⻚</code>、<code>存放 Insert Buffer信息 的⻚</code>、<code>存放 INODE信息 的⻚</code>、<code>存放 undo日志信息 的⻚</code> 等等……</p>
</blockquote>
<blockquote>
<p>当然，如果这些名词你一个都没有听过也无所谓~~~目前暂时还不准备说这些类型的⻚。<br><code>我们聚焦的是那些存放我们表中记录的那种类型的⻚</code>，官方称这种存放记录的⻚为<code>索引(INDEX)⻚</code>，鉴于我们还没有了解过索引是个什么东⻄，而这些表中的记录就是我们日常口中所称的数据，所以目前还是叫这种存放记录的⻚为<code>数据⻚</code>吧。</p>
</blockquote>
<h1 id="索引-INDEX-⻚的结构概括"><a href="#索引-INDEX-⻚的结构概括" class="headerlink" title="索引(INDEX)⻚的结构概括"></a>索引(INDEX)⻚的结构概括</h1><blockquote>
<p><code>数据⻚</code>的16KB存储空间可以被划分为多个部分，不同部分有不同的功能:<br><img src="/images/MySQL/5.0/1.jpg"></p>
</blockquote>
<blockquote>
<p>可以看出，一个InnoDB数据⻚的存储空间大致被划分成了7个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。</p>
<p>下边我们用表格的方式来大致描述一下这7个部分都存储一些啥内容(快速的瞅一眼就行了，后边会详细唠叨的):</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>👌 File Header</td>
<td>文件头部</td>
<td>38字节</td>
<td>⻚的一些通用信息(所有类型的页都有这个不分)</td>
</tr>
<tr>
<td>✅ <code>Page Header</code></td>
<td>⻚面头部</td>
<td>56字节</td>
<td><code>数据⻚</code>这种页类型<strong>专有</strong>的一些信息</td>
</tr>
<tr>
<td>✅ Infimum + Supremum</td>
<td>最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td>✅ *<em>User Records</em></td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>✅ Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>⻚中尚未使用的空间</td>
</tr>
<tr>
<td>✅ <strong><code>Page Directory</code></strong></td>
<td><strong><code>⻚面目录</code></strong></td>
<td>不确定</td>
<td>⻚中的某些记录的相对位置</td>
</tr>
<tr>
<td>👌 File Trailer</td>
<td>文件尾部</td>
<td>8字节</td>
<td>校验⻚是否完整</td>
</tr>
<tr>
<td>不过，我们接下来并不打算按照⻚中各个部分的出现顺序来依次介绍它们，因为各个部分中会出现很多大家目前不理解的概念，这会打击 各位读文章的信心与兴趣，希望各位能接受这种拍摄手法~</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/4.4 CHAR(M)中的M值过大的情况" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/21/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.4%20CHAR(M)%E4%B8%AD%E7%9A%84M%E5%80%BC%E8%BF%87%E5%A4%A7%E7%9A%84%E6%83%85%E5%86%B5/">4.4 CHAR(M)中的M值过大的情况</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-21T11:51:16.000Z" itemprop="datePublished">2021年09月21日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/21/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.4%20CHAR(M)%E4%B8%AD%E7%9A%84M%E5%80%BC%E8%BF%87%E5%A4%A7%E7%9A%84%E6%83%85%E5%86%B5/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="CHAR-M-中的M值过大的情况"><a href="#CHAR-M-中的M值过大的情况" class="headerlink" title="CHAR(M)中的M值过大的情况"></a>CHAR(M)中的M值过大的情况</h1><blockquote>
<p>CHAR(M)类型的列所占用的最大字节⻓度等于 <code>该列使用的字符集表示一个字符需要的最大字节数</code>和<code>M</code>的乘积。</p>
</blockquote>
<blockquote>
<p>如果某个列使用的是CHAR(M)类型，并且它<code>存储的最大字节⻓度超过768字节</code>，那么不论我们使用的是之前讲过的4种行格式中的哪种，<code>InnoDB都会把该列当成变⻓字段看待</code>。<br>比方说采用utf8mb4的CHAR(255)类型的列将会被当作变⻓字段看待，因为 <code>4×255 &gt; 768</code>。</p>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/4.3 Dynamic 和 Compressed 行格式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/21/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.3%20Dynamic%20%E5%92%8C%20Compressed%20%E8%A1%8C%E6%A0%BC%E5%BC%8F/">4.3 Dynamic 和 Compressed 行格式</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-21T11:11:27.000Z" itemprop="datePublished">2021年09月21日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/21/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.3%20Dynamic%20%E5%92%8C%20Compressed%20%E8%A1%8C%E6%A0%BC%E5%BC%8F/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Dynamic-和-Compressed-行格式"><a href="#Dynamic-和-Compressed-行格式" class="headerlink" title="Dynamic 和 Compressed 行格式"></a>Dynamic 和 Compressed 行格式</h1><blockquote>
<p>我现在使用的MySQL版本是5.7，它的默认行格式就是Dynamic，这俩行格式和Compact行格式挺像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他⻚面中，只在记录的真实数据处存储其他⻚面的地址，就像这样:<br><img src="/images/MySQL/4.3/1.jpg"></p>
</blockquote>
<blockquote>
<p>Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对⻚面进行压缩，以节省空间。</p>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/4.2 行溢出数据 与 溢出页" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/19/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.2%20%E8%A1%8C%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE%20%E4%B8%8E%20%E6%BA%A2%E5%87%BA%E9%A1%B5/">4.2 行溢出数据 与 溢出页</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-19T14:01:52.000Z" itemprop="datePublished">2021年09月19日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/19/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.2%20%E8%A1%8C%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE%20%E4%B8%8E%20%E6%BA%A2%E5%87%BA%E9%A1%B5/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="VARCHAR-M-最多能存储的数据"><a href="#VARCHAR-M-最多能存储的数据" class="headerlink" title="VARCHAR(M)最多能存储的数据"></a>VARCHAR(M)最多能存储的数据</h1><blockquote>
<p>我们知道，对于VARCHAR(M)类型的列最多可以占用65535个字节。(lant: 因为在变长字段长度列表中，每个变长字段实际存储的数据的长度值最多占2个字节，而2个字节最大能表示的数就是65535了)。<br>而之前我们也说过，VARCHAR(M)的<code>M</code>代表该类型最多存储的<code>字符数量</code></p>
</blockquote>
<h2 id="使用ascii定长字符集"><a href="#使用ascii定长字符集" class="headerlink" title="使用ascii定长字符集"></a>使用ascii定长字符集</h2><blockquote>
<p>如果我们使用ascii字符集的话，一个字符就代表一个字节，我们看看VARCHAR(65535)是否可用:</p>
<p><code>mysql&gt; CREATE TABLE varchar_size_demo(</code><br><code>-&gt; c VARCHAR(65535)</code><br><code>-&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</code></p>
<p><code>ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs</code></p>
<p><code>mysql&gt;</code></p>
<p>从报错信息里可以看出，MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB或者TEXT类型的列之外， <strong><code>其他所有的列(不包括隐藏列和记录头信息)占用的字节⻓度加起来不能超过65535个字节</code></strong> 。所以上面可以看到MySQL服务器建议我们把存储类型改为TEXT或者BLOB的类型。</p>
<p>这65535个字节除了列本身的数据外，还包括一些其他数据，比如说为了存储一个VARCHAR(M)类型的列，其实需要占用3部分存储空间: <code>真实数据</code>、<code>真实数据的⻓度占用的字节</code>、<code>NULL值标识</code>(如果该列有NOT NULL属性则可以没有这部分存 储空间)…<br>如果该VARCHAR类型的列没有NOT NULL属性，那最多只能存储65532个字节的数据，<code>因为真实数据的⻓度在变长字段列表中会占2个字节，NULL 值标识需要占用1个字节</code>，再次尝试，果然成功了<br><code>mysql&gt; CREATE TABLE varchar_size_demo(</code><br><code>-&gt; c VARCHAR(65532)</code><br><code>-&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</code><br><code>Query OK, 0 rows affected (0.02 sec)</code></p>
</blockquote>
<h2 id="使用变长字符集"><a href="#使用变长字符集" class="headerlink" title="使用变长字符集"></a>使用变长字符集</h2><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那会怎么样呢?</p>
<blockquote>
<p><code>mysql&gt; CREATE TABLE varchar_size_demo( </code><br><code>-&gt; c VARCHAR(65532)</code><br><code>-&gt; ) CHARSET=gbk ROW_FORMAT=Compact;</code><br><code>ERROR 1074 (42000): Column length too big for column &#39;c&#39; (max = 32767); use BLOB or TEXT instead</code></p>
<p><code>mysql&gt; CREATE TABLE varchar_size_demo(</code><br><code>-&gt;  c VARCHAR(65532)</code><br><code>-&gt; ) CHARSET=utf8 ROW_FORMAT=Compact;</code><br><code>ERROR 1074 (42000): Column length too big for column &#39;c&#39; (max = 21845); use BLOB or TEXT instead</code></p>
</blockquote>
<blockquote>
<p>从执行结果中可以看出，如果VARCHAR(M)类型的列使用的不是ascii字符集，那<code>M的最大取值取决于该字符集表示一个字符最多需要的字节数</code>。<br>gbk字符集表示一个字符最多需要2个字符，在列的值允许为NULL的情况下，M的最大取值就是32766(也就是: 65535-2(变长字段列表占2字节)-1(null列表占1字节) &#x3D; 65532)，也就是说最多能存储32766(65532&#x2F;2)个字符;<br>utf8字符集表示一个字符最多需要3个字符，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844(也就是: (65535-2-1)&#x2F;3)个字符。</p>
</blockquote>
<blockquote>
<p>Tips:<br>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844， <strong><code>这都是在表中只有一个字段的情况下说的</code></strong> ， <strong><code>一定要记住一个行中的所有列(不包括隐藏列和记录头信息)占用的字节⻓度加起来不能超过65535个字节</code></strong> !</p>
</blockquote>
<h1 id="记录中的数据太多产生的溢出"><a href="#记录中的数据太多产生的溢出" class="headerlink" title="记录中的数据太多产生的溢出"></a>记录中的数据太多产生的溢出</h1><blockquote>
<p>前边说过， <strong><code>MySQL中磁盘和内存交互的基本单位是⻚</code>，也就是说<code>MySQL是以⻚为基本单位来管理存储空间的</code>，<code>我们的记录都会被分配到某个⻚中存储</code></strong> 。</p>
<p>而一个⻚的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，<code>这样就可能造成一个⻚存放不了一条记录的尴尬情况</code>。</p>
<p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，<code>在记录的真实数据处只会存储该列的一部分数据，而剩余的数据则会被分散存储在几个其他的⻚中，然后记录的真实数据处用20个字节存储指向这些⻚的地址</code>(当然这20个字节中还包括这些分散在其他⻚面中的数据的占用的字节数)，从而可以找到剩余数据所在的⻚。<br><img src="/images/MySQL/4.2/1.jpg"></p>
</blockquote>
<blockquote>
<p>从图中可以看出来，对于Compact和Reduntant行格式来说，如果 某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的 前768个字节的数据和一个指向其他⻚的地址，然后把剩下的数据存 放到其他⻚中，这个过程也叫做行溢出，存储超出768字节的那些⻚面也被称为<code>溢出⻚</code>。简图如下：<br><img src="/images/MySQL/4.2/2.jpg"><br>最后需要注意的是，不只是 VARCHAR(M) 类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。</p>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/4.1 compact 行格式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/18/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.1%20compact%20%E8%A1%8C%E6%A0%BC%E5%BC%8F/">4.1 compact 行格式</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-18T12:41:09.000Z" itemprop="datePublished">2021年09月18日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/18/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.1%20compact%20%E8%A1%8C%E6%A0%BC%E5%BC%8F/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h1><blockquote>
<p>直接看图:<br><img src="/images/MySQL/4.1/1.jpg"><br>从图中可以看出来，一条完整的记录其实可以被分为 <code>记录的额外信息</code> 和 <code>记录的真实数据</code> 两大部分，下边我们详细看一下这两部分的组成。</p>
</blockquote>
<h1 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h1><p>这部分信息是 <strong><code>服务器为了描述这条记录而不得不额外添加的一些信息</code></strong> 。这些额外信息分为3部分，分别是 <code>变⻓字段⻓度列表</code>、<code>NULL值列表</code> 和 <code>记录头信息</code>，我们分别看一下</p>
<h2 id="记录的额外信息-之-变⻓字段⻓度列表"><a href="#记录的额外信息-之-变⻓字段⻓度列表" class="headerlink" title="记录的额外信息 之 变⻓字段⻓度列表"></a>记录的额外信息 之 <code>变⻓字段⻓度列表</code></h2><blockquote>
<p>我们知道MySQL支持一些变⻓的数据类型，比如 VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型，我们可以把被设置为这些数据类型的列称为<code>变⻓字段</code>；<br>变⻓字段中存储多少字节的数据是不固定的，所以我们在存储真实数据时，InnoDB引擎会顺便把这些数据实际占用的字节数也存起来，这样才不至于把MySQL服务器搞懵，所以这些变⻓字段占用的存储空间分为两部分: <code>真正的数据内容</code>、<code>数据内容占用的字节数</code>。</p>
<p>在Compact行格式中，把<code>所有变⻓字段的真实数据所占用的字节数</code>都存放在记录的开头部位，从而形成一个<code>变⻓字段⻓度列表</code>。各变⻓字段的真实数据所占用的字节数，按照列的顺序<code>逆序存放</code>。</p>
</blockquote>
<blockquote>
<p>示例:<br><img src="/images/MySQL/4.1/2.jpg"><br>拿 record_format_demo 示例表中的 第一条记录 来举例:</p>
<p>因为record_format_demo表的c1、c2、c4字段都是 VARCHAR(10)类型(<code>变⻓数据类型</code>)， <strong>所以这三个列的所存储的真实数据的⻓度值都需要保存在当前记录的 <code>变⻓字段⻓度列表中</code></strong> ；</p>
<p>又因为record_format_demo表中的各个列都使用的是ascii字符集(每个字符只需要1个字节来进行编码);来看一下第一条记录各变⻓字段的 实际内容 的⻓度:<br><img src="/images/MySQL/4.1/4.jpg"></p>
<p>又因为这些⻓度值需要按照列的逆序存放，所以最后<code>这条记录的变⻓字段⻓度列表</code> 的字节串用十六进制表示的效果就是：<br><img src="/images/MySQL/4.1/5.jpg"></p>
<p> <strong><code>第一行记录中，c1、c2、c4 每列中的真实数据所占的字节长度的数值比较小(4，3，1这些小数字)，用1个字节就可以表示；但是如果变⻓列的数据占用的字节数比较多，可能就需要用2个字节来表示</code></strong> 。(如果某行记录的c1变长字段的真实数据长度是300字节，300这个数值用一个字节就无法表示了，因为一个字节是8位，最大只能表示的数字是255)<br>每个变长字段在 <code>变长字段列表中</code> 具体用1个还是2个字节来表示真实数据所占用的字节数，InnoDB有它的一套规则，我们首先声明一下<code>W</code>、<code>M</code>和<code>L</code>的意思。</p>
</blockquote>
<hr>
<blockquote>
<p><strong><code>W</code></strong>:<br>假设一个<code>字符集</code>中表示一个字符最多需要使用的字节数为<code>W</code>，也就是使用 <code>SHOW CHARSET</code> 语句的结果中的<code>Maxlen</code>列。(比方说utf8字符集中的W就是3，utf8mb4字符集中的W就是4)。</p>
<p><strong><code>M</code></strong>:<br>对于变⻓类型<code>VARCHAR(M)</code>来说， <strong><code>这种类型表示能存储最多M个字符</code></strong> (注意是字符不是字节)，所以这个类型能表示的字符串最多占用的字节数就是 <code>M×W</code>。</p>
<p> <strong><code>L</code></strong>:<br>假设该变长实际存储的字符串占用的字节数是 <code>L</code>;</p>
<p>所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是:</p>
<ol>
<li><p>如果 <code>M×W &lt;= 255</code>，那么使用1个字节来表示真正字符串占用的字节数； (一个字节能表示的最大数值就是255)</p>
</li>
<li><p>如果<code>M×W &gt; 255</code>，则分为两种情况:</p>
</li>
</ol>
<ul>
<li>如果 <code>L &lt;= 127</code>，则用1个字节来表示真正字符串占用的字节数。</li>
<li>如果 <code>L &gt; 127</code>，则用2个字节来表示真正字符串占用的字节数。</li>
</ul>
<p>对于一些占用字节数非常多的字段，比方说某个字段⻓度大于了16KB，即 该记录在单个⻚面中都存储不下时，InnoDB 会把一部分数据存放到所谓的<code>溢出⻚</code>中(我们后边会唠叨)，在变⻓字段⻓度列表处只存储留在本⻚面中的⻓度，所以使用两个字节也可以存放下来。</p>
<p>总结一下就是说: 如果该变长字段允许存储的最大字节数(M×W)超过255字节并且真实存储的字节数(L)超过127字节，则使用2个字节，否则使用1个字节。</p>
</blockquote>
<hr>
<blockquote>
<p>另外需要注意的一点是，<code>变⻓字段⻓度列表中只存储实际内容为非NULL的列数据占用的字节数，值为NULL的列的⻓度是不储存的</code><br>也就是 说对于第二条记录来说，<code>因为c4列的值为NULL，所以第二条记录的变⻓字段⻓度列表只需要存储c1和c2列的⻓度即可</code>（其中c1列存储的值为’eeee’，占用的实际字节数为4，c2列存储的值为’fff’，占用的实际字节数为3。数字4可以用1个字节表示，3也可以用1个字节表示， 所以整个变⻓字段⻓度列表共需2个字节）。<br>填充完变⻓字段⻓度列表 的两条记录的对比图如下:<br><img src="/images/MySQL/4.1/6.jpg"></p>
</blockquote>
<blockquote>
<p>Tips:<br>并不是所有<code>记录</code>都有这个 <code>变⻓字段⻓度列表</code> 部分，比方说表中所有的列都不是变⻓的数据类型的话，这一部分就不需要有。</p>
</blockquote>
<h2 id="记录的额外信息-之-NULL值列表"><a href="#记录的额外信息-之-NULL值列表" class="headerlink" title="记录的额外信息 之 NULL值列表"></a>记录的额外信息 之 <code>NULL值列表</code></h2><p>我们知道表中的某些列可能存储NULL值，<code>如果把这些NULL值都放到记录的真实数据中存储，那就会很占地方</code>，所以<code>Compact行格式</code>把这些值为NULL的列统一管理起来，存储到了 <code>记录的额外信息</code> 中的 <code>NULL值列表</code> 中，它的处理过程是这样的:</p>
<blockquote>
<ol>
<li>首先统计表中允许存储NULL的列有哪些<br>像 <code>主键列</code>、<code>被NOT NULL修饰的列</code> 都是不可以存储NULL值的，所以在统计时不会把这些列算进去。</li>
<li>如果表中没有允许存储 NULL 的列，则NULL值列表也不存在。否则 <strong><code>将每个允许存储NULL的列对应一个二进制位</code></strong> ，二进制位按照列的顺序逆序排列，二进制位的值为1时，代表该列的值为NULL。二进制位的值为0时，代表该列的值不为NULL。</li>
</ol>
</blockquote>
<blockquote>
<p>MySQL规定NULL值列表必须用整数个字节的位表示，如果可以为NULL的字段数 达不到整数个字节，则在字节的高位补0。<br>表record_format_demo只有3个值允许为NULL的列，对应3个二进制位，不足一个字节，所以在字节的高位补0，效果就是这样:<br><img src="/images/MySQL/4.1/7.jpg"></p>
</blockquote>
<blockquote>
<p>对于第一条记录来说，c1、c3、c4 这3个列的值都不为NULL，所以它们对应的二进制位都是0:<br><img src="/images/MySQL/4.1/8.jpg"></p>
</blockquote>
<blockquote>
<p>对于第二条记录来说，c1、c3、c4 这3个列中c3和c4的值都为NULL，所以这3个列对应的二进制位的情况就是:<br><img src="/images/MySQL/4.1/9.jpg"></p>
</blockquote>
<blockquote>
<p>所以这两条记录在填充了NULL值列表后的示意图就是这样:<br><img src="/images/MySQL/4.1/10.jpg"></p>
</blockquote>
<h2 id="记录的额外信息-之-记录头信息"><a href="#记录的额外信息-之-记录头信息" class="headerlink" title="记录的额外信息 之 记录头信息"></a>记录的额外信息 之 <code>记录头信息</code></h2><blockquote>
<p>除了 <code>变⻓字段⻓度列表</code>、<code>NULL值列表</code> 之外，还有一个 <code>用于描述记录</code>的 <code>记录头信息</code>。</p>
</blockquote>
<blockquote>
<p><code>记录头信息</code> 由固定的5个字节组成(也就是40个二进制位，不同的位代表不同的意思)，如图:<br><img src="/images/MySQL/4.1/11.jpg"></p>
</blockquote>
<blockquote>
<p><strong>这些二进制位代表的详细信息如下表</strong>:<br><img src="/images/MySQL/4.1/12.jpg"><br>现在暂时也没必要把它们的意思都记住，只需要看一遍混个脸熟，等之后用到这些属性的时候我们再回过头来看</p>
<p>现在我们并不清楚这些属性详细的用法，所以这里就不分析各个属性值是怎么产生的了，之后我们遇到会详细看的。</p>
</blockquote>
<blockquote>
<p>所以我们现在直接看一下record_format_demo 表中的两条记录的头信息分别是什么:<br><img src="/images/MySQL/4.1/13.jpg"><br>目前，你只需要对这两条记录的 <code>记录头信息部分</code> 有个印象就行。</p>
</blockquote>
<h1 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h1><blockquote>
<p>对于record_format_demo表来说，记录的真实数据除了 c1、c2、c3、c4 这几个我们自己定义的列的数据以外， <strong><code>MySQL会为每个记录默认的添加一些列(也称为隐藏列)</code></strong> ，具体的列如下:</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
<tr>
<td>Tips: 实际上这几个列的真正名称其实是: <code>DB_ROW_ID</code>、<code>DB_TRX_ID</code>、 <code>DB_ROLL_PTR</code>，我们为了美观才写成了row_id、 transaction_id和roll_pointer。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>这里需要提一下 <strong><code>InnoDB表对主键的生成策略</code></strong>:</p>
<ul>
<li>优先使用用户自定义的主键作为主键;</li>
<li>如果用户没有定义主键，则选取一个Unique键作为主键;</li>
<li>如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为<code>row_id</code> 的<code>隐藏列</code>作为主键。</li>
</ul>
<p>所以我们可以看出: InnoDB存储引擎会为每条记录都添加 <code>transaction_id</code> 和 <code>roll_pointer</code> 这两个列，但是 <code>row_id</code> 是可选的(在没有自定义主键及Unique键的情况下才会添加该列)。这些隐藏列的值不用我们操心，InnoDB存储引擎会自己帮我们生成的。</p>
<p>因为表record_format_demo示例表并没有定义主键，所以MySQL服务器会为每条记录增加上述的3个列。现在看一下加上记录的真实数据的、两个记录⻓什么样吧:<br><img src="/images/MySQL/4.1/14.jpg"><br>看这个图的时候我们需要注意几点:<br>表record_format_demo使用的是ascii字符集，所以0x61616161就表示字符串’aaaa’，0x626262就表示字符 串’bbb’，以此类推;</p>
<p>注意第1条记录中c3列的值，它是CHAR(10)类型的，虽然它实际存储的字符串是:’cc’(ascii字符集的字节表示是’0x6363’)，虽然表示这个字符串只需要用2个字节，但整个c3列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在ascii字符集的表示就是0x20。</p>
<p><strong><code>注意第2条记录中c3和c4列的值都为NULL，它们被存储在了前边的NULL值列表处，在记录的真实数据处就不再冗余存储，从而节省存储空间</code></strong> 。</p>
</blockquote>
<h1 id="字符集对-COMPACT-行格式的影响"><a href="#字符集对-COMPACT-行格式的影响" class="headerlink" title="字符集对 COMPACT 行格式的影响"></a>字符集对 COMPACT 行格式的影响</h1><p><code>COMPACT行格式</code>会受<code>字符集</code>的影响。</p>
<blockquote>
<p>以 <code>CHAR(M)列的存储格式</code> 为例<br>尽管我们说在 <code>Compact行格式</code> 下只会把<code>变⻓字段存储的实际数据的⻓度</code>逆序存到 <code>变⻓字段⻓度列表</code>中。 <strong><code>但其实除了考虑字段本身的类型是否是变长字段，还需要考虑字符集的影响</code></strong> 。</p>
<p>对于record_format_demo示例表的c1,c2,c4列来说，它们是变长字段，这个没毛病，但此时我们的表采用的是ascii字符集(这个字符集是一个定⻓字符集，一个字符采用固定的一个字节)。<br>如果采用变⻓的字符集(也就是表示一个字符需要的字节数不确定，比如gbk表示一个字符要1<del>2个字节、utf8表示一个字符要1</del>3个字节等)的话， <strong><code>此时c3列虽然是char(10)这种定长字段，但它的数据⻓度也会被存储到变⻓字段⻓度列表中</code></strong> 。</p>
</blockquote>
<blockquote>
<p>假如我们将record_format_demo表的字符集修改为utf8,修改该列字符集后记录的变⻓字段⻓度列表也发生了变化:<br><img src="/images/MySQL/4.1/15.jpg"></p>
<p>这就意味着:  <strong><code>对于 CHAR(M) 类型的列来说，当采用的是定⻓字符集时，该列实际数据占用的字节数不会被加到变⻓字段⻓度列表中; 而如果采用的是变⻓字符集时，该列实际数据占用的字节数也会被加到变⻓字段⻓度列表</code></strong> 。</p>
</blockquote>
<blockquote>
<p>Tips:<br>另外有一点还需要注意， <strong><code>变⻓字符集的CHAR(M)类型的列要求至少占用M个字节</code></strong> （utf8表示一个字符要1~3个字节），而VARCHAR(M)却没有这个要求。</p>
<p>比方说对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节⻓度的范围是10~30个字节。即使我们向该列中存储一个空字符串也会占用10个字节。这样的话，将来更新该列的值时，如果字节⻓度小于10个字节时，可以在该记录处直接更新，<code>而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片</code>。(这里你感受到设计Compact行格式的大叔既想节省存储空间，又不想更新CHAR(M)类型的列产生碎片时的纠结心情了吧。)</p>
</blockquote>
<h1 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a><del>Redundant行格式</del></h1><blockquote>
<p><del>其实知道了Compact行格式之后，其他的行格式就是依葫芦画瓢了。我们现在要介绍的Redundant行格式是MySQL5.0之前用的一种行格式，也就是说它已经非常老了，大家乐呵乐呵的看就好。</del></p>
<p>……</p>
<p><del><strong><code>Redundant行格式: CHAR(M) 不会产生碎片</code></strong><br>我们知道<code>Compact行格式</code>在<code>CHAR(M)类型</code>的列中存储数据的时候还挺麻烦，分 <code>变⻓字符集</code> 和 <code>定⻓字符集</code> 的情况，而在Redundant行格式中十分干脆，不管该列使用的字符集是啥，只要是使用<code>CHAR(M)</code>类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和M的乘积。<br>比方说使用utf8字符集的CHAR(10)类型的列占用的真实数据空间始终为30个字节，使用gbk字符集的CHAR(10)类型的列占用的真实数据空间始终为20个字节。由此可以看出来，使用Redundant行格式的CHAR(M)类型的列是不会产生碎片的。</del></p>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/4.0 InnoDB记录存储结构 之 页的概念、行格式的概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/18/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.0%20InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E4%B9%8B%20%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5/">4.0 InnoDB记录存储结构 之 页的概念、行格式的概念</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-18T12:01:19.000Z" itemprop="datePublished">2021年09月18日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/18/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/4.0%20InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%20%E4%B9%8B%20%E9%A1%B5%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>到现在为止，MySQL对于我们来说还是一个黑盒。我们只是简单使用客户端发送请求并等待服务器返回结果。至于 <code>表中的数据到底存到了哪里?</code> <code>以什么格式存放的?</code> <code>MySQL是以什么方式来访问的这些数据?</code> 这些问题我们统统不知道。</p>
</blockquote>
<blockquote>
<p>不过前面已经多次提到， <strong>MySQL服务器上负责对表中数据的读取和写入工作的部分是<code>存储引擎</code></strong> 。<br>MySQL服务器支持多种不同类型的存储引擎(如InnoDB、MyISAM、Memory……)，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，<code>真实数据在不同存储引擎中存放的方式一般是不同的</code>，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p>
</blockquote>
<blockquote>
<p>由于<code>InnoDB</code>是MySQL<code>默认的存储引擎</code>，也是我们最常用到的存储引擎，我们也没有那么多时间去把各个存储引擎的内部实现都看一遍，所以本集要唠叨的是使用InnoDB作为存储引擎时的<code>数据存储结构</code>，了解了一个存储引擎的数据存储结构之后，其他的存储引擎都是依葫芦画瓢，等以后用到了再说~</p>
</blockquote>
<h1 id="InnoDB存储引擎中⻚的概念"><a href="#InnoDB存储引擎中⻚的概念" class="headerlink" title="InnoDB存储引擎中⻚的概念"></a>InnoDB存储引擎中<code>⻚</code>的概念</h1><blockquote>
<p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。</p>
</blockquote>
<blockquote>
<p>不过，尽管InnoDB是将数据存储到磁盘上的存储引擎，<code>但真正处理数据的过程却是发生在内存中的</code>，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。</p>
<p>而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，<code>InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么?</code><br><strong>不，那样会慢死，InnoDB采取的方式是: 将数据划分为若干个<code>⻚</code>，<code>以⻚作为磁盘和内存之间交互的基本单位</code>，InnoDB 中⻚的大小一般为16KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</strong></p>
</blockquote>
<h1 id="InnoDB引擎的行格式-记录格式"><a href="#InnoDB引擎的行格式-记录格式" class="headerlink" title="InnoDB引擎的行格式(记录格式)"></a>InnoDB引擎的行格式(记录格式)</h1><blockquote>
<p>我们平时是以<code>行</code>(也叫<code>记录</code>)为单位来向表中插入数据的，这些<code>记录</code>在磁盘上的存放方式也被称为<code>行格式</code>或者<code>记录格式</code>。</p>
</blockquote>
<blockquote>
<p>设计InnoDB存储引擎的大叔们到现在为止设计了<code>4种不同类型的行格式</code>，分别是 <code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code> 和 <code>Compressed</code> 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。</p>
</blockquote>
<blockquote>
<p><strong>如何指定表的行格式？</strong><br>我们可以在创建或修改表的语句中指定行格式:<br>&#x2F;&#x2F; 语法如下<br><code>CREATE TABLE 表名 (</code><br>    <code>列的信息</code><br><code>) ROW_FORMAT=行格式名称</code></p>
<p><code>ALTER TABLE 表名 ROW_FORMAT=行格式名称</code></p>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/3. 字符集和比较规则" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/14/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/3.%20%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/">3. 字符集和比较规则</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-14T14:53:41.000Z" itemprop="datePublished">2021年09月14日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/14/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/3.%20%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="字符集的概念"><a href="#字符集的概念" class="headerlink" title="字符集的概念"></a><code>字符集</code>的概念</h1><blockquote>
<p>我们知道在计算机中只能存储二进制数据，那该怎么存储字符串呢?  <strong><code>当然是建立字符与二进制数据的映射关系了</code></strong> ，建立这个关系最起码要搞清楚两件事儿:</p>
<ol>
<li>你要把哪些字符映射成二进制数据? (其实就是字符集要包含的 <code>字符范围</code>)</li>
<li>怎么映射? (其实就是 <code>编码规则</code>)<br>将一个字符映射成一个二进制数据的过程也叫做<code>编码</code>，将一个二进制数据映射到一个字符的过程叫做<code>解码</code>。</li>
</ol>
<p>为此，人们抽象出了一个叫 <code>字符集</code> 的概念来描述某个<code>字符范围</code>的<code>编码规则</code>。</p>
</blockquote>
<blockquote>
<p>比方说，我们现在可以自定义一个名称为 xiaohaizi 的字符集，它包含的 <code>字符范围</code> 和 <code>编码规则</code> 如下:</p>
<ul>
<li><code>字符范围</code>: 包含字符：’a’、’b’、’A’、’B’ ；</li>
<li><code>编码规则</code>是：采用1个字节编码一个字符，字符和字节的映射关系如下:<br>‘a’ -&gt; 00000001 (十六进制:0x01)<br>‘b’ -&gt; 00000010 (十六进制:0x02)<br>‘A’ -&gt; 00000011 (十六进制:0x03)<br>‘B’ -&gt; 00000100 (十六进制:0x04)</li>
</ul>
<p>有了 xiaohaizi 这个字符集后，我们就可以用二进制形式表示一些字符串了，下边是一些字符串用 xiaohaizi 这个字符集编码后的二进制表示:<br>bA’ -&gt; 00000010 00000011 (十六进制:0x0203)<br>‘baB’ -&gt; 00000010 00000001 00000100 (十六进 制:0x020104)<br>‘cd’ -&gt; 无法表示，因为字符集xiaohaizi不包含字符’c’和’d’</p>
</blockquote>
<p>所以，<code>字符集</code> 其实就是通过制定 <code>字符范围</code> 和 <code>编码规则</code>  来将日常字符数据映射到计算机能存储的二进制数据的一套规则。</p>
<h1 id="比较规则的概念"><a href="#比较规则的概念" class="headerlink" title="比较规则的概念"></a><code>比较规则</code>的概念</h1><blockquote>
<p>在我们确定了xiaohaizi字符集表示字符的范围以及编码规则后，怎么比较两个字符的大小呢?</p>
</blockquote>
<blockquote>
<p>最容易想到的就是直接比较这两个字符对应的二进制编码的大小，比方说字符’a’的编码为0x01，字符’b’的编码为0x02，所以’a’小于’b’，这种简单的比较规则也可以被称为<code>二进制比较规则</code>，英文名为<code>binary collation</code>。</p>
<p><code>二进制比较规则</code> 非常简单，但有时候并不符合现实需求，比如在很多场合对于英文字符我们都是不区分大小写的，也就是说’a’和’A’是相等的，在这种场合下就不能简单粗暴的使用二进制比较规则了，这时候我们可以这样指定比较规则:</p>
<ul>
<li>将两个大小写不同的字符全都转为大写或者小写。</li>
<li>然后再比较这两个字符对应的二进制数据。</li>
</ul>
<p>这是一种稍微复杂一点点的比较规则，但是实际生活中的字符不止英文字符一种，比如我们的汉字有几万几十万之多，<code>即便对于某一种字符集来说，比较两个字符大小的规则也可以制定出很多种</code>。<br>后面会介绍各种现实生活中用的字符集以及它们的一些比较规则。</p>
</blockquote>
<h1 id="一些重要的字符集"><a href="#一些重要的字符集" class="headerlink" title="一些重要的字符集"></a>一些重要的字符集</h1><p>不幸的是，这个世界太大了，不同的人制定出了<code>好多种字符集</code>，每个字符集表示的<code>字符范围</code>和用到的<code>编码规则</code>可能都不一样。我们看一下一些常用字符集的情况:</p>
<h2 id="ASCII字符集"><a href="#ASCII字符集" class="headerlink" title="ASCII字符集"></a>ASCII字符集</h2><blockquote>
<p><code>字符范围</code>：共收录128个字符<br>包括空格、标点符号、数字、大小写字母 和一些不可⻅字符。</p>
</blockquote>
<blockquote>
<p><code>编码规则</code>：由于总共才128个字符，所以可以使用1个字节来进行编码，我们简单看一下该字符集的编码方式:<br>‘L’ -&gt; 01001100(十六进制:0x4C，十进制:76)<br>‘M’ -&gt; 01001101(十六进制:0x4D，十进制:77)</p>
</blockquote>
<h2 id="ISO-8859-1字符集"><a href="#ISO-8859-1字符集" class="headerlink" title="ISO 8859-1字符集"></a>ISO 8859-1字符集</h2><p>这个字符集有一个别名 <code>latin1</code></p>
<blockquote>
<p><code>字符范围</code>：共收录256个字符，是在ASCII字符集的基础上又扩充了128个⻄欧常用字符(包括德法两国的字母);</p>
</blockquote>
<blockquote>
<p><code>编码 方式/规则/方案</code>：它也是使用1个字节来进行编码。</p>
</blockquote>
<h2 id="GB2312字符集"><a href="#GB2312字符集" class="headerlink" title="GB2312字符集"></a>GB2312字符集</h2><blockquote>
<p><code>字符范围</code>：收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语⻄里尔字母。其中收录汉字6763个，其他文字符号682个。</p>
</blockquote>
<blockquote>
<p><code>编码规则</code>：同时这种字符集又兼容ASCII字符集，所以在编码方式上显得有些奇怪:</p>
<ul>
<li><code>如果该字符在ASCII字符集中，则采用1字节编码</code>。</li>
<li><code>否则采用2字节编码</code>。</li>
</ul>
<p>这种表示一个字符需要的字节数可能不同的编码方式称为<code>变⻓编码方式</code>。<br>比方说字符串’爱u’，其中’爱’需要用2个字节进行编码，编码后的十六进制表示为0xCED2;<br>而’u’只需要用1个字节进行编码，编码后的十六进制表示为0x75;<br>所以拼合起来就是0xCED275。</p>
</blockquote>
<blockquote>
<p>⚠️ Tips:<br>我们怎么区分某个字节代表一个单独的字符还是代表某个字符的一部分呢?<br>别忘了ASCII字符集只收录128个字符，使用0<del>127就可以表示全部字符(只用到了01111111 一个字节的前7位)，所以如果某个字节是在0</del>127之内的(如果第8个字节是0)，就意味着一个字节代表一个单独的字符，否则就是两个字节代表一个单独的字符。</p>
</blockquote>
<h2 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h2><blockquote>
<p><code>字符范围</code>： GBK字符集只是在收录字符范围上对GB2312字符集作了扩充；</p>
</blockquote>
<blockquote>
<p><code>编码方式</code>: 兼容GB2312；</p>
</blockquote>
<h2 id="utf8字符集"><a href="#utf8字符集" class="headerlink" title="utf8字符集"></a>utf8字符集</h2><blockquote>
<p><code>字符范围</code>: 收录地球上能想到的所有字符，而且还在不断扩充。</p>
</blockquote>
<blockquote>
<p><code>编码方式</code>: 这种字符集兼容ASCII字符集，采用<code>变⻓编码方式</code>，编码一个字符需要使用<code>1~4个字节</code>，比方说这样:<br>‘L’ -&gt; 01001100(十六进制:0x4C)<br>‘啊’ -&gt; 111001011001010110001010(十六进 制:0xE5958A)</p>
</blockquote>
<blockquote>
<p>⚠️ Tips:<br>其实准确的说，<code>utf8</code>并不是一个<code>字符集</code>，它只是<code>Unicode字符集</code>的一种<code>编码方案</code>。Unicode字符集可以采用utf8、utf16、utf32这几种编码方案：</p>
<ul>
<li>utf8使用1~4个字节编码一个字符；</li>
<li>utf16使用2个或4个字节编码一个字符；</li>
<li>utf32使用4个字节编码一个字符。</li>
</ul>
<p>更详细的Unicode和其编码方案的知识不是本书的重点，大家上网查查哈~</p>
<p>虽然 <code>编码方案</code> 只是 <code>字符集</code> 内包含的一部分功能，但 <strong><code>MySQL中并不区分字符集和编码方案的概念</code>，所以后边唠叨的时候把utf8、utf16、utf32都当作一种<code>字符集</code>对待</strong>。</p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>字符集</code>的概念包括<code>字符范围</code>和<code>编码规则</code>两部分功能；<br>可以对<code>字符集</code>制定多种不同的<code>比较规则</code>；</p>
<p><code>utf8</code>并不是一个<code>字符集</code>，它只是<code>Unicode字符集</code>的一种<code>编码方案</code>；</p>
<p>MySQL中并不区分<code>字符集</code>和<code>编码方案</code>的概念<code>，所以后边唠叨的时候把 utf8、utf16、utf32都当作一种</code>字符集&#96;对待。</p>
<h1 id="MySQL中支持的字符集和排序规则"><a href="#MySQL中支持的字符集和排序规则" class="headerlink" title="MySQL中支持的字符集和排序规则"></a>MySQL中支持的字符集和排序规则</h1><h2 id="MySQL中的-utf8-和-utf8mb4"><a href="#MySQL中的-utf8-和-utf8mb4" class="headerlink" title="MySQL中的 utf8 和 utf8mb4"></a>MySQL中的 <code>utf8</code> 和 <code>utf8mb4</code></h2><blockquote>
<p>我们上边说<code>utf8字符集</code>表示一个字符需要使用<code>1~4个字节</code>，但是我们常用的一些字符使用1~3个字节就可以表示了。而在MySQL中字符集表示一个字符所用最大字节⻓度在某些方面会影响系统的存储和性能，所以设计MySQL的大叔偷偷的定义了两个概念:</p>
</blockquote>
<ul>
<li><code>utf8mb3</code>: 阉割过的utf8字符集，只使用<code>1~3个字节</code>表示字符。</li>
<li><code>utf8mb4</code>: 正宗的utf8字符集，使用1~4个字节表示字符。</li>
</ul>
<blockquote>
<p>有一点需要大家十分的注意，在MySQL中<code>utf8</code>是<code>utf8mb3</code>的别名，所以之后在MySQL中提到utf8就意味着使用1~3个字节来表示一个字符， <strong><code>如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用utf8mb4</code></strong> 。</p>
</blockquote>
<h2 id="字符集的查看"><a href="#字符集的查看" class="headerlink" title="字符集的查看"></a>字符集的查看</h2><blockquote>
<p>MySQL支持好多好多种字符集，查看当前MySQL中支持的字符集可以用 <code>SHOW (CHARSET) [LIKE 匹配的模式];</code>  这个语句:<br>我们查询一下(支持的字符集太多了，我们省略了一些)，为了让大家的印象更深刻，下面把几个常用到的字符集的Maxlen列摘抄下来，大家务必记住:</p>
<table>
<thead>
<tr>
<th>字符集名称</th>
<th>Maxlen</th>
</tr>
</thead>
<tbody><tr>
<td>ascii</td>
<td>1</td>
</tr>
<tr>
<td>latin1</td>
<td>1</td>
</tr>
<tr>
<td>gb2312</td>
<td>2</td>
</tr>
<tr>
<td>gbk</td>
<td>2</td>
</tr>
<tr>
<td>utf8</td>
<td>3</td>
</tr>
<tr>
<td>utf8mb4</td>
<td>4</td>
</tr>
</tbody></table>
</blockquote>
<h2 id="比较规则的查看"><a href="#比较规则的查看" class="headerlink" title="比较规则的查看"></a>比较规则的查看</h2><blockquote>
<p>查看MySQL中支持的比较规则的命令为: <code>SHOW COLLATION [LIKE 匹配的模式];</code></p>
</blockquote>
<blockquote>
<p>我们前边说过<code>一种字符集</code>可能对应着<code>若干种比较规则</code>，MySQL支持的字符集就已经非常多了，所以支持的比较规则更多，我们先只查看一下utf8字符集下的比较规则:<code>SHOW COLLATION LIKE &#39;utf8%&#39;;</code></p>
<p>每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则，<code>SHOW COLLATION</code>的返回结果中的<code>Default列</code>的值为<code>YES</code>的就是该字符集的默认比较规则，比方说utf8字符集默认的比较规则就是<code>utf8_general_ci</code>。</p>
</blockquote>
<h1 id="各级别的字符集和比较规则"><a href="#各级别的字符集和比较规则" class="headerlink" title="各级别的字符集和比较规则"></a>各级别的字符集和比较规则</h1><p>MySQL有4个级别的字符集和比较规则，分别是:</p>
<ul>
<li>服务器级别<blockquote>
<p>MySQL提供了两个系统变量来表示服务器级别的字符集和比较规则<br><code>character_set_server 服务器级别的字符集 </code><br><code>collation_server 服务器级别的比较规则</code></p>
<p>我们可以在启动服务器程序时通过<code>启动选项</code>或者在服务器程序运行过程中使用SET语句修改这两个变量的值。<br>比如我们可以在配置文件中这样写:<br><code>[server]</code><br><code>character_set_server=gbk</code><br><code>collation_server=gbk_chinese_ci</code></p>
</blockquote>
</li>
<li>数据库级别<blockquote>
<p>我们在创建和修改数据库时可以指定该数据库的字符集和比较规则；<br>如果想查看当前数据库使用的字符集和比较规则，可以查看下面两个系统变量的值；<br><code>character_set_database</code> 和 <code>collation_database</code> 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的 字符集和比较规则<br>数据库的创建语句中也可以不指定字符集和比较规则，这样的话将使用服务器级别的字符集和比较规则作为数据库的字符集和比较规则；</p>
</blockquote>
</li>
<li>表级别<blockquote>
<p>我们也可以在创建和修改表的时候指定表的字符集和比较规则<br>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则</p>
</blockquote>
</li>
<li>列级别<blockquote>
<p>需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以 有不同的字符集和比较规则。<br>对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较 规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比 较规则。</p>
</blockquote>
</li>
</ul>
<h1 id="客户端和服务器通信中的字符集"><a href="#客户端和服务器通信中的字符集" class="headerlink" title="客户端和服务器通信中的字符集"></a>客户端和服务器通信中的字符集</h1><blockquote>
<p>如果对于同一个字符串编码和解码使用的<code>字符集</code>不一样，会产生意想不到的结果，作为人类的我们看上去就像是产生了<code>乱码</code>一样。</p>
</blockquote>
<blockquote>
<p>我们知道从客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符串，而字符串其实是使用某种字符集编码的二进制数据。这个字符串可不是使用一种字符集的编码方式一条道走到黑的，从发送请求到返回结果这个过程中伴随着多次字符集的转换，在这个过程中会用到<code>3个系统变量</code>，我们先把它们写出来看一下:</p>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>character_set_client</code></td>
<td>服务器解码请求时使用的字符集</td>
</tr>
<tr>
<td><code>character_set_connection</code></td>
<td>服务器运行过程中使用的字符集</td>
</tr>
<tr>
<td><code>character_set_results</code></td>
<td>服务器向客户端返回数据时使用的字符集</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><strong>我们通常都把 <code>character_set_client</code> 、<code>character_set_connection</code>、<code>character_set_results</code> 这三个 系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换。</strong></p>
<p>为了方便我们设置，MySQL提供了一条非常简便的语句: <code>SET NAMES 字符集名;</code> 这一条语句产生的效果和下面这3条的效果是一样的:<br><code>SET character_set_client = 字符集名;</code><br><code>SET character_set_connection = 字符集名;</code><br><code>SET character_set_results = 字符集名;</code></p>
</blockquote>
<blockquote>
<p>另外，如果你想在启动客户端的时候就把这三个系统变量的值设置成一样的，那我们可以在启动客户端的时候指定一个叫<code>default-character-set</code>的启动选项，比如在配置文件里可以这么写:<br><code>[client]</code><br><code>default-character-set=utf8</code><br>它起到的效果和执行一遍 <code>SET NAMES utf8</code> 是一样一样的，都会将那三个系统变量的值设置成utf8。<br>lant: 这怪方便，只用设置这个，mysql启动后，所有的客户端都连接上来都会先设置这三个系统变量…. 妥妥的无乱码喽</p>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/2. MySQL的启动选项和配置文件、系统变量、状态变量" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/14/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/2.%20MySQL%E7%9A%84%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%81%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E3%80%81%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F/">2. MySQL的启动选项和配置文件、系统变量、状态变量</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-14T13:17:21.000Z" itemprop="datePublished">2021年09月14日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/14/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/2.%20MySQL%E7%9A%84%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%81%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E3%80%81%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL的启动选项"><a href="#MySQL的启动选项" class="headerlink" title="MySQL的启动选项"></a>MySQL的<code>启动选项</code></h1><blockquote>
<p>MySQL的 服务器程序 和 客户端程序 都有很多的<code>设置项</code>:</p>
<ul>
<li>比如 <code>MySQL服务器程序</code> 可以指定像 <code>允许同时连入的客户端数量</code>、<code>客户端和服务器通信方式</code>、<code>表的默认存储引擎</code>、<code>查询缓存的大小</code>…等 <code>设置项</code>。</li>
<li>对于<code>MySQL客户端程序</code>，则可以指定像 <code>需要连接的服务器程序所在主机的主机名或IP地址</code>、<code>用户名</code>及<code>密码</code>等信息。</li>
</ul>
</blockquote>
<blockquote>
<p>这些<code>设置项</code>一般都有各自的默认值，比方说<code>服务器允许同时连入的客户端的默认数量是151</code>，<code>表的默认存储引擎是InnoDB</code>。</p>
<p><strong>我们可以在程序启动的时候去修改这些默认值，对于这种在程序启动时指定的<code>设置项</code>也称之为<code>启动选项(startup options)</code>，这些选项控制着程序启动后的行为</strong>。</p>
</blockquote>
<blockquote>
<p>在MySQL安装目录下的<code>bin目录</code>中的各种<code>可执行文件</code>，不论是服务器相关的程序(比如<code>mysqld</code>、<code>mysqld_safe</code>)还是客户端相关的程序(比如<code>mysql</code>、<code>mysqladmin</code>)， <strong>在启动时基本都可以指定<code>启动参数</code></strong> 。</p>
<p>这些<code>启动参数</code>可以放在<code>命令行</code>中指定，也可以把它们放在<code>配置文件</code>中指定。</p>
</blockquote>
<pre><code>下面会以`mysqld`为例，来详细唠叨如何指定`启动选项`。下边出现的`启动选项不`论大家认不认识，先不用去纠结每个选项具体的作用是啥，之后我们会对一些重要的启动选项详细唠叨。
</code></pre>
<h1 id="在命令行上设置启动选项"><a href="#在命令行上设置启动选项" class="headerlink" title="在命令行上设置启动选项"></a>在命令行上设置启动选项</h1><blockquote>
<p>通过上一篇的学习，我们已经知道，如果我们在启动客户端程序时在<code>-h参数</code>后边紧跟服务器的IP地址，这就意味着客户端和服务器之间需要通过<code>TCP/IP网络</code>进行通信（当然，如果ip指定的是 127.0.0.1，那也可能是通过 <code>unix套接字进行通信</code>）。</p>
</blockquote>
<blockquote>
<p>如果我们在启动服务器程序时，想禁止各客户端使用TCP&#x2F;IP网络与服务器程序进行通信，则可以在<code>启动服务器程序的命令行</code>里添加 <code>skip-networking</code> 启动选项，如: <code>mysqld --skip-networking</code></p>
<p>Tips：<br>在命令行中指定启动选项时需要在选项名前加上 <code>--前缀</code>。<br>如果选项名是由多个单词构成的，它们之间可以由<code>短划线-</code>连接起来，也可以使用<code>下划线_</code>连接起来，也就是说 <code>skip-networking</code> 和 <code>skip_networking</code> 表示的含义是相同的。</p>
<p>在按照上述命令启动服务器程序后，如果我们再使用mysql来启动客户端程序时，仍把服务器主机名指定为127.0.0.1(IP地址的形式)的话，就会显示连接失败。这就意味着我们指定的启动选项 skip-networking 生效了!</p>
</blockquote>
<hr>
<blockquote>
<p>再举一个例子，我们前边说过如果在创建表的语句中没有显式指定表的存储引擎的话，则会默认使用InnoDB作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行: <code>mysqld --default-storage-engine=MyISAM</code>。<br>这下，你再次建表时即便没有明确指定表的存储引擎，建表成功后通过 <code>SHOW CREATE TABLE 表名\G</code> 会发现表已经是 MyISAM 引擎了。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>小结：</strong><br>在启动服务器程序的命令行后边指定启动选项的通用格式是 <code>--启动选项1[=值1] --启动选项2[=值2] ... --启动选项n[= 值n]</code></p>
<p>即，我们可以将多个启动选项写到一行，各个启动选项间用空白字符隔开，在每个启动选项名称前边添加<code>--</code>。<br>对于不需要值的启动选项，比方说 <code>skip-networking</code>，它们就不需要指定对应的值。<br>对于需要指定值的启动选项，比如<code>default-storage-engine</code>,我们在指定这个设置项的时候需要显式的指定它的值。</p>
<p>在命令行上指定有值的启动选项时，需要注意，<code>选项名、=、选项值之间不可以有空白字符</code>。</p>
<p>每个MySQL程序都有许多不同的启动选项。大多数程序提供了一个 <code>--help</code> 选项来查看该程序支持的全部启动选项以及它们的默认值。例如，使用 <code>mysql --help</code> 可以看到mysql程序支持的启动选项，<code>mysqld_safe --help</code> 可以看mysqld_safe程序支持的启动选项。查看mysqld支持的启动选项有些特别，需要使用 <code>mysqld --verbose --help</code>。</p>
</blockquote>
<h1 id="启动选项的⻓形式和短形式"><a href="#启动选项的⻓形式和短形式" class="headerlink" title="启动选项的⻓形式和短形式"></a>启动选项的⻓形式和短形式</h1><blockquote>
<p>我们前边提到的 <code>skip-networking</code>、<code>default-storage-engine</code>称之为<code>⻓形式的选项</code>，设计MySQL的大叔为了我们使用的方便，对于一些常用的选项提供了<code>短形式</code>，我们列举一些具有短形式的启动选项来瞅瞅(MySQL支持的短形式选项太多了，全列出来会刷屏的)</p>
<table>
<thead>
<tr>
<th>⻓形式</th>
<th>短形式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>host</td>
<td>-h</td>
<td>主机名</td>
</tr>
<tr>
<td>–user</td>
<td>-u</td>
<td>用户名</td>
</tr>
<tr>
<td>–password</td>
<td>-p</td>
<td>密码</td>
</tr>
<tr>
<td>–port</td>
<td>-P</td>
<td>端口</td>
</tr>
<tr>
<td>–version</td>
<td>-V</td>
<td>版本信息</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>短形式的选项名只有一个字母，与使用⻓形式选项时需要在选项名前加<code>--前缀</code>不同的是，使用短形式选项时在选项名前只加一个短划线<code>-前缀</code>。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>使用短形式指定启动选项时，选项名和选项值之间可以无间隙，也可以用空白字符隔开(-p选项有些特殊，-p和密码值之间不能有空白字符)。(<strong>得了，无论 短形式 还是 长形式，选项名和选项值之间都别有空格就行了</strong>)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h1 id="在配置文件中设置启动选项"><a href="#在配置文件中设置启动选项" class="headerlink" title="在配置文件中设置启动选项"></a>在配置文件中设置启动选项</h1><blockquote>
<p>在命令行中设置启动选项只对当次启动生效，下次重启程序时还得在启动命令行中加这些<code>启动选项</code>! 于是设计MySQL的大叔们提出 <code>配置文件</code>(也称为<code>选项文件</code>)的概念，我们把需要设置的启动选项都写在这个配置文件中，每次启动服务器时都从这个文件里加载相应的启动选项。由于这个配置文件可以⻓久的保存在计算机的硬盘里，所以只需我们配置一次，以后就都不用显式的把启动选项都写在启动命令行中了， <strong><code>所以我们推荐使用配置文件的方式来设置启动选项</code></strong> 。</p>
</blockquote>
<blockquote>
<p><strong>配置文件的路径</strong>:<br> MySQL程序在启动时会寻找多个路径下的配置文件，这些路径有的是固定的，有的是可以在命令行指定的。根据操作系统的不同，配置文件的路径也有所不同，这里重点看下类unix系统。</p>
<p>在类UNIX操作系统中，MySQL会按照下列路径来寻找配置文件:</p>
<table>
<thead>
<tr>
<th>路径名</th>
<th>备注</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;my.cnf</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#x2F;etc&#x2F;mysql&#x2F;my.cnf</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SYSCONFDIR&#x2F;my.cnf</td>
<td></td>
<td>SYSCONFDIR 表示在使用CMake构建MySQL时使用SYSCONFDIR选项指定的目录。默认情况下，这是位于编译安装目录下的etc目录。</td>
</tr>
<tr>
<td>$MYSQL_HOME&#x2F;my.cnf</td>
<td>特定于服务器的选项(仅限服务器)</td>
<td>MYSQL_HOME是一个环境变量，该变量的值是我们自己设置的，我们想设置就设置，不想设置就不设置。该变量的值代表一个路径，我们可以在该路径下创建一个my.cnf配置文件。这个配置文件中只能放置关于启动服务器程序相关的选项(言外之意就是其他的配置文件既能存放服务器相关的选项也 能存放客户端相关的选项，.mylogin.cnf除外，它只能存放客户端相关的一些选项)。</td>
</tr>
<tr>
<td>defaults-extra-file</td>
<td>命令行指定的额外配置文件路径</td>
<td></td>
</tr>
<tr>
<td>~&#x2F;.my.cnf</td>
<td>用户特定选项</td>
<td></td>
</tr>
<tr>
<td>~&#x2F;.mylogin.cnf</td>
<td>用户特定的登录路径选项(仅限客户端)</td>
<td>.mylogin.cnf 不是纯文本文件，只能使用mysql_config_editor实用程序去创建或修改，用于存放客户端登陆服务器时的相关选 项。</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>这也就是说，在我的计算机中这几个路径中的任意一个都可以当作配置文件来使用，如果它们不存在，你可以手动创建一个。</p>
<p>另外，我们在唠叨如何启动MySQL服务器程序的时候说过，使用mysqld_safe程序启动服务器时，会间接调用mysqld，所以对于传递给mysqld_safe的启动选项来说，如果mysqld_safe程序<br>不处理，会接着传递给mysqld程序处理。比方说skip-networking选项是由mysqld处理的，mysqld_safe并不处理。</p>
</blockquote>
<blockquote>
<p><strong>配置文件的内容:</strong><br>与在命令行中指定启动选项不同的是，配置文件中的<code>启动选项</code>被划分为若干个组，每个组有一个组名，用中括号<code>[]</code>扩起来，像这样:</p>
<p><code>[server] </code><br><code>(具体的启动选项...)</code><br><code>[mysqld] </code><br><code>(具体的启动选项...)</code><br><code>[mysqld_safe] </code><br><code>(具体的启动选项...)</code><br><code>[client] </code><br><code>(具体的启动选项...)</code><br><code>[mysql] </code><br><code>(具体的启动选项...)</code><br><code>[mysqladmin] </code><br><code>(具体的启动选项...)</code></p>
<p>每个组下边可以定义若干个启动选项，我们以[server]组为例来看一下填写启动选项的形式<br><code>[server]</code><br><code>option1 #这是option1，该选项不需要选项值</code><br><code>option2 = value2 #这是option2，该选项需要选项值 ...</code></p>
</blockquote>
<blockquote>
<p>在配置文件中指定启动选项的语法类似于命令行语法，但是<code>配置文件中只能使用⻓形式的选项</code>。在配置文件中指定的启动选项<code>不允许加--前缀</code>，并且每行只指定一个选项，而且&#x3D;周围可以有空白字符。另外，在配置文件中，我们可以使用#来添加注释，从#出现直到行尾的内容都属于注释内容，读取配置文件时会忽略这些注释内容。</p>
</blockquote>
<hr>
<blockquote>
<p><code>配置文件中不同的选项组是给不同的启动命令使用的</code>，如果选项组名称与程序名称相同，则组中的选项将专⻔应用于该程序。例如，<code>[mysqld]</code> 和 <code>[mysql]</code>  组分别应用于<code>mysqld服务器程序</code> 和 <code>mysql客户端程序</code>。不过有两个选项组比较特别:</p>
<ul>
<li><code>[server]组</code>下边的启动选项将作用于所有的服务器程序。</li>
<li><code>[client]组</code>下边的启动选项将作用于所有的客户端程序。</li>
</ul>
<p>不过， 需要注意的一点是，mysqld_safe和mysql.server这两个程序在启动时都会读取[mysqld]选项组中的内容。</p>
<p>为了直观感受一下，我们挑一些启动命令来看一下它们能读取的选项组都有哪些:</p>
<table>
<thead>
<tr>
<th>启动命令</th>
<th>类别</th>
<th>能读取的组</th>
</tr>
</thead>
<tbody><tr>
<td>mysqld</td>
<td>启动服务器</td>
<td>[mysqld]、[server]</td>
</tr>
<tr>
<td>mysqld_safe</td>
<td>启动服务</td>
<td>[mysqld]、[server]、[mysqld_safe]</td>
</tr>
<tr>
<td>mysql.server</td>
<td>启动服务</td>
<td>[mysqld]、[server]、[mysql.server]</td>
</tr>
<tr>
<td>mysql</td>
<td>启动客户端</td>
<td>[mysql]、[client]</td>
</tr>
<tr>
<td>mysqladmin</td>
<td>启动客户端</td>
<td>[mysqladmin]、[client]</td>
</tr>
<tr>
<td>mysqldump</td>
<td>启动客户端</td>
<td>[mysqldump]、[client]</td>
</tr>
</tbody></table>
</blockquote>
<hr>
<blockquote>
<p><strong>特定MySQL版本的专用选项组</strong><br>我们可以在选项组的名称后加上特定的MySQL版本号，比如对于 <code>[mysqld]选项组</code> 来说，我们可以定义一个 <code>[mysqld-5.7] 的选项组</code>，它的含义和 <code>[mysqld]</code> 一样，只不过只有版本号为5.7的 mysqld程序才能使用这个选项组中的选项。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>配置文件的优先级</strong><br>我们前边唠叨过MySQL将在某些固定的路径下搜索配置文件，我们也可以通过在命令行上指定<code>defaults-extra-file启动选项</code> 来指定额外的配置文件路径。MySQL将按照我们在上表中给定的顺序依次读取各个配置文件，如果该文件不存在则忽略。值得注意的是，如果我们在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>同一个配置文件中多个组的优先级</strong><br>我们说同一个命令可以访问配置文件中的多个组，比如mysqld可以访问[mysqld]、[server]组，如果在同一个配置文件中的这些组里出现了同样的配置项，比如:<br><code>[server]</code><br><code>default-storage-engine=InnoDB</code><br><code>[mysqld]</code><br><code>default-storage-engine=MyISAM</code><br>那么，将以最后一个出现的组中的启动选项为准，因为[mysqld]组在[server]组后边，就以 [mysqld]组中的配置项为准。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>defaults-file的使用</strong><br>如果我们不想让MySQL到默认的路径下搜索配置文件(就是上表中列出的那些)，则可以在命令行指定<code>defaults-file选项</code><br>比如：<code>mysqld --defaults-file=/tmp/myconfig.txt</code>，在程序启动的时候将只在&#x2F;tmp&#x2F;myconfig.txt路径下搜索配置文件。如果文件不存在或无法访问，则会发生错误。</p>
<p>Tips: 注意<code>defaults-extra-file</code>和<code>defaults-file</code>的区别<br>使用<code>defaults-extra-file</code>可以指定额外的配置文件搜索路径 (也就是说那些固定的配置文件路径也会被搜索)。</p>
</blockquote>
<h1 id="命令行和配置文件中启动选项的区别"><a href="#命令行和配置文件中启动选项的区别" class="headerlink" title="命令行和配置文件中启动选项的区别"></a>命令行和配置文件中启动选项的区别</h1><p>在命令行上指定的绝大部分启动选项都可以放到配置文件中，但是有一些选项是专⻔为命令行设计的，比方说<code>defaults-extra-file</code>、<code>defaults-file</code>这样的选项本身就是为了指定配置文件路径的，再放在配置文件中使用就没啥意义了。剩下的一些只能用在命令行上而不能用到配置文件中的启动选项就不一一列举了，用到的时候再提。</p>
<p>另外有一点需要特别注意，如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准!</p>
<h1 id="系统变量简介"><a href="#系统变量简介" class="headerlink" title="系统变量简介"></a>系统变量简介</h1><blockquote>
<p>MySQL服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为<code>MySQL系统变量</code>。</p>
<ul>
<li>比如允许同时连入的客户端数量用系统变量 <code>max_connections</code> 表示</li>
<li>表的默认存储引擎用系统变量 <code>default_storage_engine</code> 表示</li>
<li>查询缓存的大小用系统变量 <code>query_cache_size</code> 表示</li>
</ul>
<p>MySQL服务器程序的系统变量有好几百条，我们就不一一列举了。<br>每个<code>系统变量</code>都有一个默认值，我们可以使用<code>命令行</code>或者<code>配置文件</code>中的选项在启动服务器时改变它们。 不过，<code>大多数的系统变量的值也可以在程序运行过程中修改，而无需停止并重新启动它</code>。</p>
</blockquote>
<h2 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h2><blockquote>
<p>可以使用 <code>SHOW VARIABLES [LIKE 匹配的模式];</code> 命令查看MySQL服务器程序支持的系统变量以及它们的当前值:<br>不过，由于系统变量实在太多了，如果我们直接使用 <code>SHOW VARIABLES</code> 查看的话就直接刷屏了，所以通常都会带一个LIKE过滤条件来查看我们需要的系统变量的值，比如:<br>mysql&gt; SHOW VARIABLES LIKE ‘default_storage_engine’;<br>+————————+——–+<br>| Variable_name          | Value  |<br>+————————+——–+<br>| default_storage_engine | InnoDB |<br>+————————+——–+<br>1 row in set (0.01 sec)</p>
<p>mysql&gt; SHOW VARIABLES like ‘max_connections’;<br>+—————–+——-+<br>| Variable_name   | Value |<br>+—————–+——-+<br>| max_connections | 151   |<br>+—————–+——-+<br>1 row in set (0.00 sec)</p>
<p>mysql&gt;</p>
</blockquote>
<h2 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h2><h3 id="通过启动选项设置系统变量"><a href="#通过启动选项设置系统变量" class="headerlink" title="通过启动选项设置系统变量"></a>通过启动选项设置系统变量</h3><blockquote>
<p>大部分的系统变量都可以通过启动服务器时传送<code>启动选项</code>的方式来进行设置。如何填写启动选项我们上边已经花了大篇幅来唠叨了，就是下边两种方式:</p>
<ul>
<li>通过命令行添加启动选项:<br>比方说我们在启动服务器程序时用命令: <code>mysqld --default-storage-engine=MyISAM --max-connections=10</code></li>
<li>通过配置文件添加启动选项:<br><code>[server] </code><br><code>default-storage-engine=MyISAM </code><br><code>max-connections=10</code></li>
</ul>
<p>有一点需要注意的是，对于启动选项来说，如果<code>启动选项名</code>由多个单词组成，各个单词之间用短划线-或者下划线_连接起来都可以，但是<strong>对应的 <code>系统变量</code> 之间必须使用<code>下划线_</code>连接起来</strong>。</p>
</blockquote>
<h3 id="服务器程序运行过程中设置系统变量"><a href="#服务器程序运行过程中设置系统变量" class="headerlink" title="服务器程序运行过程中设置系统变量"></a>服务器程序运行过程中设置系统变量</h3><blockquote>
<p>系统变量比较牛逼的一点就是，对于大部分系统变量来说，<strong>它们的值可以在服务器程序运行过程中进行动态修改而无需停止并重启服务器</strong>。不过系统变量有作用范围之分，下边详细唠叨下。</p>
</blockquote>
<blockquote>
<p><strong>系统变量的不同作用范围</strong><br>我们前边说过，多个客户端程序可以同时连接到一个服务器程序。<br>对于同一个系统变量，我们有时想让不同的客户端有不同的值。</p>
<blockquote>
<p>比方说狗哥使用客户端A，他想让当前客户端对应的默认存储引擎为InnoDB，所以他可以把系统变量default_storage_engine的值设置为InnoDB; 猫爷使用客户端B，他想让当前客户端对应的默认存储引擎为MyISAM，所以他可以把系统变量default_storage_engine的值设置为MyISAM。这样可以使狗哥和猫爷的的客户端拥有不同的默认存储引擎，使用时互不影响，十分方便。但是这样各个客户端都私有一份系统变量会产生这么两个问题:</p>
</blockquote>
<ul>
<li>有一些系统变量并不是针对单个客户端的，比如允许同时连接到服务器的客户端数量max_connections，查询缓存的大小query_cache_size，这些公有的系统变量让某个客户端私有显然不合适。</li>
<li>一个新连接到服务器的客户端对应的系统变量的值该怎么设置?</li>
</ul>
</blockquote>
<blockquote>
<p>为了解决这两个问题，设计MySQL的大叔提出了<code>系统变量的作用范围</code>的概念，具体来说作用范围分为这两种:</p>
<ul>
<li>GLOBAL:全局变量，影响服务器的整体操作。</li>
<li>SESSION:会话变量，影响某个客户端连接的操作。(注:SESSION有个别名叫LOCAL)</li>
</ul>
<p>在服务器启动时，会将每个全局变量初始化为其默认值(可以通过<code>命令行</code>或<code>配置文件</code>中指定的选项更改这些默认值)。然后服务器还为每个连接的客户端维护一组会话变量，客户端的会话变量在连接时使用相应全局变量的当前值初始化。<br>以default_storage_engine举例，在服务器启动时会初始化一个名为default_storage_engine，作用范围为GLOBAL的系统变量。之后每当有一个客户端连接到该服务器时，服务器都会单独为该客户端分配一个名为default_storage_engine，作用范围为SESSION的系统变量，该作用范围为SESSION的系统变量值按照当前作用范围为GLOBAL的同名系统变量值进行初始化。</p>
</blockquote>
<blockquote>
<p><strong>服务器程序运行过程中设置系统变量</strong><br>了解了系统变量的GLOBAL和SESSION作用范围之后，我们再看一下在服务器程序运行期间通过客户端程序设置系统变量的语法:<br><code>SET [GLOBAL|SESSION] 系统变量名 = 值;</code><br>或者<br><code>SET [@@(GLOBAL|SESSION).]var_name = XXX;</code></p>
<p><code>如果在设置系统变量的语句中省略了作用范围，默认的作用范围就是SESSION</code></p>
</blockquote>
<h3 id="查看不同作用范围的系统变量"><a href="#查看不同作用范围的系统变量" class="headerlink" title="查看不同作用范围的系统变量"></a>查看不同作用范围的系统变量</h3><blockquote>
<p>既然系统变量有作用范围之分，那我们的<code>SHOW VARIABLES</code>语句查看的是什么作用范围的系统变量呢?<br>答:默认查看的是SESSION作用范围的系统变量。</p>
</blockquote>
<blockquote>
<p>当然我们也可以在查看系统变量的语句上加上要查看哪个作用范围的系统变量，就像这样:<br><code>SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</code></p>
</blockquote>
<blockquote>
<p>如果某个客户端改变了某个系统变量在<code>GLOBAL</code>作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为 <code>SESSION</code>的值，只会影响后续连入的客户端在作用范围为 <code>SESSION</code>的值。</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote>
<p>并不是所有系统变量都具有GLOBAL和SESSION的作用范围</p>
<ul>
<li>有一些系统变量只具有GLOBAL作用范围，比方说 max_connections，表示服务器程序支持同时最多有多少个客户端程序进行连接。</li>
<li>有一些系统变量只具有SESSION作用范围，比如 insert_id，表示插入值时使用的AUTO_INCREMENT修饰的列的值。</li>
<li>有一些系统变量的值既具有GLOBAL作用范围，也具有SESSION作用范围，比如我们前边用到的 default_storage_engine，而且其实大部分的系统变量都是这样的。</li>
<li>有些系统变量是只读的，并不能设置值。 比方说version，表示当前MySQL的版本，我们客户端是不能设置它的值的，只能在SHOW VARIABLES语句里查看。</li>
</ul>
</blockquote>
<h1 id="启动选项和系统变量的区别"><a href="#启动选项和系统变量的区别" class="headerlink" title="启动选项和系统变量的区别"></a>启动选项和系统变量的区别</h1><p><code>启动选项</code>是在程序启动时我们程序员传递的一些参数，而<code>系统变量</code>是影响服务器程序运行行为的变量，它们之间的关系如下:</p>
<ul>
<li><p>大部分的<code>系统变量</code>都可以被当作<code>启动选项</code>传入;</p>
</li>
<li><p>有些<code>系统变量</code>是在程序运行过程中自动生成的，是不可以当作<code>启动选项</code>来设置，比如 auto_increment_offset、character_set_client啥的。</p>
</li>
<li><p>有些<code>启动选项</code>也不是<code>系统变量</code>，比如defaults-file。</p>
</li>
</ul>
<h1 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h1><p>为了让我们更好的了解服务器程序的运行情况，MySQL服务器程序中维护了好多关于程序运行状态的变量，它们被称为<code>状态变量</code>。比方说 <code>Threads_connected</code> 表示当前有多少客户端与服务器建立了连接，<code>Handler_update</code>表示已经更新了多少行记录吧啦吧啦，像这样显示服务器程序状态信息的状态变量还有好几百个，我们就不一一唠叨了，等遇到了会详细说它们的作用的。</p>
<p>由于<code>状态变量</code>是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。与系统变量类似，状态变量也有GLOBAL和SESSION两个作用范围的，所以查看状态变量的语句可以这么写:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</span><br><span class="line">// 类似的，如果我们不写明作用范围，默认的作用范围是SESSION</span><br><span class="line">// 如下， 所有以Thread开头的SESSION作用范围的状态变量就都被展示出来 了。</span><br><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;thread%&#x27;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Threads_cached    | 1     |</span><br><span class="line">| Threads_connected | 1     |</span><br><span class="line">| Threads_created   | 2     |</span><br><span class="line">| Threads_running   | 2     |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/1. 重新认识MySQL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/12/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1.%20%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/">1. 重新认识MySQL</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-09-12T05:01:09.000Z" itemprop="datePublished">2021年09月12日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/09/12/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1.%20%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL的-客户端-服务器架构"><a href="#MySQL的-客户端-服务器架构" class="headerlink" title="MySQL的 客户端&#x2F;服务器架构"></a>MySQL的 客户端&#x2F;服务器架构</h1><p>我们日常使用MySQL的情景一般是:</p>
<ul>
<li>启动 <code>MySQL服务器程序</code>；</li>
<li>启动 <code>MySQL客户端程序</code> 并连接到 <code>MySQL服务器程序</code>；</li>
<li>在 <code>MySQL客户端程序</code> 中输入一些 <code>命令语句</code> 作为请求发送到 <code>MySQL服务器程序</code>；</li>
<li><code>MySQL服务器程序</code> 收到这些请求后，会根据请求的内容来操作具体的数据并向 <code>MySQL客户端程序</code> 返回操作结果。</li>
</ul>
<hr>
<p><code>MySQL服务器程序</code> 和 <code>MySQL客户端程序</code> 本质上都算是计算机上的一个<code>进程</code>，代表 <code>MySQL服务器程序</code> 的进程也被称为 <code>MySQL数据库实例</code>(简称<code>数据库实例</code>)；</p>
<ul>
<li><p>每个进程都有一个唯一的编号，称为 <code>进程ID</code>，英文名叫<code>PID</code>， <em><strong>这个编号是在我们启动程序的时候由操作系统 <code>随机分配</code>的，操作系统会保证在某一时刻同一台机器上的进程号不重复</strong></em>。</p>
<blockquote>
<p>比如你打开了计算机中的QQ程序，那么操作系统会为它分配一个唯一的进程号；如果你把这个程序关掉了，那操作系统就会把这个进程号回收，之后可能会重新分配给别的进程。当我们下一次再启动QQ程序的时候分配的就可能是另一个编号。</p>
</blockquote>
</li>
<li><p>每个进程都有一个名称，这个名称是编写程序的人自己定义的，比如我们启动的 <code>MySQL服务器进程</code> 的<strong>默认</strong>名称是  <code>mysqld</code>，而我们常用的<code>MySQL客户端进程</code>的<strong>默认</strong>名称为 <code>mysql</code>。</p>
</li>
</ul>
<h1 id="MySQL安装-小须知"><a href="#MySQL安装-小须知" class="headerlink" title="MySQL安装 小须知"></a>MySQL安装 小须知</h1><p>首先你要知道：无论我们通过 <code>下载源代码自行编译安装的方式</code> 还是 <code>直接使用官方提供的安装包进行安装的方式</code>。之后，<code>MySQL的服务器程序</code>和<code>MySQL的客户端程序</code> 都会被安装到我们的机器上。</p>
<blockquote>
<p>Tips:<br>MySQL的大部分安装包都包含了服务器程序和客户端程序，不过在Linux下使用 RPM包 安装时会有单独的 服务器RPM包 和 客户端RPM包，需要分别安装。</p>
</blockquote>
<p>不论使用上述两者的哪种安装方式，一定要记住你的 <strong><code>MySQL的安装目录</code></strong> 。</p>
<p>在 <code>MySQL的安装目录</code> 下有一个特别特别重要的目录 <strong><code>bin目录</code></strong> ，这个目录下存放着许多可执行文件。</p>
<h1 id="启动MySQL服务器程序"><a href="#启动MySQL服务器程序" class="headerlink" title="启动MySQL服务器程序"></a>启动MySQL服务器程序</h1><p>在 <code>类UNIX系统</code> 中，用来 启动MySQL服务器程序 的<code>可执行文件</code>有很多，大多都在 <code>MySQL安装目录</code> 的 <code>bin目录</code> 下。</p>
<h2 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a><del><code>mysqld</code></del></h2><p><del><code>mysqld</code> 这个可执行文件就代表着 <code>MySQL服务器程序</code>，运行这个可执行文件就可以直接启动一个服务器进程。 但这个命令不常用，我们继续往下看更牛逼的启动命令。</del></p>
<h2 id="mysqld-safe"><a href="#mysqld-safe" class="headerlink" title="mysqld_safe"></a><code>mysqld_safe</code></h2><p><code>mysqld_safe</code> 是一个启动脚本:</p>
<ul>
<li>它会间接的调用 <code>mysqld</code> ;</li>
<li>而且还顺便启动了另外一个 <code>监控进程</code>；这个 <code>监控进程</code> 在服务器进程挂了的时候，可以帮助重启它;</li>
<li>另外，它会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生<code>错误日志</code>，方便我们找出发生错误的原因。</li>
</ul>
<h2 id="mysql-server"><a href="#mysql-server" class="headerlink" title="mysql.server"></a><code>mysql.server</code></h2><p><code>mysql.server</code> 也是一个启动脚本，它会间接的调用 <code>mysqld_safe</code>；</p>
<p>命令用法如下：</p>
<ul>
<li>启动服务器程序 ：<code>mysq.server start</code></li>
<li>停止服务器程序：<code>mysq.server stop</code></li>
</ul>
<blockquote>
<p>需要注意的是，这个 <code>mysql.server</code> 文件其实是一个链接文件，它的实际文件是 <code>../support-files/mysql.server</code> 。</p>
<p>我使用的macOS操作系统会帮我在bin目录下自动创建一个指向实际文件的链接文件，如果你的操作系统没有帮你自动创建这个链接文件，那就自己创建一个呗~</p>
</blockquote>
<h2 id="mysqld-multi"><a href="#mysqld-multi" class="headerlink" title="mysqld_multi"></a><del><code>mysqld_multi</code></del></h2><blockquote>
<p><del>其实我们一台计算机上也可以运行多个MYSQL数据库实例。<code>mysql_multi可执行文件</code> 可以对每一个服务器进程的启动或停止进行监控。</del><br><del>这个命令的使用比较复杂，本书主要是为了讲清楚MySQL服务器和客户端运行的过程，不会对启动多个服务器程序进行过多唠叨。</del></p>
</blockquote>
<h1 id="启动MySQL客户端程序"><a href="#启动MySQL客户端程序" class="headerlink" title="启动MySQL客户端程序"></a>启动MySQL客户端程序</h1><blockquote>
<p>在成功启动<code>MySQL服务器程序</code>后，就可以接着启动<code>MySQL客户端程序</code>来连接到这个服务器。</p>
<p><code>bin目录</code>下有许多客户端程序，比方说 <code>mysqladmin</code>、<code>mysqldump</code>、<code>mysqlcheck</code> 等等 (好多呢，就不一一列举了)。</p>
</blockquote>
<hr>
<p>这里我们重点要关注的是 <code>可执行文件 mysql</code>：</p>
<blockquote>
<p><strong>通过这个可执行文件可以让我们和服务器程序进程交互</strong>(也就是发送请求，接受服务器的处理结果)。</p>
<p>命令用法：<br>&#x2F;&#x2F; 启动这个可执行文件时一般需要一些参数，格式如下:<br><code>mysql -h主机名 -u用户名 -p密码</code></p>
<p>&#x2F;&#x2F; 如果我们想断开客户端与服务器的连接并且关闭客户端的话，&gt; 可以在 <code>mysql&gt; 提示符</code>后输入下边任意一个命令:</p>
<ol>
<li><code>quit</code></li>
<li><code>exit</code></li>
<li><code>\q</code></li>
</ol>
<p>Tips:<br>像 h、u、p 这样只有一个英文字母的参数称为 <code>短形式的参数</code>，使用时前边需要加单短划线;<br>而像 host、user、password 这样大于一个英文字母的参数称为<code>⻓形式的参数</code>，使用时前边需要加 <code>双短划线</code>。</p>
</blockquote>
<hr>
<blockquote>
<p>如果你愿意，你可以多打开几个终端窗口(每个黑框框都使用 <code>mysql -hlocalhost -uroot -p123456</code>)来运行多个 <code>客户端程序</code>，每个<code>客户端程序</code> 其实都是互不影响的。<br>如果你有多个电脑，也可以试试把它们用局域网连起来，在一个电脑上启动 <code>MySQL服务器程序</code>，在另一个电脑上执行 <code>mysql命令</code> 使用IP地址作为主机名来连接到服务器。</p>
</blockquote>
<h1 id="客户端与服务器连接的过程"><a href="#客户端与服务器连接的过程" class="headerlink" title="客户端与服务器连接的过程"></a>客户端与服务器连接的过程</h1><p>我们现在已经知道如何启动 <code>MySQL的服务器程序</code>，以及如何启动 <code>MySQL的客户端程序</code>来连接到这个服务器程序。</p>
<p>运行着的服务器程序和客户端程序本质上都是计算机上的一个<code>进程</code>，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个<code>进程间通信的过程</code>!</p>
<p><strong><code>MySQL支持下边三种客户端进程和服务器进程的通信方式</code></strong>:</p>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><p><strong>真实环境中，<code>数据库服务器进程</code> 和 <code>客户端进程</code> 可能运行在不同的主机中，它们之间必须通过网络来进行通讯</strong>。</p>
<p>MySQL采用 <code>TCP</code> 作为<code>服务器</code>和<code>客户端</code> 之间的网络通信协议:</p>
<blockquote>
<p>在网络环境下，每台计算机都有一个唯一的IP地址，如果某个进程有需要采用TCP协议进行网络通信方面的需求，可以向操作系统申请一个端口号，这是一个整数值，它的取值范围是0~65535。这样在网络中的其他进程就可以通过 <code>IP地址 + 端口号</code>的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。</p>
<p> <code>MySQL服务器</code>启动时会默认申请3306端口号(即，MySQL服务器会默认监听3306端口)，之后就在这个端口号上等待客户端进程进行连接。</p>
</blockquote>
<blockquote>
<p>Tips:<br>&#x2F;&#x2F; 如果3306端口号已经被别的进程占用了或者我们单纯的想自定义该 数据库实例监听的端口号，那我们可以在启动服务器程序的命令行里添加 <code>-P参数</code> 来明确指定一下端口号，比如这样: <code>mysqld -P3307</code><br>&#x2F;&#x2F; 这样MySQL服务器在启动时就会去监听我们指定的端口号3307。</p>
</blockquote>
<h2 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a><del>命名管道和共享内存</del></h2><p><del>如果你是一个Windows用户，那么客户端进程和服务器进程之间可以考虑使用命名管道或共享内存进行通信。</del></p>
<h2 id="Unix域套接字文件"><a href="#Unix域套接字文件" class="headerlink" title="Unix域套接字文件"></a>Unix域套接字文件</h2><p>如果我们的<code>服务器进程</code>和<code>客户端进程</code>都运行在 <strong><code>同一台</code></strong> 操作系统为 类Unix的机器上的话，我们可以使用<code>Unix域套接字文件</code>来进行进程间通信。</p>
<p>如果我们在<code>启动客户端程序时</code>指定的主机名为<code>localhost</code>，或者指定了<code>--protocal=socket</code>的启动参数，那服务器程序和客户端程序之间就可以通过<code>Unix域套接字文件</code>来进行通信了。</p>
<hr>
<p>MySQL服务器程序默认监听的Unix域套接字文件路径为<code>/tmp/mysql.sock</code>，客户端程序也默认连接到这个Unix域套接字文件。</p>
<ul>
<li>如果我们想改变这个默认路径，可以在启动服务器程序时指定<code>socket参数</code>，就像这样: <code>mysqld --socket=/tmp/a.txt</code>，这样服务器启动后便会监听<code>/tmp/a.txt</code>。</li>
<li>在服务器改变了默认的UNIX域套接字文件后，如果客户端程序想通过UNIX域套接字文件进行通信的话，也需要显式的指定连接到的UNIX域套接字文件路径，就像这样:<code>mysql -hlocalhost -uroot --socket=/tmp/a.txt -p</code></li>
</ul>
<p>这样该客户端进程和服务器进程就可以通过路径为<code>/tmp/a.txt</code>的Unix域套接字文件进行通信了。</p>
<h1 id="服务器处理客户端请求"><a href="#服务器处理客户端请求" class="headerlink" title="服务器处理客户端请求"></a>服务器处理客户端请求</h1><blockquote>
<p>其实不论<code>客户端进程</code>和<code>服务器进程</code>是采用哪种方式进行通信，最后实现的效果都是:客户端进程向服务器进程发送一段文本(MySQL语句)，服务器进程处理后再向客户端进程返回一段文本(处理结果)。</p>
<p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?</p>
</blockquote>
<blockquote>
<p>客户端可以向服务器发送增删改查各类请求，我们这里以比较复杂的查询请求为例来画个图展示一下大致的过程:<br><img src="/images/MySQL/1/fsfasfsff23e2e.jpg"></p>
</blockquote>
<blockquote>
<p>从图中可以看出，服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是 <code>连接管理</code>、<code>解析与优化</code>、 <strong><code>存储引擎</code></strong> 。下边我们来详细看一下这三个部分都干了什么。</p>
</blockquote>
<h2 id="📌连接管理"><a href="#📌连接管理" class="headerlink" title="📌连接管理"></a>📌连接管理</h2><blockquote>
<p><code>客户端进程</code> 可以采用我们上边介绍的 <code>TCP/IP</code>、<code>命名管道或共享内存</code>、<code>Unix域套接字</code> 这几种方式之一来与 <code>服务器进</code> 程建立连接。</p>
<p><strong><code>每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专⻔处理与这个客户端的交互； 当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来； 在另一个新的客户端再进行连接时，服务器会把这个缓存的线程重新分配给该新客户端。 这样就起到了不频繁创建和销毁线程的效果，从而节省开销</code></strong> 。</p>
<p>从这一点大家也能看出， <strong><code>MySQL服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量</code></strong> ，至于怎么限制我们后边再说哈~</p>
</blockquote>
<hr>
<blockquote>
<p>在客户端程序发起连接的时候，需要携带 主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。<br>另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了SSL(安全套接字)的网络连接进行通信，来保证数据传输的安全性。</p>
<p>当连接建立后，<code>与该客户端关联的服务器线程</code>会一直等待客户端发送过来的请求，MySQL服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理，预知后事如何，继续往下看哈~</p>
</blockquote>
<h2 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h2><p>到现在为止，MySQL服务器已经获得了文本形式的请求，接着还要经过九九八十一难的处理，其中的几个比较重要的部分分别是 <code>查询缓存</code>、<code>语法解析</code> 和 <code>查询优化</code>，下边我们详细来看。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a><del>查询缓存</del></h3><blockquote>
<p>如果我问你 9+8×16-3×2×17 的值是多少，你可能会用计算器去算一下，或者牛逼一点用心算，最终得到了结果35，如果我再问你一遍 9+8×16-3×2×17 的值是多少，你还用再傻呵呵的算一遍么?我们 刚刚已经算过了，直接说答案就好了。</p>
<p>MySQL服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果缓存起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就 不用再傻呵呵的去底层的表中查找了。</p>
<p>并且 <strong><code>这个查询缓存可以在不同客户端之间共享</code></strong> ，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。</p>
</blockquote>
<hr>
<blockquote>
<p>当然，MySQL服务器并没有人聪明:</p>
<ul>
<li><p>如果两个查询请求在任何字符上的不同(例如:空格、注释、大小写)，都会导致缓存不会命中。</p>
</li>
<li><p>另外，如果查询请求中包含某些<code>系统函数</code>、<code>用户自定义变量</code>和<code>函数</code>、一些<code>系统表</code>，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</p>
<blockquote>
<p>以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，<strong>比如 <code>函数NOW</code>，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的!</strong></p>
</blockquote>
</li>
<li><p>而且，既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、 UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或 DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除!</p>
</li>
</ul>
</blockquote>
<hr>
<p>所以，虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如<code>每次都要去查询缓存中检索</code>，<code>查询请求处理完需要更新查询缓存</code>，<code>维护该查询缓存对应的内存区域</code>。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</p>
<h3 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h3><blockquote>
<p>如果 <code>查询缓存</code> 没有命中，接下来就需要进入正式的 <code>查询阶段</code> 了。</p>
<p>但由于<code>客户端程序</code> 发送过来的请求只是一段文本而已，所<code>以MySQL服务器程序</code>首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将 <code>要查询的表</code>、<code>各种查询条件</code> … 等信息都提取出来放到MySQL服务器内部使用的一些数据结构上来。<br>⚠️ Tips:<br>这个从指定的文本中提取出我们需要的信息本质上算是一个<code>编译过程</code>，涉及 <code>词法解析</code>、<code>语法分析</code>、<code>语义分析</code> 等阶段，这些问题不属于我们讨论的范畴，大家只要了解在处理请求的过程中需要这个步骤就好了。</p>
</blockquote>
<h3 id="📌-查询优化"><a href="#📌-查询优化" class="headerlink" title="📌 查询优化"></a>📌 查询优化</h3><blockquote>
<p><code>语法解析</code>之后，服务器程序获得到了需要的信息，比如 <code>要查询的列是哪些</code>，<code>表是哪个</code>，<code>搜索条件是什么</code> 等等…，但光有这些是不够的，因为我们写的MySQL语句执行起来效率可能并不是很高，MySQL的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接吧啦吧啦的一堆东⻄。</p>
</blockquote>
<blockquote>
<p>优化的结果会 <strong>生成一个<code>执行计划</code></strong> ，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。<br><strong>我们可以使用<code>EXPLAIN语句</code>来查看某个语句的执行计划</strong>，关于查询优化这部分的详细内容我们后边会仔细唠叨，现在你只需要知道在MySQL服务器程序处理请求的过程中有这么一个步骤就好了。</p>
</blockquote>
<h2 id="📌-存储引擎"><a href="#📌-存储引擎" class="headerlink" title="📌 存储引擎"></a>📌 存储引擎</h2><p>截止到<code>服务器程序</code>完成了<code>查询优化</code>为止，还没有真正的去访问真实的数据表。 <strong><code>MySQL服务器把数据的存储和提取操作都封装到了一个叫 存储引擎 的模块里</code></strong> 。</p>
<p>我们知道表是由一行一行的<code>记录</code>组成的， <strong><code>但这只是一个逻辑上的概念，物理上如何表示 记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上? </code></strong> 这都是 <code>存储引擎</code> 负责的事情。 <strong>为了实现不同的功能，MySQL提供了<code>各式各样</code>的存储引擎，<code>不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同</code></strong> 。</p>
<hr>
<p>为了管理方便，人们把 <code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code> 这些并<strong>不涉及真实数据存储的功能</strong>划分为<code>MySQL server</code>的功能。 而把<strong>真实存取数据的功能</strong>划分为<code>存储引擎</code>的功能。（各种不同的 <code>存储引擎</code> 向上边的 <code>MySQL server层</code> 提供统一的调用接口(也就是存储引擎 API)，包含了几十个底层函数，像”读取索引第一条内容”、”读取索引下一条内容”、”插入记录”等等。<br>所以在<code>MySQL server</code>完成了<code>查询优化</code>后，只需按照生成的<code>执行计划</code> 调用 <code>底层存储引擎</code> 提供的API，获取到数据后返回给客户端就好了。</p>
<h1 id="常用存储引擎"><a href="#常用存储引擎" class="headerlink" title="常用存储引擎"></a>常用存储引擎</h1><p>MySQL支持非常多种存储引擎，我这先列举一些:</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ARCHIVE</td>
<td>用于数据存档(行被插入后不能再修改)</td>
</tr>
<tr>
<td>BLACKHOLE</td>
<td>丢弃写操作，读操作会返回空内容</td>
</tr>
<tr>
<td>CSV</td>
<td>在存储数据时，以逗号分隔各个数据项</td>
</tr>
<tr>
<td>FEDERATED</td>
<td>用来访问远程表</td>
</tr>
<tr>
<td><strong><code>InnoDB</code></strong></td>
<td><strong><code>具备外键支持功能的事务存储引擎</code></strong></td>
</tr>
<tr>
<td>MEMORY</td>
<td>置于内存的表</td>
</tr>
<tr>
<td>MERGE</td>
<td>用来管理多个MyISAM表构成的表集合</td>
</tr>
<tr>
<td><strong><code>MyISAM</code></strong></td>
<td><strong><code>主要的非事务处理存储引擎</code></strong></td>
</tr>
<tr>
<td>NDB</td>
<td>MySQL集群专用存储引</td>
</tr>
</tbody></table>
<p>这么多我们怎么挑啊，哈哈，你多虑了，其实我们最常用的就是<code>InnoDB</code> 和 <code>MyISAM</code>，有时会提一下 <code>Memory</code>。其中<code>InnoDB是MySQL默认的存储引擎</code>，我们之后会详细唠叨这个存储引擎的各种功能。现在先看一下一些存储引擎对于某些功能的支持情况:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>MyISAM</th>
<th>Memory</th>
<th>InnoDB</th>
<th>Archive</th>
<th>NDB</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>B-tree</code></strong> indexes</td>
<td><strong><code>yes</code></strong></td>
<td><strong><code>yes</code></strong></td>
<td><strong><code>yes</code></strong></td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td><strong><code>Clustered indexes</code></strong></td>
<td>no</td>
<td>no</td>
<td><strong><code>yes</code></strong></td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Full-text search indexes</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td><strong><code>MVCC</code></strong></td>
<td>no</td>
<td>no</td>
<td><strong><code>yes</code></strong></td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>Hash indexes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>密密麻麻列了这么多，看的头皮都发麻了，达到的效果就是告诉你: 这玩意儿很复杂。其实这些东⻄大家没必要立即就给记住，列出来的目的就是想让大家明白不同的存储引擎支持不同的功能，有些重要的功能我们会在后边的唠叨中慢慢让大家理解的~</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="查看、设置-存储引擎"><a href="#查看、设置-存储引擎" class="headerlink" title="查看、设置 存储引擎"></a>查看、设置 存储引擎</h1><blockquote>
<p>我们可以用<code>SHOW ENGINES;</code>命令来查看当前服务器程序支持的存储引擎:<br><img src="/images/MySQL/1/1713156308289.jpg"></p>
<ul>
<li><code>Support列</code> 表示该存储引擎是否可用;</li>
<li><code>DEFAULT值</code> 代表是当前服务器程序的默认存储引擎;</li>
<li><code>Comment列</code> 是对存储引擎的一个描述;</li>
<li><code>Transactions列</code> 代表该存储引擎是否支持事务处理;</li>
<li><strong><code>XA列</code> 代表着该存储引擎是否支持分布式事务</strong>;<br>  (也许你并不知道什么是个事务、更别提分布式事务了，这些内容在后边的章节会详细唠叨，现在看个新鲜就得了)</li>
<li><code>Savepoints列</code> 代表着该列是否支持部分事务回滚。</li>
</ul>
</blockquote>
<blockquote>
<p>设置表的存储引擎<br>前边说过，  <strong><code>存储引擎是负责对表中的数据进行提取和写入工作的</code></strong>  ，我们可以为不同的表设置不同的存储引擎，也就是说 <strong><code>不同的表可以有不同的物理存储结构，不同的提取和写入方式</code></strong> 。</p>
<ul>
<li><p>创建表时指定存储引擎<br>  我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎InnoDB。(查看表结构可以使用:<code>show create tables 表名\G</code>)<br>如果我们想显式的指定一下表的存储引擎，那可以这么写:<br><code>CREATE TABLE 表名( 建表语句;</code><br><code>) ENGINE = 存储引擎名称;</code></p>
</li>
<li><p>如果表已经建好了，我们也可以使用 <code>ALTER TABLE 表名 ENGINE = 存储引擎名称;</code> 这个语句来修改表的存储引擎。</p>
</li>
</ul>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>



    <nav id="page-nav">

<a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
</nav>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> 最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/09/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/11.%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/">11. 连接的原理</a>
          </li>
        
          <li>
            <a href="/2021/11/06/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/10.0%20TODO%20%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/">10. 单表访问方法</a>
          </li>
        
          <li>
            <a href="/2021/11/04/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/9.6%20TODO%20%E5%AD%98%E6%94%BE%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90--InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/">9.6 InnoDB的表空间 之 系统表空间</a>
          </li>
        
          <li>
            <a href="/2021/10/29/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/9.5%20InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4%20%E4%B9%8B%20%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84(5)/">9.5 InnoDB独立表空间结构 之 各类型⻚面详细情况</a>
          </li>
        
          <li>
            <a href="/2021/10/28/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/9.4%20InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4%20%E4%B9%8B%20%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84(4)/">9.4 InnoDB的表空间 之 独立表空间结构(4)</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CAS/" style="font-size: 10px;">CAS</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/MySQL/" style="font-size: 20px;">MySQL</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> 分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">0</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a><span class="category-list-count">41</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSO/">SSO</a><span class="category-list-count">0</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">0</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">0</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> 归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年</a><span class="archive-list-count">41</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/" rel="tag">CAS</a><span class="tag-list-count">0</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">41</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">0</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">0</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">网站地图</a>
        <span> | </span><a href="/atom.xml">订阅本站</a>
        <span> | </span><a href="/about/">联系博主</a>
      </p>
      
      <p>
        <span>Copyright &copy; 2024 Rymuscle.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>




<script src="/js/script.js"></script>












  



  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>
  <script src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async type="text/javascript"></script>

</body>
</html>