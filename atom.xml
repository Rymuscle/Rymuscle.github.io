<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rymuscle的技术博客</title>
  
  <subtitle>一切美好都如约而至!</subtitle>
  <link href="http://rymuscle.github.io/atom.xml" rel="self"/>
  
  <link href="http://rymuscle.github.io/"/>
  <updated>2023-11-15T05:31:16.913Z</updated>
  <id>http://rymuscle.github.io/</id>
  
  <author>
    <name>Rymuscle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉查找树</title>
    <link href="http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-5.bst/"/>
    <id>http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-5.bst/</id>
    <published>2020-10-28T13:35:43.000Z</published>
    <updated>2023-11-15T05:31:16.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说到<code>二叉查找树</code>，从名字你也能看出这种数据结构是用二叉树来做快速查找的。 事实上<code>二叉搜索树</code>最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。<br>而我们之前学过的<code>散列表</code>也是支持这些操作的，并且<code>散列表</code>的这些操作比<code>二叉查找树</code>更高效，时间复杂度是 <code>O(1)</code>。<br>既然有了这么高效的<code>散列表</code>，还要<code>二叉查找树</code>干啥？有没有哪些地方是<code>散列表</code>做不了，必须要用<code>二叉查找树</code>来做的呢？</p><p>带着这些问题，我们就来学习今天的内容，<strong>二叉查找树</strong>！</p><h3 id="二叉搜索树-binary-search-tree」"><a href="#二叉搜索树-binary-search-tree」" class="headerlink" title="二叉搜索树 binary search tree」"></a>二叉搜索树 binary search tree」</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;说到&lt;code&gt;二叉查找树&lt;/code&gt;，从名字你也能看出这种数据结构是用二叉树来做快速查找的。 事实上&lt;code&gt;二叉搜索树&lt;/code&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>用数组表示(存储)二叉树</title>
    <link href="http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-4.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-4.binary-tree/</id>
    <published>2020-10-28T12:57:19.000Z</published>
    <updated>2023-11-15T05:23:34.503Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>之前我们的<code>二叉树</code>是使用<code>链表</code>这种最基本的数据结构来存储的（<code>链式存储</code>）。 而本篇我们将使用<code>数组</code>这种最基本的结构来存储<code>二叉树</code>（<code>顺序存储</code>）。</p><img src="/images/WX20231115-113301@2x.png" width="400px" style="margin-left:0px;"/></li><li><p>尝试用数组存储一棵二叉树</p><blockquote><p>如果将根节点A存储在下标 <code>i = 1</code> 的位置，那左子节点B会存储在下标 <code>2 * i = 2</code> 的位置，右子节点C会存储在 <code>2 * i + 1 = 3</code> 的位置。<br>以此类推，B 节点的左子节点D会存储在 <code>2 * i = 2 * 2 = 4</code> 的位置，右子节点E存储在 <code>2 * i + 1 = 2 * 2 + 1 = 5</code> 的位置。<br>……<br>最终的二叉树和数组的对应关系如下图:<br><img src="/images/WX20231115-114707@2x.png" width="250px" style="margin-left:0px;"/><br>总结一下，就是，<strong>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是它的左子节点，下标为 2 * i + 1 的位置存储的就是它的右子节点。反过来，下标为 i&#x2F;2 的位置存储就是它的父节点。</strong><br><strong>通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。</strong></p></blockquote></li><li><p>比较遗憾的是，刚刚我们举的例子是将一棵完全二叉树存储到了数组中，为了方便通过下标计算树中各节点位置，所以“浪费”了一个下标为 0 的存储位置。<span style="color:red">但如果我们往数组中存储的是一棵非完全二叉树，那就会浪费比较多的数组存储空间了</span>。</p><div style="display: flex;align-content: center;"><img src="/images/WX20231115-115837@2x.png" width="260px" /><img src="/images/array_representation_with_empty.png" width="350px" style="margin-left: 20px;"/></div></li></ol><p>可以看到，我们为了使  <code>根节点下标为i, 左子节点下标为2 * i, 右子节点下标为 2 * i + 1</code> 这个公式来仍然生效(<strong>方便计算各节点位置从而串起整棵树</strong>)，<span style="color:red">就不得不将一些None节点的位置也在数组中留出来。 这样就会浪费比较多的数组存储空间。</span></p><span id="more"></span><p>以下代码实现了一个基于数组表示的二叉树，包括以下几种操作</p><ul><li>给定某节点，获取它的值、左（右）子节点、父节点。</li><li>获取前序遍历、中序遍历、后序遍历、层序遍历序列。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/* 数组表示下的二叉树类 */</span><br><span class="line">class ArrayBinaryTree &#123;</span><br><span class="line">    private List&lt;Integer&gt; tree;</span><br><span class="line"></span><br><span class="line">    /* 构造方法 */</span><br><span class="line">    public ArrayBinaryTree(List&lt;Integer&gt; arr) &#123;</span><br><span class="line">        tree = new ArrayList&lt;&gt;(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 节点数量 */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return tree.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的值 */</span><br><span class="line">    public Integer val(int i) &#123;</span><br><span class="line">        // 若索引越界，则返回 null ，代表空位</span><br><span class="line">        if (i &lt; 0 || i &gt;= size())</span><br><span class="line">            return null;</span><br><span class="line">        return tree.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的左子节点的索引 */</span><br><span class="line">    public Integer left(int i) &#123;</span><br><span class="line">        return 2 * i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的右子节点的索引 */</span><br><span class="line">    public Integer right(int i) &#123;</span><br><span class="line">        return 2 * i + 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的父节点的索引 */</span><br><span class="line">    public Integer parent(int i) &#123;</span><br><span class="line">        return (i - 1) / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 层序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; levelOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        // 直接遍历数组</span><br><span class="line">        for (int i = 0; i &lt; size(); i++) &#123;</span><br><span class="line">            if (val(i) != null)</span><br><span class="line">                res.add(val(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 深度优先遍历 */</span><br><span class="line">    private void dfs(Integer i, String order, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        // 若为空位，则返回</span><br><span class="line">        if (val(i) == null)</span><br><span class="line">            return;</span><br><span class="line">        // 前序遍历</span><br><span class="line">        if (order == &quot;pre&quot;)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(left(i), order, res);</span><br><span class="line">        // 中序遍历</span><br><span class="line">        if (order == &quot;in&quot;)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(right(i), order, res);</span><br><span class="line">        // 后序遍历</span><br><span class="line">        if (order == &quot;post&quot;)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 前序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; preOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, &quot;pre&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 中序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; inOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, &quot;in&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 后序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; postOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, &quot;post&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>lant:</p><blockquote><p>所以，其实二叉树中，也就<code>完全二叉树</code>比较适合用 数组来存储。 因为如果一棵二叉树是一棵<code>完全二叉树</code>，那它用数组存储就会非常节省空间，它不需要像链式存储那样要存储额外的左右子节点的指针。<br>这也是为什么<code>完全二叉树</code>要求最后一层的子节点都靠左的原因，因为右边的None节点会一起排在数组的末尾，可以直接省略，也不影响 <code>数组存储二叉树的公式</code> 计算。<br><img src="/images/WX20231115-120907@2x.png" width="420px" /><br><img src="/images/WX20231115-120750@2x.png" width="420px" /></p></blockquote></li><li><p>优势与局限性<br>二叉树的数组表示主要有以下优点：</p></li></ol><ul><li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。</li><li>不需要存储指针，比较节省空间。</li><li>允许随机访问节点。</li></ul><p>然而，数组表示也存在一些局限性：</p><ul><li>数组存储需要连续内存空间，因此不适合存储数据量过大的树。</li><li>增删节点需要通过数组插入与删除操作实现，效率较低。</li><li>当二叉树中存在大量None时，数组中包含的节点数据比重较低，空间利用率较低。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/array_representation_of_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;之前我们的&lt;code&gt;二叉树&lt;/code&gt;是使用&lt;code&gt;链表&lt;/code&gt;这种最基本的数据结构来存储的（&lt;code&gt;链式存储&lt;/code&gt;）。 而本篇我们将使用&lt;code&gt;数组&lt;/code&gt;这种最基本的结构来存储&lt;code&gt;二叉树&lt;/code&gt;（&lt;code&gt;顺序存储&lt;/code&gt;）。&lt;/p&gt;
&lt;img src=&quot;/images/WX20231115-113301@2x.png&quot; width=&quot;400px&quot; style=&quot;margin-left:0px;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尝试用数组存储一棵二叉树&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果将根节点A存储在下标 &lt;code&gt;i = 1&lt;/code&gt; 的位置，那左子节点B会存储在下标 &lt;code&gt;2 * i = 2&lt;/code&gt; 的位置，右子节点C会存储在 &lt;code&gt;2 * i + 1 = 3&lt;/code&gt; 的位置。&lt;br&gt;以此类推，B 节点的左子节点D会存储在 &lt;code&gt;2 * i = 2 * 2 = 4&lt;/code&gt; 的位置，右子节点E存储在 &lt;code&gt;2 * i + 1 = 2 * 2 + 1 = 5&lt;/code&gt; 的位置。&lt;br&gt;……&lt;br&gt;最终的二叉树和数组的对应关系如下图:&lt;br&gt;&lt;img src=&quot;/images/WX20231115-114707@2x.png&quot; width=&quot;250px&quot; style=&quot;margin-left:0px;&quot;/&gt;&lt;br&gt;总结一下，就是，&lt;strong&gt;如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是它的左子节点，下标为 2 * i + 1 的位置存储的就是它的右子节点。反过来，下标为 i&amp;#x2F;2 的位置存储就是它的父节点。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比较遗憾的是，刚刚我们举的例子是将一棵完全二叉树存储到了数组中，为了方便通过下标计算树中各节点位置，所以“浪费”了一个下标为 0 的存储位置。&lt;span style=&quot;color:red&quot;&gt;但如果我们往数组中存储的是一棵非完全二叉树，那就会浪费比较多的数组存储空间了&lt;/span&gt;。&lt;/p&gt;
&lt;div style=&quot;display: flex;align-content: center;&quot;&gt;
&lt;img src=&quot;/images/WX20231115-115837@2x.png&quot; width=&quot;260px&quot; /&gt;
&lt;img src=&quot;/images/array_representation_with_empty.png&quot; width=&quot;350px&quot; style=&quot;margin-left: 20px;&quot;/&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到，我们为了使  &lt;code&gt;根节点下标为i, 左子节点下标为2 * i, 右子节点下标为 2 * i + 1&lt;/code&gt; 这个公式来仍然生效(&lt;strong&gt;方便计算各节点位置从而串起整棵树&lt;/strong&gt;)，&lt;span style=&quot;color:red&quot;&gt;就不得不将一些None节点的位置也在数组中留出来。 这样就会浪费比较多的数组存储空间。&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-3.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-3.binary-tree/</id>
    <published>2020-10-27T13:52:36.000Z</published>
    <updated>2023-11-15T02:57:28.459Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们的<code>二叉树</code>从下层的<code>物理结构</code>角度来看, 仍然是使用<code>链表</code>这种最基本的的数据结构进行的存储，因此其遍历方式仍是通过指针逐个访问节点。 <span style="color:red;">然而</span>，从上层的<code>逻辑角度</code>来看，<code>二叉树</code>是一种<code>非线性数据结构</code>，这就使得二叉树(<span style="color:orange;">在应用层逻辑上</span>)的遍历要比遍历链表更加复杂，需要借助搜索算法来实现。</p><p>二叉树常见的遍历方式包括 <code>层序遍历</code>、<code>前序遍历</code>、<code>中序遍历</code> 和 <code>后序遍历</code> 等。</p><h3 id="广度优先遍历-–-「层序遍历-level-order-traversal」"><a href="#广度优先遍历-–-「层序遍历-level-order-traversal」" class="headerlink" title="广度优先遍历 – 「层序遍历 level-order traversal」"></a>广度优先遍历 – 「层序遍历 level-order traversal」</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。<br>层序遍历本质上属于 <code>「广度优先遍历 breadth-first traversal」</code> ，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。</p><div style="display: flex;"><img src="/images/binary_tree_bfs.png" width="400px" style="margin-left:0px;"/><img src="/images/WX20231114-210129@2x.png" width="350px" style="margin-left:10px;border: 1px solid #ccc;border-radius: 5px;"/></div><span id="more"></span><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>仔细看上图的 广度优先遍历 方式，你会发现它遍历节点时，节点出现的方式 和 队列的“先进先出”规则很像，因此广度优先遍历也通常借助“队列”来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 层序遍历 */</span><br><span class="line">List&lt;Integer&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    // 初始化队列，加入根节点</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    // 初始化一个列表，用于保存遍历序列</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll(); // 队列出队</span><br><span class="line">        list.add(node.val);           // 保存节点值</span><br><span class="line">        if (node.left != null)</span><br><span class="line">            queue.offer(node.left);   // 左子节点入队</span><br><span class="line">        if (node.right != null)</span><br><span class="line">            queue.offer(node.right);  // 右子节点入队</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(n)</code>：所有节点被访问一次，使用 O(n) 时间，其中 n 为节点数量。<br>空间复杂度<code>O(n)</code>：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 <code>(n+1)/2</code> 个节点，占用 O(n) 空间。<br><code>二叉树的层数越往下，每层的节点越多，所以 只有二叉树是满二叉树时，最底层的节点数会达到最大。此时，当最底层节点(叶子节点)全部放入队列时，也是队列占用空间最大时。此时叶子结点数量为  (n+1)/2</code></p><h3 id="深度优先遍历-前、中、后-序遍历"><a href="#深度优先遍历-前、中、后-序遍历" class="headerlink" title="深度优先遍历 - 前、中、后 序遍历"></a>深度优先遍历 - 前、中、后 序遍历</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><img src="/images/WX20231115-102257@2x.png" width="450px" style="margin-left:10px;border: 1px solid #ccc;border-radius: 5px;"/><blockquote><p>“前序”、”中序”、”后序” 是基于遍历时 “根节点” 的顺序来说的。前序：根在前；中序：根在中；后序：根在后; </p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* 前序遍历 */</span><br><span class="line">void preOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 中序遍历 */</span><br><span class="line">void inOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 后序遍历 */</span><br><span class="line">void postOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 <code>O(n)</code>：所有节点被访问一次，使用 O(n) 时间。<br>空间复杂度 <code>O(n)</code>：在最差情况下，即树退化为链表时，递归深度达到 n，系统占用 O(n) 栈帧空间。</p><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><p>到目前为止，我们的二叉树都还只是自己手动将一些 数据节点 随意串连起来的，父子节点之间也没什么大小顺序之分，节点们的组合还没什么规律可言。<br>我们也只是在串连时尽量保证它们连起来像一棵二叉树，尽量<code>完全</code> 或 <code>完美</code>。</p><p>但即便我们好手动连出了一棵完美二叉树，由于各节点之间并没有什么规则，这棵树貌似既不能帮我们完成排序，也无法帮我们完成某种快速检索。 貌似还没什么用……</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/binary_tree_traversal/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止，我们的&lt;code&gt;二叉树&lt;/code&gt;从下层的&lt;code&gt;物理结构&lt;/code&gt;角度来看, 仍然是使用&lt;code&gt;链表&lt;/code&gt;这种最基本的的数据结构进行的存储，因此其遍历方式仍是通过指针逐个访问节点。 &lt;span style=&quot;color:red;&quot;&gt;然而&lt;/span&gt;，从上层的&lt;code&gt;逻辑角度&lt;/code&gt;来看，&lt;code&gt;二叉树&lt;/code&gt;是一种&lt;code&gt;非线性数据结构&lt;/code&gt;，这就使得二叉树(&lt;span style=&quot;color:orange;&quot;&gt;在应用层逻辑上&lt;/span&gt;)的遍历要比遍历链表更加复杂，需要借助搜索算法来实现。&lt;/p&gt;
&lt;p&gt;二叉树常见的遍历方式包括 &lt;code&gt;层序遍历&lt;/code&gt;、&lt;code&gt;前序遍历&lt;/code&gt;、&lt;code&gt;中序遍历&lt;/code&gt; 和 &lt;code&gt;后序遍历&lt;/code&gt; 等。&lt;/p&gt;
&lt;h3 id=&quot;广度优先遍历-–-「层序遍历-level-order-traversal」&quot;&gt;&lt;a href=&quot;#广度优先遍历-–-「层序遍历-level-order-traversal」&quot; class=&quot;headerlink&quot; title=&quot;广度优先遍历 – 「层序遍历 level-order traversal」&quot;&gt;&lt;/a&gt;广度优先遍历 – 「层序遍历 level-order traversal」&lt;/h3&gt;&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。&lt;br&gt;层序遍历本质上属于 &lt;code&gt;「广度优先遍历 breadth-first traversal」&lt;/code&gt; ，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。&lt;/p&gt;
&lt;div style=&quot;display: flex;&quot;&gt;
&lt;img src=&quot;/images/binary_tree_bfs.png&quot; width=&quot;400px&quot; style=&quot;margin-left:0px;&quot;/&gt;
&lt;img src=&quot;/images/WX20231114-210129@2x.png&quot; width=&quot;350px&quot; style=&quot;margin-left:10px;border: 1px solid #ccc;border-radius: 5px;&quot;/&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>常见二叉树类型</title>
    <link href="http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-2.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-2.binary-tree/</id>
    <published>2020-10-27T13:23:19.000Z</published>
    <updated>2023-11-14T12:38:39.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="「完美二叉树-perfect-binary-tree」"><a href="#「完美二叉树-perfect-binary-tree」" class="headerlink" title="「完美二叉树 perfect binary tree」"></a>「完美二叉树 perfect binary tree」</h3><p>所有层的节点都被完全填满。<br>在完美二叉树中，叶节点的度为 0，其余所有节点的度都为 2；若树高度为 h，则节点总数为 $2^{h+1}-1$ 。<br>呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。<br><img src="/images/perfect_binary_tree.png" width="450px" style="margin-left:0px;"/></p><span id="more"></span><h3 id="「完全二叉树-complete-binary-tree」"><a href="#「完全二叉树-complete-binary-tree」" class="headerlink" title="「完全二叉树 complete binary tree」"></a>「完全二叉树 complete binary tree」</h3><p>只有最底层的节点未被填满，且最底层节点尽量靠左填充。<br><img src="/images/complete_binary_tree.png" width="450px" style="margin-left:0px;"/></p><h3 id="「完满二叉树-full-binary-tree」"><a href="#「完满二叉树-full-binary-tree」" class="headerlink" title="「完满二叉树 full binary tree」"></a>「完满二叉树 full binary tree」</h3><p>除了叶节点之外，其余所有节点都有两个子节点<br><img src="/images/full_binary_tree.png" width="450px" style="margin-left:0px;"/></p><h3 id="「平衡二叉树-balanced-binary-tree」"><a href="#「平衡二叉树-balanced-binary-tree」" class="headerlink" title="「平衡二叉树 balanced binary tree」"></a>「平衡二叉树 balanced binary tree」</h3><p><strong>任意节点</strong>的左子树和右子树的高度之差的绝对值不超过 1<br><img src="/images/balanced_binary_tree.png" width="450px" style="margin-left:0px;"/></p><h3 id="二叉树的退化"><a href="#二叉树的退化" class="headerlink" title="二叉树的退化"></a>二叉树的退化</h3><p>当二叉树的每层节点都被填满时，达到 <code>完美二叉树</code>，完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。<br>而当所有节点都偏向一侧时，二叉树退化为 <code>链表</code>，链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 <code>O(n)</code>。<br><img src="/images/binary_tree_best_worst_cases.png" width="450px" style="margin-left:0px;"/></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/binary_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;「完美二叉树-perfect-binary-tree」&quot;&gt;&lt;a href=&quot;#「完美二叉树-perfect-binary-tree」&quot; class=&quot;headerlink&quot; title=&quot;「完美二叉树 perfect binary tree」&quot;&gt;&lt;/a&gt;「完美二叉树 perfect binary tree」&lt;/h3&gt;&lt;p&gt;所有层的节点都被完全填满。&lt;br&gt;在完美二叉树中，叶节点的度为 0，其余所有节点的度都为 2；若树高度为 h，则节点总数为 $2^{h+1}-1$ 。&lt;br&gt;呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。&lt;br&gt;&lt;img src=&quot;/images/perfect_binary_tree.png&quot; width=&quot;450px&quot; style=&quot;margin-left:0px;&quot;/&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「二叉树 binary tree」</title>
    <link href="http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-1.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-1.binary-tree/</id>
    <published>2020-10-27T12:15:32.000Z</published>
    <updated>2023-11-15T03:40:27.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识二叉树"><a href="#认识二叉树" class="headerlink" title="认识二叉树"></a>认识二叉树</h3><ol><li>「二叉树 binary tree」是一种<code>非线性数据结构</code>，体现着“一分为二”的分治逻辑。与<code>链表</code>类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。</li></ol><img src="/images/binary_tree_definition.png" width="400px" style="margin-left:0px;"/><ol start="2"><li>常见术语<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根节点 root node」：位于二叉树顶层的节点，没有父节点。</span><br><span class="line">「叶节点 leaf node」：没有子节点的节点，其两个指针均指向。</span><br><span class="line">「边 edge」：连接两个节点的线段，即节点引用（指针）。</span><br><span class="line">节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。</span><br><span class="line">节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</span><br><span class="line">二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。</span><br><span class="line">节点的「深度 depth」：从根节点到该节点所经过的边的数量。</span><br><span class="line">节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。</span><br></pre></td></tr></table></figure><div style="display: flex;"><img src="/images/WX20231114-190226@2x.png" width="340px" style="margin-left:0px;"/><img src="/images/binary_tree_terminology.png" width="310px" style="margin-left:20px;"/></div></li></ol><h3 id="二叉树-链式存储-基本操作"><a href="#二叉树-链式存储-基本操作" class="headerlink" title="二叉树 (链式存储) 基本操作"></a>二叉树 (链式存储) 基本操作</h3><h4 id="初始化二叉树"><a href="#初始化二叉树" class="headerlink" title="初始化二叉树"></a>初始化二叉树</h4><ol><li>从二叉树的结构图来看，它的节点和链表的节点非常像，因此用<code>链表</code>来存储<code>二叉树</code>也挺顺理成章的 😝。<br>而且链式存储也比较简单、直观，很方便地通过节点的左右指针就能将整棵树串起来，大部分二叉树代码都是通过这种结构来实现的。<img src="/images/WX20231115-113929@2x.png" width="350px" style="margin-left:0px;"/></li></ol><span id="more"></span><ol start="2"><li><p>其实初始化二叉树的过程和初始化一个链表没什么区别(将一些节点用指针串联起来)。只不过串联的逻辑稍有不同。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化节点</span><br><span class="line">TreeNode n1 = new TreeNode(1);</span><br><span class="line">TreeNode n2 = new TreeNode(2);</span><br><span class="line">TreeNode n3 = new TreeNode(3);</span><br><span class="line">TreeNode n4 = new TreeNode(4);</span><br><span class="line">TreeNode n5 = new TreeNode(5);</span><br><span class="line">// 构建引用指向（即指针）</span><br><span class="line">n1.left = n2;</span><br><span class="line">n1.right = n3;</span><br><span class="line">n2.left = n4;</span><br><span class="line">n2.right = n5;</span><br></pre></td></tr></table></figure><p>这棵二叉树的逻辑结构如下：</p><img src="/images/b-t-01.png" width="100px" style="margin-left:0px;"/></li><li><p>当然，对于上面的多个节点，你有多种不同的连接方式，将它们连成多种不同的二叉树：</p><img src="/images/b-t-02.png" width="250px" style="margin-left:0px;"/></li></ol><h4 id="插入、删除-节点"><a href="#插入、删除-节点" class="headerlink" title="插入、删除 节点"></a>插入、删除 节点</h4><p>与<code>链表</code>类似， 在<code>二叉树</code>中 插入、删除节点 ，可以通过修改指针来实现<br><img src="/images/binary_tree_add_remove.png" width="450px" style="margin-left:0px;"/></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode P = new TreeNode(0);</span><br><span class="line">// 在 n1 -&gt; n2 中间插入节点 P</span><br><span class="line">n1.left = P;</span><br><span class="line">P.left = n2;</span><br><span class="line">// 删除节点 P</span><br><span class="line">n1.left = n2;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/binary_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;认识二叉树&quot;&gt;&lt;a href=&quot;#认识二叉树&quot; class=&quot;headerlink&quot; title=&quot;认识二叉树&quot;&gt;&lt;/a&gt;认识二叉树&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;「二叉树 binary tree」是一种&lt;code&gt;非线性数据结构&lt;/code&gt;，体现着“一分为二”的分治逻辑。与&lt;code&gt;链表&lt;/code&gt;类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&quot;/images/binary_tree_definition.png&quot; width=&quot;400px&quot; style=&quot;margin-left:0px;&quot;/&gt;


&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;常见术语&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;根节点 root node」：位于二叉树顶层的节点，没有父节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;「叶节点 leaf node」：没有子节点的节点，其两个指针均指向。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;「边 edge」：连接两个节点的线段，即节点引用（指针）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;节点的「深度 depth」：从根节点到该节点所经过的边的数量。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;div style=&quot;display: flex;&quot;&gt;
&lt;img src=&quot;/images/WX20231114-190226@2x.png&quot; width=&quot;340px&quot; style=&quot;margin-left:0px;&quot;/&gt;
&lt;img src=&quot;/images/binary_tree_terminology.png&quot; width=&quot;310px&quot; style=&quot;margin-left:20px;&quot;/&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;二叉树-链式存储-基本操作&quot;&gt;&lt;a href=&quot;#二叉树-链式存储-基本操作&quot; class=&quot;headerlink&quot; title=&quot;二叉树 (链式存储) 基本操作&quot;&gt;&lt;/a&gt;二叉树 (链式存储) 基本操作&lt;/h3&gt;&lt;h4 id=&quot;初始化二叉树&quot;&gt;&lt;a href=&quot;#初始化二叉树&quot; class=&quot;headerlink&quot; title=&quot;初始化二叉树&quot;&gt;&lt;/a&gt;初始化二叉树&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;从二叉树的结构图来看，它的节点和链表的节点非常像，因此用&lt;code&gt;链表&lt;/code&gt;来存储&lt;code&gt;二叉树&lt;/code&gt;也挺顺理成章的 😝。&lt;br&gt;而且链式存储也比较简单、直观，很方便地通过节点的左右指针就能将整棵树串起来，大部分二叉树代码都是通过这种结构来实现的。&lt;img src=&quot;/images/WX20231115-113929@2x.png&quot; width=&quot;350px&quot; style=&quot;margin-left:0px;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构分类</title>
    <link href="http://rymuscle.github.io/2020/10/11/data-structure-algorithm/01.dataStructure-type/"/>
    <id>http://rymuscle.github.io/2020/10/11/data-structure-algorithm/01.dataStructure-type/</id>
    <published>2020-10-11T12:15:32.000Z</published>
    <updated>2023-11-14T10:38:20.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><p>数据结构可以从两个维度分为： <code>逻辑结构</code> 和 <code>物理结构</code>。</p><p><code>逻辑结构</code> 揭示了数据元素之间的逻辑关系，是抽象意义上的结构（也是我们后面重点关注和讨论的）；</p><p><code>物理结构</code> 则反映了 按一定逻辑结构组成的数据元素 在计算机内存中真正的存储结构；<br>在算法运行过程中，相关数据都存储在内存中, 这些数据的存储方式可分为 <code>连续空间存储（数组）</code> 和 <code>分散空间存储（链表）</code></p><span id="more"></span><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ol><li><code>逻辑结构</code> 又可被分为 <code>线性</code> 和 <code>非线性</code> 两大类</li></ol><ul><li><code>线性结构</code>比较直观，指数据在逻辑关系上呈线性排列；如：数组、链表、栈、队列、哈希表。 </li><li><code>非线性结构</code>则相反，呈非线性排列。如：树、堆、图、哈希表。</li></ul><ol start="2"><li>所有数据结构都是基于 数组、链表 或二者的组合实现的，例如<blockquote><p>基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度&gt;&#x3D;3的数组）等。<br>基于链表可实现：栈、队列、哈希表、树、堆、图等。</p></blockquote></li></ol><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><ol><li><p><code>数组</code> 和 <code>链表</code>这两种逻辑数据结构，对应了内存上的两个最基本的物理存储结构 <code>连续存储</code>、<code>分散存储</code>，因此 <code>数组</code> 和 <code>链表</code>是最基本的逻辑数据结构，其他更为复杂的逻辑数据结构要使用哪种物理结构进行存储时，都需要基于这两个最基础的逻辑数据结构进行选择。</p></li><li><p><strong>可以简单认为，对于一组数据，无论它们逻辑上是用哪种结构组合起来的。它们最终在物理介质上都是两种存储方式 <code>连续存储</code>、<code>分散存储</code>。 而这两种物理存储方式对应了最基础的两个数据结构 <code>数组</code>、<code>链表</code>。</strong></p></li><li><p><strong>所以无论你的数据是哪种<code>逻辑结构</code>的组合，最终也要选择基于什么样的<code>物理结构</code>进行存储，而 <code>数组</code> 和 <code>链表</code> 这两种基础数据结构分别对应了不同的物理存储结构。</strong></p></li></ol><p>如，下图中对于 <code>堆</code> 这种数据结构(<strong>逻辑上的</strong>)，可以采用 链表 或 数组 两种不同的 数据结构(<strong>物理上的</strong>) 进行存储。<br><img src="/images/1699950608316.jpg" width="400px" style="margin-left:0px;"/></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;数据结构分类&quot;&gt;&lt;a href=&quot;#数据结构分类&quot; class=&quot;headerlink&quot; title=&quot;数据结构分类&quot;&gt;&lt;/a&gt;数据结构分类&lt;/h3&gt;&lt;p&gt;数据结构可以从两个维度分为： &lt;code&gt;逻辑结构&lt;/code&gt; 和 &lt;code&gt;物理结构&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;逻辑结构&lt;/code&gt; 揭示了数据元素之间的逻辑关系，是抽象意义上的结构（也是我们后面重点关注和讨论的）；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;物理结构&lt;/code&gt; 则反映了 按一定逻辑结构组成的数据元素 在计算机内存中真正的存储结构；&lt;br&gt;在算法运行过程中，相关数据都存储在内存中, 这些数据的存储方式可分为 &lt;code&gt;连续空间存储（数组）&lt;/code&gt; 和 &lt;code&gt;分散空间存储（链表）&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
