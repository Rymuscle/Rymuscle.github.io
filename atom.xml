<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rymuscle的技术博客</title>
  
  <subtitle>一切美好都如约而至!</subtitle>
  <link href="http://rymuscle.github.io/atom.xml" rel="self"/>
  
  <link href="http://rymuscle.github.io/"/>
  <updated>2023-11-16T02:02:50.724Z</updated>
  <id>http://rymuscle.github.io/</id>
  
  <author>
    <name>Rymuscle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>平衡二叉搜索树--AVL树（下）</title>
    <link href="http://rymuscle.github.io/2020/10/30/data-structure-algorithm/10-7.AVL/"/>
    <id>http://rymuscle.github.io/2020/10/30/data-structure-algorithm/10-7.AVL/</id>
    <published>2020-10-30T14:31:09.000Z</published>
    <updated>2023-11-16T02:02:50.724Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/avl_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hello-algo.com/chapter_tree/avl_tre</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉搜索树--AVL树（上）</title>
    <link href="http://rymuscle.github.io/2020/10/29/data-structure-algorithm/10-6.AVL/"/>
    <id>http://rymuscle.github.io/2020/10/29/data-structure-algorithm/10-6.AVL/</id>
    <published>2020-10-29T14:09:21.000Z</published>
    <updated>2023-11-16T02:02:50.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lant："><a href="#lant：" class="headerlink" title="lant："></a>lant：</h3><p>通过上一篇对 <code>BST</code> 和 <code>hash表</code> 这两种数据结构的对比，我们知道虽然 <code>BST</code>在平衡状态下的 查、插、删 时间复杂度能达到<code>O(logn)</code>，但相比 <code>hash表</code>的 <code>O(1)</code>常量级时间复杂度还是逊色一点，不过它有<code>hash表</code>无法做到的，所以有存在的必要性和合理性。<br>但上面也提到了，BST需要在平衡状态下才能发挥出威力，否则它的操作效率会逐渐降低到<code>O(n)</code>级。<br>为了解决极端情况下，二叉树会退化为链表的情况，我们就需要设计一种<code>平衡二叉查找树</code>，也就是今天要讲的这种数据结构。<br>通俗的讲，<code>平衡二叉查找树</code>就是说，一棵<code>二叉查找树</code>在频繁地增删改查操作后，它依然能不断通过自我修复来维护自身的平衡性，从而始终保持高效的数据操作性能。</p><h3 id="自平衡二叉查找树"><a href="#自平衡二叉查找树" class="headerlink" title="自平衡二叉查找树"></a>自平衡二叉查找树</h3><p>其实<code>平衡二叉查找树</code>有挺多，常见的比如 <code>AVL树</code>，<code>SplayTree(伸展树)</code>、<code>Treap(树堆)</code>、<code>红黑树</code>。<br>不过你可能留意到，每当提到<code>平衡二叉查找树</code>，听到的基本都是<code>红黑树</code>。它的出镜率甚至要高于“平衡二叉查找 树”这几个字，有时候，我们甚至默认<code>平衡二叉查找树</code>就是<code>红黑树</code>，不过本篇暂时不聊这个明星树，后面会专门再聊。<br>下面先看最早的AVL树。</p><span id="more"></span><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><ol><li>AVL树是最先被发明的自平衡二叉查找树, 它严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</li><li>AVL 树既是<code>二叉搜索树</code>也是<code>平衡二叉树</code>，同时满足这两类二叉树的所有性质，因此也被称为<code>「平衡二叉搜索树 balanced binary search tree」</code>。</li></ol><h3 id="AVL树如何实现自平衡"><a href="#AVL树如何实现自平衡" class="headerlink" title="AVL树如何实现自平衡"></a>AVL树如何实现自平衡</h3><ol><li><p>AVL 树之所以在不断地增删改查操作后，依然能保持自身的平衡，就是因为它的“旋转”操作。<br>它的旋转操做能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”。</p></li><li><p>在介绍AVL树的旋转操作之前，我们先了解一个概念叫 <code>平衡因子</code>， 它用来标识当前节点是否是<code>失衡节点</code>，如果是，就需要对其做旋转操作来保证二叉树的平衡。</p></li><li><p>当发现<code>失衡因子</code>时，如何对其进行旋转才能保证二叉树的平衡呢？<br>下面根据节点失衡情况的不同，将旋转操作分为四种：<code>右旋</code>、<code>左旋</code>、<code>先右旋后左旋</code>、<code>先左旋后右旋</code>。下面我们将详细介绍这些旋转操作。</p></li></ol><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><blockquote><p>其实我们可以想下，为什么是四种旋转操作呢？<br>其实很简单，平衡的条件是 <code>任意节点**的左子树和右子树的高度之差的绝对值不超过 1 </code>，那就意味着，当你插入一个节点时，只要破坏了这个条件，就得做旋转操作。<br>所以，我们只用看插入节点后，破坏平衡的状况有哪几种，无非就四种：<code>父是左节点，自己是左节点</code>，<code>父左,自己右</code>; <code>父右,自己左</code>，<code>父左,字节右</code><br><img src="/images/avltree_rotation_cases.png" width="450px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>每种失衡情况有各自对应的旋转操作。</p></blockquote><br/><blockquote><p>另外 ，在学习具体的旋转操作之前，我们切记要做到有的放矢，不要太执迷于一些玄学，比如陷入”为什么这么转就能保持平衡，怎么能论证这个结论?”、“这么神奇的操作是怎么想出来的，为什么我就想不出这个方法?” …..<br>可以你看看技术大咖们对此的看法：</p><div style="display: flex"><img src="/images/b-s-t-0006.png" width="450px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/b-s-t-0007.png" width="450px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div></blockquote><h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p><a href="https://www.hello-algo.com/chapter_tree/avl_tree/#1_1">https://www.hello-algo.com/chapter_tree/avl_tree/#1_1</a></p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p><a href="https://www.hello-algo.com/chapter_tree/avl_tree/#2_1">https://www.hello-algo.com/chapter_tree/avl_tree/#2_1</a></p><h4 id="先左旋后右旋"><a href="#先左旋后右旋" class="headerlink" title="先左旋后右旋"></a>先左旋后右旋</h4><p><a href="https://www.hello-algo.com/chapter_tree/avl_tree/#3">https://www.hello-algo.com/chapter_tree/avl_tree/#3</a></p><h4 id="先右旋后左旋"><a href="#先右旋后左旋" class="headerlink" title="先右旋后左旋"></a>先右旋后左旋</h4><p><a href="https://www.hello-algo.com/chapter_tree/avl_tree/#4">https://www.hello-algo.com/chapter_tree/avl_tree/#4</a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/avl_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;lant：&quot;&gt;&lt;a href=&quot;#lant：&quot; class=&quot;headerlink&quot; title=&quot;lant：&quot;&gt;&lt;/a&gt;lant：&lt;/h3&gt;&lt;p&gt;通过上一篇对 &lt;code&gt;BST&lt;/code&gt; 和 &lt;code&gt;hash表&lt;/code&gt; 这两种数据结构的对比，我们知道虽然 &lt;code&gt;BST&lt;/code&gt;在平衡状态下的 查、插、删 时间复杂度能达到&lt;code&gt;O(logn)&lt;/code&gt;，但相比 &lt;code&gt;hash表&lt;/code&gt;的 &lt;code&gt;O(1)&lt;/code&gt;常量级时间复杂度还是逊色一点，不过它有&lt;code&gt;hash表&lt;/code&gt;无法做到的，所以有存在的必要性和合理性。&lt;br&gt;但上面也提到了，BST需要在平衡状态下才能发挥出威力，否则它的操作效率会逐渐降低到&lt;code&gt;O(n)&lt;/code&gt;级。&lt;br&gt;为了解决极端情况下，二叉树会退化为链表的情况，我们就需要设计一种&lt;code&gt;平衡二叉查找树&lt;/code&gt;，也就是今天要讲的这种数据结构。&lt;br&gt;通俗的讲，&lt;code&gt;平衡二叉查找树&lt;/code&gt;就是说，一棵&lt;code&gt;二叉查找树&lt;/code&gt;在频繁地增删改查操作后，它依然能不断通过自我修复来维护自身的平衡性，从而始终保持高效的数据操作性能。&lt;/p&gt;
&lt;h3 id=&quot;自平衡二叉查找树&quot;&gt;&lt;a href=&quot;#自平衡二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;自平衡二叉查找树&quot;&gt;&lt;/a&gt;自平衡二叉查找树&lt;/h3&gt;&lt;p&gt;其实&lt;code&gt;平衡二叉查找树&lt;/code&gt;有挺多，常见的比如 &lt;code&gt;AVL树&lt;/code&gt;，&lt;code&gt;SplayTree(伸展树)&lt;/code&gt;、&lt;code&gt;Treap(树堆)&lt;/code&gt;、&lt;code&gt;红黑树&lt;/code&gt;。&lt;br&gt;不过你可能留意到，每当提到&lt;code&gt;平衡二叉查找树&lt;/code&gt;，听到的基本都是&lt;code&gt;红黑树&lt;/code&gt;。它的出镜率甚至要高于“平衡二叉查找 树”这几个字，有时候，我们甚至默认&lt;code&gt;平衡二叉查找树&lt;/code&gt;就是&lt;code&gt;红黑树&lt;/code&gt;，不过本篇暂时不聊这个明星树，后面会专门再聊。&lt;br&gt;下面先看最早的AVL树。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树 binary search tree</title>
    <link href="http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-5.bst/"/>
    <id>http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-5.bst/</id>
    <published>2020-10-28T13:35:43.000Z</published>
    <updated>2023-11-16T02:03:27.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说到<code>二叉查找树</code>，从名字你也能猜出这种数据结构的估计就是用二叉树来做快速查找的。<br>事实上<code>二叉搜索树</code>最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。<br>而我们之前学过的<code>散列表</code>也是支持这些操作的，并且<code>散列表</code>的这些操作比<code>二叉查找树</code>更高效，时间复杂度是 <code>O(1)</code>。<br>既然有了这么高效的<code>散列表</code>，还要<code>二叉查找树</code>干啥？有没有哪些地方是<code>散列表</code>做不了，必须要用<code>二叉查找树</code>来做的呢？</p><p>带着这些问题，下面来学习今天的内容，<strong>二叉查找树</strong>！</p><h3 id="二叉搜索树-binary-search-tree"><a href="#二叉搜索树-binary-search-tree" class="headerlink" title="二叉搜索树 binary search tree"></a>二叉搜索树 binary search tree</h3><p>首先<code>二叉查找树</code>是建立在<code>二叉树</code>的基础上的，不过，它在<code>二叉树</code>的基础上又新增了自己的特性：<br><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong>下面是几个<code>二叉查找树</code>的例子，估计你一看应该就清楚了<br><img src="/images/b-s-t-0001.png" width="450px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p><span id="more"></span><h3 id="TODO-初始化一棵平衡的二叉查找树-学到本篇-目前还有难度-😰"><a href="#TODO-初始化一棵平衡的二叉查找树-学到本篇-目前还有难度-😰" class="headerlink" title="TODO 初始化一棵平衡的二叉查找树 学到本篇,目前还有难度 😰"></a>TODO 初始化一棵平衡的二叉查找树 学到本篇,目前还有难度 😰</h3><p><strong>lant:</strong> <a href="/2020/10/27/data-structure-algorithm/10-3.binary-tree/#lant">回忆</a><br>之前我们的<code>二叉树</code>一直都是把一些节点通过指针随意串连起来的，<span style="color:orange;">只不过在串连的时候，我们会尽量让它<strong>更像</strong>一棵树(你要是追求完美的话，还能让它更像一棵 <code>完美二叉树</code>)</span>。<br><strong>而现在的<code>二叉搜索树</code>不一样了，它要求我们在串连节点时，除了尽量更像一棵树，还要遵循它的额外特性。</strong></p><p>所以，如果你使用一组数据来初始化一棵 二叉查找树，你可能要花费点时间了，你除了要保证二叉查找树的特性，又要尽可能让树平衡… 还是要花费点时间的 (可以点击<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">这个</a>数据结构可视化站点试试)</p><blockquote><p>比如给你一组数 [1~10] 做节点，让你做个二叉搜索树<br>如果你直接挨个拿出节点连接，企图构建一棵二叉树，那效果就尴尬了：<br><img src="/images/b-s-t-0004.png" width="300px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>而一棵平衡的二叉查找树应该像下面这样：<br><span style="color:red;font-weight:600;">如果让你手动将这些节点连接成一棵平衡的二叉查找树，怕是不告诉你用什么技巧，你可能要连一阵子了 😝<span><br><img src="/images/b-s-t-0005.png" width="300px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote><p>我们暂时先不考虑如何能初始化一棵平衡的二叉搜索树，这个问题后面再聊…<br>下面先假设我们已经有了一棵平衡的 <code>二叉搜索树</code>，然后看我们能用它做些什么操作，时间复杂度怎么样。</p><h3 id="二叉搜索树的操作"><a href="#二叉搜索树的操作" class="headerlink" title="二叉搜索树的操作"></a>二叉搜索树的操作</h3><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ol><li><p><strong>假设我们现在已经有了一棵平衡的二叉查找树</strong>，那如何在二叉查找树中查找一个节点？ </p><blockquote><p>从根节点开始，如果它等于我们要查找的数据，那就返回;<br>如果要查找的数据比根节点的值小，那就在左子树中<strong>递归</strong>查找；<br>如果要查找的数据比根节点的值大，那就在右子树中<strong>递归</strong>查找。<br><img src="/images/b-s-t-0002.png" width="220px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote></li><li><p>二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，<strong>当二叉树平衡时</strong>，使用 <code>O(log n)</code>时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 查找节点 */</span><br><span class="line">TreeNode search(int num) &#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    // 循环查找，越过叶节点后跳出</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        // 目标节点在 cur 的右子树中</span><br><span class="line">        if (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        // 目标节点在 cur 的左子树中</span><br><span class="line">        else if (cur.val &gt; num)</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        // 找到目标节点，跳出循环</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回目标节点</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><ol><li><p>如何在<code>二叉查找树</code>中插入节点？</p><blockquote><p>二叉查找树的插入过程有点类似查找操作。 我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。<br>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置； 如果不为空，就再递归遍历右子树，查找插入位置。<br>同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。<br><img src="/images/b-s-t-0003.png" width="220px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>代码参考 <a href="https://www.hello-algo.com/chapter_tree/binary_search_tree/#2">这里</a></p></blockquote></li><li><p>很显然，即便你最初拥有一棵非常平衡的二叉查找树，随着你不断地插入节点(或者后面的删除节点)，你原本的 <code>平衡二叉查找树</code> 可能就逐渐退化成了<code>链表</code>。这时各种操作的时间复杂度也会退化为 <code>O(n)</code>。</p></li></ol><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>如何在<code>二叉查找树</code>中删除节点？<br>参考 <a href="https://www.hello-algo.com/chapter_tree/binary_search_tree/#3">这里</a></p><h4 id="二叉搜索树-中序遍历-的-福利"><a href="#二叉搜索树-中序遍历-的-福利" class="headerlink" title="二叉搜索树 中序遍历 的 福利"></a>二叉搜索树 中序遍历 的 福利</h4><p>由于 <code>二叉查找树</code> 有 任意节点<code>左子节点 &lt; 根节点 &lt; 右子节点</code>的特性。而二叉树<code>中序遍历</code>的遍历顺序正好又是<code>左-&gt;根-&gt;右</code>。<br>所以，对于<code>二查找叉树</code>来说，它的中序遍历得到的序列就是个升序序列。</p><p><span style="color:orange">利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需<code>O(n)</code>时间，无须进行额外的排序操作，非常高效。</span></p><h3 id="二叉搜索树的效率"><a href="#二叉搜索树的效率" class="headerlink" title="二叉搜索树的效率"></a>二叉搜索树的效率</h3><p>在理想情况下，二叉搜索树是“平衡”的，这样就可以在 <code>O(log n)</code> 的时间复杂度下，查、插、删 节点。</p><h3 id="开头的问题"><a href="#开头的问题" class="headerlink" title="开头的问题"></a>开头的问题</h3><p>之前我们学过，<code>散列表</code> 的插入、删除、查找操作的时间复杂度可以做到常量级的<code>O(1)</code>，非常高效;<br>而<code>二叉查找树</code>在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 <code>O(logn)</code>; 相对<code>散列表</code>，好像并没有什么优势，那我们为什么还要用<code>二叉查找树</code>呢？</p><p>我认为有下面几个原因：</p><ul><li>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。<br>  比如，如果做索引的话(如mysql)，用户一般会有排序要求，散列表当然不能满足了。</li><li>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)。</li><li>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li><li>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li><li>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。<br>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</li></ul><h3 id="二叉搜索树常见应用"><a href="#二叉搜索树常见应用" class="headerlink" title="二叉搜索树常见应用"></a>二叉搜索树常见应用</h3><p><strong>用作系统中的多级索引，实现高效的查找、插入、删除操作。</strong><br>作为某些搜索算法的底层数据结构。<br>用于存储数据流，以保持其有序状态。</p><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><p>所以我们现在的问题是</p><ol><li>如果我们有了一棵平衡的二叉搜索树，我们只能对树上现有的静态数据做查询操作，如果频繁地做插入，删除操作，我们目前还没办法保持树继续平衡，极端情况下，树有可能退化为链表。</li><li>即便我们只是想对一组静态数据进行查询操作，我们目前也还没办法先将他们逻辑地组成一棵平衡的 二叉搜索树 😓。</li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/binary_search_tree/#2">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;说到&lt;code&gt;二叉查找树&lt;/code&gt;，从名字你也能猜出这种数据结构的估计就是用二叉树来做快速查找的。&lt;br&gt;事实上&lt;code&gt;二叉搜索树&lt;/code&gt;最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。&lt;br&gt;而我们之前学过的&lt;code&gt;散列表&lt;/code&gt;也是支持这些操作的，并且&lt;code&gt;散列表&lt;/code&gt;的这些操作比&lt;code&gt;二叉查找树&lt;/code&gt;更高效，时间复杂度是 &lt;code&gt;O(1)&lt;/code&gt;。&lt;br&gt;既然有了这么高效的&lt;code&gt;散列表&lt;/code&gt;，还要&lt;code&gt;二叉查找树&lt;/code&gt;干啥？有没有哪些地方是&lt;code&gt;散列表&lt;/code&gt;做不了，必须要用&lt;code&gt;二叉查找树&lt;/code&gt;来做的呢？&lt;/p&gt;
&lt;p&gt;带着这些问题，下面来学习今天的内容，&lt;strong&gt;二叉查找树&lt;/strong&gt;！&lt;/p&gt;
&lt;h3 id=&quot;二叉搜索树-binary-search-tree&quot;&gt;&lt;a href=&quot;#二叉搜索树-binary-search-tree&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树 binary search tree&quot;&gt;&lt;/a&gt;二叉搜索树 binary search tree&lt;/h3&gt;&lt;p&gt;首先&lt;code&gt;二叉查找树&lt;/code&gt;是建立在&lt;code&gt;二叉树&lt;/code&gt;的基础上的，不过，它在&lt;code&gt;二叉树&lt;/code&gt;的基础上又新增了自己的特性：&lt;br&gt;&lt;strong&gt;二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。&lt;/strong&gt;下面是几个&lt;code&gt;二叉查找树&lt;/code&gt;的例子，估计你一看应该就清楚了&lt;br&gt;&lt;img src=&quot;/images/b-s-t-0001.png&quot; width=&quot;450px&quot; style=&quot;margin-left:0px;border: 1px solid #ccc;border-radius: 5px;&quot;/&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>用数组表示(存储)二叉树</title>
    <link href="http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-4.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-4.binary-tree/</id>
    <published>2020-10-28T12:57:19.000Z</published>
    <updated>2023-11-15T05:23:34.503Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>之前我们的<code>二叉树</code>是使用<code>链表</code>这种最基本的数据结构来存储的（<code>链式存储</code>）。 而本篇我们将使用<code>数组</code>这种最基本的结构来存储<code>二叉树</code>（<code>顺序存储</code>）。</p><img src="/images/WX20231115-113301@2x.png" width="400px" style="margin-left:0px;"/></li><li><p>尝试用数组存储一棵二叉树</p><blockquote><p>如果将根节点A存储在下标 <code>i = 1</code> 的位置，那左子节点B会存储在下标 <code>2 * i = 2</code> 的位置，右子节点C会存储在 <code>2 * i + 1 = 3</code> 的位置。<br>以此类推，B 节点的左子节点D会存储在 <code>2 * i = 2 * 2 = 4</code> 的位置，右子节点E存储在 <code>2 * i + 1 = 2 * 2 + 1 = 5</code> 的位置。<br>……<br>最终的二叉树和数组的对应关系如下图:<br><img src="/images/WX20231115-114707@2x.png" width="250px" style="margin-left:0px;"/><br>总结一下，就是，<strong>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是它的左子节点，下标为 2 * i + 1 的位置存储的就是它的右子节点。反过来，下标为 i&#x2F;2 的位置存储就是它的父节点。</strong><br><strong>通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。</strong></p></blockquote></li><li><p>比较遗憾的是，刚刚我们举的例子是将一棵完全二叉树存储到了数组中，为了方便通过下标计算树中各节点位置，所以“浪费”了一个下标为 0 的存储位置。<span style="color:red">但如果我们往数组中存储的是一棵非完全二叉树，那就会浪费比较多的数组存储空间了</span>。</p><div style="display: flex;align-content: center;"><img src="/images/WX20231115-115837@2x.png" width="260px" /><img src="/images/array_representation_with_empty.png" width="350px" style="margin-left: 20px;"/></div></li></ol><p>可以看到，我们为了使  <code>根节点下标为i, 左子节点下标为2 * i, 右子节点下标为 2 * i + 1</code> 这个公式来仍然生效(<strong>方便计算各节点位置从而串起整棵树</strong>)，<span style="color:red">就不得不将一些None节点的位置也在数组中留出来。 这样就会浪费比较多的数组存储空间。</span></p><span id="more"></span><p>以下代码实现了一个基于数组表示的二叉树，包括以下几种操作</p><ul><li>给定某节点，获取它的值、左（右）子节点、父节点。</li><li>获取前序遍历、中序遍历、后序遍历、层序遍历序列。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/* 数组表示下的二叉树类 */</span><br><span class="line">class ArrayBinaryTree &#123;</span><br><span class="line">    private List&lt;Integer&gt; tree;</span><br><span class="line"></span><br><span class="line">    /* 构造方法 */</span><br><span class="line">    public ArrayBinaryTree(List&lt;Integer&gt; arr) &#123;</span><br><span class="line">        tree = new ArrayList&lt;&gt;(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 节点数量 */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return tree.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的值 */</span><br><span class="line">    public Integer val(int i) &#123;</span><br><span class="line">        // 若索引越界，则返回 null ，代表空位</span><br><span class="line">        if (i &lt; 0 || i &gt;= size())</span><br><span class="line">            return null;</span><br><span class="line">        return tree.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的左子节点的索引 */</span><br><span class="line">    public Integer left(int i) &#123;</span><br><span class="line">        return 2 * i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的右子节点的索引 */</span><br><span class="line">    public Integer right(int i) &#123;</span><br><span class="line">        return 2 * i + 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的父节点的索引 */</span><br><span class="line">    public Integer parent(int i) &#123;</span><br><span class="line">        return (i - 1) / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 层序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; levelOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        // 直接遍历数组</span><br><span class="line">        for (int i = 0; i &lt; size(); i++) &#123;</span><br><span class="line">            if (val(i) != null)</span><br><span class="line">                res.add(val(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 深度优先遍历 */</span><br><span class="line">    private void dfs(Integer i, String order, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        // 若为空位，则返回</span><br><span class="line">        if (val(i) == null)</span><br><span class="line">            return;</span><br><span class="line">        // 前序遍历</span><br><span class="line">        if (order == &quot;pre&quot;)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(left(i), order, res);</span><br><span class="line">        // 中序遍历</span><br><span class="line">        if (order == &quot;in&quot;)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(right(i), order, res);</span><br><span class="line">        // 后序遍历</span><br><span class="line">        if (order == &quot;post&quot;)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 前序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; preOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, &quot;pre&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 中序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; inOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, &quot;in&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 后序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; postOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, &quot;post&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>lant:</p><blockquote><p>所以，其实二叉树中，也就<code>完全二叉树</code>比较适合用 数组来存储。 因为如果一棵二叉树是一棵<code>完全二叉树</code>，那它用数组存储就会非常节省空间，它不需要像链式存储那样要存储额外的左右子节点的指针。<br>这也是为什么<code>完全二叉树</code>要求最后一层的子节点都靠左的原因，因为右边的None节点会一起排在数组的末尾，可以直接省略，也不影响 <code>数组存储二叉树的公式</code> 计算。<br><img src="/images/WX20231115-120907@2x.png" width="420px" /><br><img src="/images/WX20231115-120750@2x.png" width="420px" /></p></blockquote></li><li><p>优势与局限性<br>二叉树的数组表示主要有以下优点：</p></li></ol><ul><li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。</li><li>不需要存储指针，比较节省空间。</li><li>允许随机访问节点。</li></ul><p>然而，数组表示也存在一些局限性：</p><ul><li>数组存储需要连续内存空间，因此不适合存储数据量过大的树。</li><li>增删节点需要通过数组插入与删除操作实现，效率较低。</li><li>当二叉树中存在大量None时，数组中包含的节点数据比重较低，空间利用率较低。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/array_representation_of_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;之前我们的&lt;code&gt;二叉树&lt;/code&gt;是使用&lt;code&gt;链表&lt;/code&gt;这种最基本的数据结构来存储的（&lt;code&gt;链式存储&lt;/code&gt;）。 而本篇我们将使用&lt;code&gt;数组&lt;/code&gt;这种最基本的结构来存储&lt;code&gt;二叉树&lt;/code&gt;（&lt;code&gt;顺序存储&lt;/code&gt;）。&lt;/p&gt;
&lt;img src=&quot;/images/WX20231115-113301@2x.png&quot; width=&quot;400px&quot; style=&quot;margin-left:0px;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尝试用数组存储一棵二叉树&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果将根节点A存储在下标 &lt;code&gt;i = 1&lt;/code&gt; 的位置，那左子节点B会存储在下标 &lt;code&gt;2 * i = 2&lt;/code&gt; 的位置，右子节点C会存储在 &lt;code&gt;2 * i + 1 = 3&lt;/code&gt; 的位置。&lt;br&gt;以此类推，B 节点的左子节点D会存储在 &lt;code&gt;2 * i = 2 * 2 = 4&lt;/code&gt; 的位置，右子节点E存储在 &lt;code&gt;2 * i + 1 = 2 * 2 + 1 = 5&lt;/code&gt; 的位置。&lt;br&gt;……&lt;br&gt;最终的二叉树和数组的对应关系如下图:&lt;br&gt;&lt;img src=&quot;/images/WX20231115-114707@2x.png&quot; width=&quot;250px&quot; style=&quot;margin-left:0px;&quot;/&gt;&lt;br&gt;总结一下，就是，&lt;strong&gt;如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是它的左子节点，下标为 2 * i + 1 的位置存储的就是它的右子节点。反过来，下标为 i&amp;#x2F;2 的位置存储就是它的父节点。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比较遗憾的是，刚刚我们举的例子是将一棵完全二叉树存储到了数组中，为了方便通过下标计算树中各节点位置，所以“浪费”了一个下标为 0 的存储位置。&lt;span style=&quot;color:red&quot;&gt;但如果我们往数组中存储的是一棵非完全二叉树，那就会浪费比较多的数组存储空间了&lt;/span&gt;。&lt;/p&gt;
&lt;div style=&quot;display: flex;align-content: center;&quot;&gt;
&lt;img src=&quot;/images/WX20231115-115837@2x.png&quot; width=&quot;260px&quot; /&gt;
&lt;img src=&quot;/images/array_representation_with_empty.png&quot; width=&quot;350px&quot; style=&quot;margin-left: 20px;&quot;/&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到，我们为了使  &lt;code&gt;根节点下标为i, 左子节点下标为2 * i, 右子节点下标为 2 * i + 1&lt;/code&gt; 这个公式来仍然生效(&lt;strong&gt;方便计算各节点位置从而串起整棵树&lt;/strong&gt;)，&lt;span style=&quot;color:red&quot;&gt;就不得不将一些None节点的位置也在数组中留出来。 这样就会浪费比较多的数组存储空间。&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-3.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-3.binary-tree/</id>
    <published>2020-10-27T13:52:36.000Z</published>
    <updated>2023-11-15T02:57:28.459Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们的<code>二叉树</code>从下层的<code>物理结构</code>角度来看, 仍然是使用<code>链表</code>这种最基本的的数据结构进行的存储，因此其遍历方式仍是通过指针逐个访问节点。 <span style="color:red;">然而</span>，从上层的<code>逻辑角度</code>来看，<code>二叉树</code>是一种<code>非线性数据结构</code>，这就使得二叉树(<span style="color:orange;">在应用层逻辑上</span>)的遍历要比遍历链表更加复杂，需要借助搜索算法来实现。</p><p>二叉树常见的遍历方式包括 <code>层序遍历</code>、<code>前序遍历</code>、<code>中序遍历</code> 和 <code>后序遍历</code> 等。</p><h3 id="广度优先遍历-–-「层序遍历-level-order-traversal」"><a href="#广度优先遍历-–-「层序遍历-level-order-traversal」" class="headerlink" title="广度优先遍历 – 「层序遍历 level-order traversal」"></a>广度优先遍历 – 「层序遍历 level-order traversal」</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。<br>层序遍历本质上属于 <code>「广度优先遍历 breadth-first traversal」</code> ，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。</p><div style="display: flex;"><img src="/images/binary_tree_bfs.png" width="400px" style="margin-left:0px;"/><img src="/images/WX20231114-210129@2x.png" width="350px" style="margin-left:10px;border: 1px solid #ccc;border-radius: 5px;"/></div><span id="more"></span><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>仔细看上图的 广度优先遍历 方式，你会发现它遍历节点时，节点出现的方式 和 队列的“先进先出”规则很像，因此广度优先遍历也通常借助“队列”来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 层序遍历 */</span><br><span class="line">List&lt;Integer&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    // 初始化队列，加入根节点</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    // 初始化一个列表，用于保存遍历序列</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll(); // 队列出队</span><br><span class="line">        list.add(node.val);           // 保存节点值</span><br><span class="line">        if (node.left != null)</span><br><span class="line">            queue.offer(node.left);   // 左子节点入队</span><br><span class="line">        if (node.right != null)</span><br><span class="line">            queue.offer(node.right);  // 右子节点入队</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(n)</code>：所有节点被访问一次，使用 O(n) 时间，其中 n 为节点数量。<br>空间复杂度<code>O(n)</code>：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 <code>(n+1)/2</code> 个节点，占用 O(n) 空间。<br><code>二叉树的层数越往下，每层的节点越多，所以 只有二叉树是满二叉树时，最底层的节点数会达到最大。此时，当最底层节点(叶子节点)全部放入队列时，也是队列占用空间最大时。此时叶子结点数量为  (n+1)/2</code></p><h3 id="深度优先遍历-前、中、后-序遍历"><a href="#深度优先遍历-前、中、后-序遍历" class="headerlink" title="深度优先遍历 - 前、中、后 序遍历"></a>深度优先遍历 - 前、中、后 序遍历</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><img src="/images/WX20231115-102257@2x.png" width="450px" style="margin-left:10px;border: 1px solid #ccc;border-radius: 5px;"/><blockquote><p>“前序”、”中序”、”后序” 是基于遍历时 “根节点” 的顺序来说的。前序：根在前；中序：根在中；后序：根在后; </p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* 前序遍历 */</span><br><span class="line">void preOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 中序遍历 */</span><br><span class="line">void inOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 后序遍历 */</span><br><span class="line">void postOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 <code>O(n)</code>：所有节点被访问一次，使用 O(n) 时间。<br>空间复杂度 <code>O(n)</code>：在最差情况下，即树退化为链表时，递归深度达到 n，系统占用 O(n) 栈帧空间。</p><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><p>到目前为止，我们的二叉树都还只是自己手动将一些 数据节点 随意串连起来的，父子节点之间也没什么大小顺序之分，节点们的组合还没什么规律可言。<br>我们也只是在串连时尽量保证它们连起来像一棵二叉树，尽量<code>完全</code> 或 <code>完美</code>。</p><p>但即便我们好手动连出了一棵完美二叉树，由于各节点之间并没有什么规则，这棵树貌似既不能帮我们完成排序，也无法帮我们完成某种快速检索。 貌似还没什么用……</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/binary_tree_traversal/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止，我们的&lt;code&gt;二叉树&lt;/code&gt;从下层的&lt;code&gt;物理结构&lt;/code&gt;角度来看, 仍然是使用&lt;code&gt;链表&lt;/code&gt;这种最基本的的数据结构进行的存储，因此其遍历方式仍是通过指针逐个访问节点。 &lt;span style=&quot;color:red;&quot;&gt;然而&lt;/span&gt;，从上层的&lt;code&gt;逻辑角度&lt;/code&gt;来看，&lt;code&gt;二叉树&lt;/code&gt;是一种&lt;code&gt;非线性数据结构&lt;/code&gt;，这就使得二叉树(&lt;span style=&quot;color:orange;&quot;&gt;在应用层逻辑上&lt;/span&gt;)的遍历要比遍历链表更加复杂，需要借助搜索算法来实现。&lt;/p&gt;
&lt;p&gt;二叉树常见的遍历方式包括 &lt;code&gt;层序遍历&lt;/code&gt;、&lt;code&gt;前序遍历&lt;/code&gt;、&lt;code&gt;中序遍历&lt;/code&gt; 和 &lt;code&gt;后序遍历&lt;/code&gt; 等。&lt;/p&gt;
&lt;h3 id=&quot;广度优先遍历-–-「层序遍历-level-order-traversal」&quot;&gt;&lt;a href=&quot;#广度优先遍历-–-「层序遍历-level-order-traversal」&quot; class=&quot;headerlink&quot; title=&quot;广度优先遍历 – 「层序遍历 level-order traversal」&quot;&gt;&lt;/a&gt;广度优先遍历 – 「层序遍历 level-order traversal」&lt;/h3&gt;&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。&lt;br&gt;层序遍历本质上属于 &lt;code&gt;「广度优先遍历 breadth-first traversal」&lt;/code&gt; ，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。&lt;/p&gt;
&lt;div style=&quot;display: flex;&quot;&gt;
&lt;img src=&quot;/images/binary_tree_bfs.png&quot; width=&quot;400px&quot; style=&quot;margin-left:0px;&quot;/&gt;
&lt;img src=&quot;/images/WX20231114-210129@2x.png&quot; width=&quot;350px&quot; style=&quot;margin-left:10px;border: 1px solid #ccc;border-radius: 5px;&quot;/&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>常见二叉树类型</title>
    <link href="http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-2.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-2.binary-tree/</id>
    <published>2020-10-27T13:23:19.000Z</published>
    <updated>2023-11-14T12:38:39.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="「完美二叉树-perfect-binary-tree」"><a href="#「完美二叉树-perfect-binary-tree」" class="headerlink" title="「完美二叉树 perfect binary tree」"></a>「完美二叉树 perfect binary tree」</h3><p>所有层的节点都被完全填满。<br>在完美二叉树中，叶节点的度为 0，其余所有节点的度都为 2；若树高度为 h，则节点总数为 $2^{h+1}-1$ 。<br>呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。<br><img src="/images/perfect_binary_tree.png" width="450px" style="margin-left:0px;"/></p><span id="more"></span><h3 id="「完全二叉树-complete-binary-tree」"><a href="#「完全二叉树-complete-binary-tree」" class="headerlink" title="「完全二叉树 complete binary tree」"></a>「完全二叉树 complete binary tree」</h3><p>只有最底层的节点未被填满，且最底层节点尽量靠左填充。<br><img src="/images/complete_binary_tree.png" width="450px" style="margin-left:0px;"/></p><h3 id="「完满二叉树-full-binary-tree」"><a href="#「完满二叉树-full-binary-tree」" class="headerlink" title="「完满二叉树 full binary tree」"></a>「完满二叉树 full binary tree」</h3><p>除了叶节点之外，其余所有节点都有两个子节点<br><img src="/images/full_binary_tree.png" width="450px" style="margin-left:0px;"/></p><h3 id="「平衡二叉树-balanced-binary-tree」"><a href="#「平衡二叉树-balanced-binary-tree」" class="headerlink" title="「平衡二叉树 balanced binary tree」"></a>「平衡二叉树 balanced binary tree」</h3><p><strong>任意节点</strong>的左子树和右子树的高度之差的绝对值不超过 1<br><img src="/images/balanced_binary_tree.png" width="450px" style="margin-left:0px;"/></p><h3 id="二叉树的退化"><a href="#二叉树的退化" class="headerlink" title="二叉树的退化"></a>二叉树的退化</h3><p>当二叉树的每层节点都被填满时，达到 <code>完美二叉树</code>，完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。<br>而当所有节点都偏向一侧时，二叉树退化为 <code>链表</code>，链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 <code>O(n)</code>。<br><img src="/images/binary_tree_best_worst_cases.png" width="450px" style="margin-left:0px;"/></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/binary_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;「完美二叉树-perfect-binary-tree」&quot;&gt;&lt;a href=&quot;#「完美二叉树-perfect-binary-tree」&quot; class=&quot;headerlink&quot; title=&quot;「完美二叉树 perfect binary tree」&quot;&gt;&lt;/a&gt;「完美二叉树 perfect binary tree」&lt;/h3&gt;&lt;p&gt;所有层的节点都被完全填满。&lt;br&gt;在完美二叉树中，叶节点的度为 0，其余所有节点的度都为 2；若树高度为 h，则节点总数为 $2^{h+1}-1$ 。&lt;br&gt;呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。&lt;br&gt;&lt;img src=&quot;/images/perfect_binary_tree.png&quot; width=&quot;450px&quot; style=&quot;margin-left:0px;&quot;/&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树 binary tree</title>
    <link href="http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-1.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-1.binary-tree/</id>
    <published>2020-10-27T12:15:32.000Z</published>
    <updated>2023-11-16T02:03:49.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识二叉树"><a href="#认识二叉树" class="headerlink" title="认识二叉树"></a>认识二叉树</h3><ol><li>「二叉树 binary tree」是一种<code>非线性数据结构</code>，体现着“一分为二”的分治逻辑。与<code>链表</code>类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。</li></ol><img src="/images/binary_tree_definition.png" width="400px" style="margin-left:0px;"/><ol start="2"><li>常见术语<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根节点 root node」：位于二叉树顶层的节点，没有父节点。</span><br><span class="line">「叶节点 leaf node」：没有子节点的节点，其两个指针均指向。</span><br><span class="line">「边 edge」：连接两个节点的线段，即节点引用（指针）。</span><br><span class="line">节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。</span><br><span class="line">节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</span><br><span class="line">二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。</span><br><span class="line">节点的「深度 depth」：从根节点到该节点所经过的边的数量。</span><br><span class="line">节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。</span><br></pre></td></tr></table></figure><div style="display: flex;"><img src="/images/WX20231114-190226@2x.png" width="340px" style="margin-left:0px;"/><img src="/images/binary_tree_terminology.png" width="310px" style="margin-left:20px;"/></div></li></ol><span id="more"></span><h3 id="二叉树-链式存储-基本操作"><a href="#二叉树-链式存储-基本操作" class="headerlink" title="二叉树 (链式存储) 基本操作"></a>二叉树 (链式存储) 基本操作</h3><h4 id="初始化二叉树"><a href="#初始化二叉树" class="headerlink" title="初始化二叉树"></a>初始化二叉树</h4><ol><li><p>从二叉树的结构图来看，它的节点和链表的节点非常像，因此用<code>链表</code>来存储<code>二叉树</code>也挺顺理成章的 😝。<br>而且链式存储也比较简单、直观，很方便地通过节点的左右指针就能将整棵树串起来，大部分二叉树代码都是通过这种结构来实现的。</p><img src="/images/WX20231115-113929@2x.png" width="350px" style="margin-left:0px;"/></li><li><p>其实初始化二叉树的过程和初始化一个链表没什么区别(将一些节点用指针串联起来)。只不过串联的逻辑稍有不同。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化节点</span><br><span class="line">TreeNode n1 = new TreeNode(1);</span><br><span class="line">TreeNode n2 = new TreeNode(2);</span><br><span class="line">TreeNode n3 = new TreeNode(3);</span><br><span class="line">TreeNode n4 = new TreeNode(4);</span><br><span class="line">TreeNode n5 = new TreeNode(5);</span><br><span class="line">// 构建引用指向（即指针）</span><br><span class="line">n1.left = n2;</span><br><span class="line">n1.right = n3;</span><br><span class="line">n2.left = n4;</span><br><span class="line">n2.right = n5;</span><br></pre></td></tr></table></figure><p>这棵二叉树的逻辑结构如下：</p><img src="/images/b-t-01.png" width="100px" style="margin-left:0px;"/></li><li><p>当然，对于上面的多个节点，你有多种不同的连接方式，将它们连成多种不同的二叉树：</p><img src="/images/b-t-02.png" width="250px" style="margin-left:0px;"/></li></ol><h4 id="插入、删除-节点"><a href="#插入、删除-节点" class="headerlink" title="插入、删除 节点"></a>插入、删除 节点</h4><p>与<code>链表</code>类似， 在<code>二叉树</code>中 插入、删除节点 ，可以通过修改指针来实现<br><img src="/images/binary_tree_add_remove.png" width="450px" style="margin-left:0px;"/></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode P = new TreeNode(0);</span><br><span class="line">// 在 n1 -&gt; n2 中间插入节点 P</span><br><span class="line">n1.left = P;</span><br><span class="line">P.left = n2;</span><br><span class="line">// 删除节点 P</span><br><span class="line">n1.left = n2;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/binary_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;认识二叉树&quot;&gt;&lt;a href=&quot;#认识二叉树&quot; class=&quot;headerlink&quot; title=&quot;认识二叉树&quot;&gt;&lt;/a&gt;认识二叉树&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;「二叉树 binary tree」是一种&lt;code&gt;非线性数据结构&lt;/code&gt;，体现着“一分为二”的分治逻辑。与&lt;code&gt;链表&lt;/code&gt;类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&quot;/images/binary_tree_definition.png&quot; width=&quot;400px&quot; style=&quot;margin-left:0px;&quot;/&gt;


&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;常见术语&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;根节点 root node」：位于二叉树顶层的节点，没有父节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;「叶节点 leaf node」：没有子节点的节点，其两个指针均指向。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;「边 edge」：连接两个节点的线段，即节点引用（指针）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;节点的「深度 depth」：从根节点到该节点所经过的边的数量。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;div style=&quot;display: flex;&quot;&gt;
&lt;img src=&quot;/images/WX20231114-190226@2x.png&quot; width=&quot;340px&quot; style=&quot;margin-left:0px;&quot;/&gt;
&lt;img src=&quot;/images/binary_tree_terminology.png&quot; width=&quot;310px&quot; style=&quot;margin-left:20px;&quot;/&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构分类</title>
    <link href="http://rymuscle.github.io/2020/10/11/data-structure-algorithm/01.dataStructure-type/"/>
    <id>http://rymuscle.github.io/2020/10/11/data-structure-algorithm/01.dataStructure-type/</id>
    <published>2020-10-11T12:15:32.000Z</published>
    <updated>2023-11-14T10:38:20.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><p>数据结构可以从两个维度分为： <code>逻辑结构</code> 和 <code>物理结构</code>。</p><p><code>逻辑结构</code> 揭示了数据元素之间的逻辑关系，是抽象意义上的结构（也是我们后面重点关注和讨论的）；</p><p><code>物理结构</code> 则反映了 按一定逻辑结构组成的数据元素 在计算机内存中真正的存储结构；<br>在算法运行过程中，相关数据都存储在内存中, 这些数据的存储方式可分为 <code>连续空间存储（数组）</code> 和 <code>分散空间存储（链表）</code></p><span id="more"></span><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ol><li><code>逻辑结构</code> 又可被分为 <code>线性</code> 和 <code>非线性</code> 两大类</li></ol><ul><li><code>线性结构</code>比较直观，指数据在逻辑关系上呈线性排列；如：数组、链表、栈、队列、哈希表。 </li><li><code>非线性结构</code>则相反，呈非线性排列。如：树、堆、图、哈希表。</li></ul><ol start="2"><li>所有数据结构都是基于 数组、链表 或二者的组合实现的，例如<blockquote><p>基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度&gt;&#x3D;3的数组）等。<br>基于链表可实现：栈、队列、哈希表、树、堆、图等。</p></blockquote></li></ol><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><ol><li><p><code>数组</code> 和 <code>链表</code>这两种逻辑数据结构，对应了内存上的两个最基本的物理存储结构 <code>连续存储</code>、<code>分散存储</code>，因此 <code>数组</code> 和 <code>链表</code>是最基本的逻辑数据结构，其他更为复杂的逻辑数据结构要使用哪种物理结构进行存储时，都需要基于这两个最基础的逻辑数据结构进行选择。</p></li><li><p><strong>可以简单认为，对于一组数据，无论它们逻辑上是用哪种结构组合起来的。它们最终在物理介质上都是两种存储方式 <code>连续存储</code>、<code>分散存储</code>。 而这两种物理存储方式对应了最基础的两个数据结构 <code>数组</code>、<code>链表</code>。</strong></p></li><li><p><strong>所以无论你的数据是哪种<code>逻辑结构</code>的组合，最终也要选择基于什么样的<code>物理结构</code>进行存储，而 <code>数组</code> 和 <code>链表</code> 这两种基础数据结构分别对应了不同的物理存储结构。</strong></p></li></ol><p>如，下图中对于 <code>堆</code> 这种数据结构(<strong>逻辑上的</strong>)，可以采用 链表 或 数组 两种不同的 数据结构(<strong>物理上的</strong>) 进行存储。<br><img src="/images/1699950608316.jpg" width="400px" style="margin-left:0px;"/></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;数据结构分类&quot;&gt;&lt;a href=&quot;#数据结构分类&quot; class=&quot;headerlink&quot; title=&quot;数据结构分类&quot;&gt;&lt;/a&gt;数据结构分类&lt;/h3&gt;&lt;p&gt;数据结构可以从两个维度分为： &lt;code&gt;逻辑结构&lt;/code&gt; 和 &lt;code&gt;物理结构&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;逻辑结构&lt;/code&gt; 揭示了数据元素之间的逻辑关系，是抽象意义上的结构（也是我们后面重点关注和讨论的）；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;物理结构&lt;/code&gt; 则反映了 按一定逻辑结构组成的数据元素 在计算机内存中真正的存储结构；&lt;br&gt;在算法运行过程中，相关数据都存储在内存中, 这些数据的存储方式可分为 &lt;code&gt;连续空间存储（数组）&lt;/code&gt; 和 &lt;code&gt;分散空间存储（链表）&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
