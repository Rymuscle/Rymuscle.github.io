<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>rymuscle的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="rymuscle的技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
    
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">rymuscle的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一切美好都如约而至!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> 首页</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> 归档</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> 关于</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> 订阅</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  <article id="post-MySQL知识点整理/21.0 redo日志文件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/12/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/21.0%20redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/">21.0 redo日志文件</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-12T12:23:11.000Z" itemprop="datePublished">2021年12月12日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/12/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/21.0%20redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="redo日志刷盘时机"><a href="#redo日志刷盘时机" class="headerlink" title="redo日志刷盘时机"></a>redo日志刷盘时机</h1><p>前边说过，<code>MTR</code> 运行过程中产生的一组redo日志在<code>mtr</code>结束时会被复制到<code>log buffer</code>中。可这些日志总在内存里呆着也不是个办法，在一些情况下它们会被刷新到磁盘里，比如:</p>
<ul>
<li><code>log buffer</code>空间不足时<br>log buffer的大小是有限的(通过系统变量 <code>innodb_log_buffer_size</code> 指定)，如果不停的往这个有限大小的log buffer里塞入日志，很快它就会被填满。<br>设计 InnoDB的大叔认为，如果当前写入log buffer的redo日志量已经占满了log buffer总容量的50%左右，就需要把这些日志刷新到磁盘中。</li>
<li><strong>事务提交时</strong><br>我们前边说过之所以使用redo日志主要是因为它占用的<code>空间少</code>，还是<code>顺序写</code>，在事务提交时可以不把修改过的<code>Buffer Pool⻚面</code>刷新到磁盘，<strong>但是为了保证持久性，必须要把修改这些⻚面对应的redo日志刷新到磁盘</strong> 。 否则系统崩溃后，无法将该事务对页面所做的修改恢复过来。</li>
<li>后台有一个线程，大约以每秒一次的频率将log buffer中的redo日志刷新到磁盘。</li>
<li>正常关闭服务器时。</li>
<li>做所谓的checkpoint时(我们现在没介绍过checkpoint的概念，稍后会仔细唠叨，稍安勿躁)</li>
</ul>
<h1 id="redo日志文件组"><a href="#redo日志文件组" class="headerlink" title="redo日志文件组"></a>redo日志文件组</h1><p>MySQL的数据目录(使用 <code>SHOW VARIABLES LIKE &#39;datadir&#39;</code>查看)下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，<strong>log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。</strong></p>
<p>如果我们对默认的redo日志文件不满意，可以通过下边几个启动参数来调节:</p>
<ul>
<li><code>innodb_log_group_home_dir</code>：该参数指定了redo日志文件所在的目录，默认值就是当前的数据目录。</li>
<li><code>innodb_log_file_size</code>：该参数指定了每个redo日志文件的大小，在MySQL 5.7.21 这个版本中的默认值为48MB。</li>
<li><code>innodb_log_files_in_group</code>：该参数指定redo日志文件的个数，默认值为2，最大值为 100。</li>
</ul>
<div style="font-weight:500;border: 1px solid #33b045;border-radius: 5px;padding:10px 10px 0 25px;">

<p>从上边的描述中可以看到，磁盘上的redo日志文件不只一个，而是以一个日志文件组的形式出现的。 这些文件以<code>ib_logfile[数字]</code> (数字可以是0、1、2…)的形式进行命名。<br>在将redo日志写入日志文件组时，是从ib_logfile0开始写，如果ib_logfile0写满了，就接着ib_logfile1写，同理，ib_logfile1写满了就去写ib_logfile2，依此类推。 如果写到最后一个文件该咋办? 那就重新转到ib_logfile0继续写，所以整个过程如下图所示:<br><img src="/images/MySQL/21/1.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>总共的redo日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code>。</p>
</div>

<p><strong>Tips: 如果采用循环使用的方式向redo日志文件组里写数据的话，那岂不是要追尾，也就是后写入的redo日志覆盖掉前边写的redo日志? 当然可能了! 所以设计InnoDB的大叔提出了<code>checkpoint</code>的概念，稍后我们重点唠叨。</strong></p>
<h1 id="redo日志的文件格式"><a href="#redo日志的文件格式" class="headerlink" title="redo日志的文件格式"></a>redo日志的<code>文件格式</code></h1><p>我们前边说过<code>log buffer</code>本质上是一片连续的内存空间，被划分成了若干个512字节大小的<code>block</code>。<br><strong>将<code>log buffer</code>中的redo日志刷新到磁盘的本质就是把block的镜像写入<code>日志文件</code>中，所以<code>redo日志文件</code>其实也是由若干个512字节大小的block组成。</strong></p>
<p><code>redo日志文件组</code>中的每个文件大小都一样，格式也一样，都是由两部分组成:</p>
<ul>
<li>前2048个字节，也就是前4个block是用来存储一些管理信息的；</li>
<li>从第2048字节往后是用来存储<code>log buffer</code>中的block镜像的；</li>
</ul>
<p>所以我们前边所说的循环使用redo日志文件，其实是从每个日志文件的第2048个字节开始算，示意图就是:<br><img src="/images/MySQL/21/2.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<hr>
<p>普通block的格式我们在唠叨<code>log buffer</code>时都说过了，就是<code>log block header</code>、<code>log block body</code>、<code>log block trialer</code>这三个部分，就不重复介绍了。</p>
<p>这里需要介绍一下每个<code>redo日志文件</code>前2048个字节，也就是<code>前4个特殊block</code>的格式都是干嘛的，先看图:<br><img src="/images/MySQL/21/3.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>从图中可以看出来，这4个block分别是:</p>
<ul>
<li><code>log file header</code>:描述该redo日志文件的一些整体属性，它的结构:<blockquote>
<img src="/images/MySQL/21/4.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>

<p><code>LOG_HEADER_FORMAT</code>: 4字节，redo日志的版本，在MySQL 5.7.21中该值永远为1<br><code>LOG_HEADER_PAD1</code>： 4字节，做字节填充用的，没什么实际意义，忽略~<br><code>LOG_HEADER_START_LSN</code>: 8字节，标记本redo日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值(关于什么是LSN我们稍后再看哈，看不懂的先忽略)。<br><code>LOG_HEADER_CREATOR</code>：32字节，一个字符串标记本redo日志文件的创建者是谁。正常运行时该值为MySQL的版本号，比如:”MySQL 5.7.21”，使用mysqlbackup命令创建的redo日志文件的该值为”ibbackup”和创建时间。<br><code>LOG_BLOCK_CHECKSUM</code>: 4字节，本block的校验值，所有block都有，我们不关心</p>
<p>Tips: 设计InnoDB的大叔对redo日志的block格式做了很多次修改，如果你阅读的其他书籍中发现上述的属性和你阅读书籍中的属性有些出入，不要慌，正常现象，忘记以前的版本吧。另外，LSN值我们后边才会介绍，现在千万别纠结LSN是个啥。</p>
</blockquote>
</li>
<li><code>checkpoint1</code>: 记录关于checkpoint的一些属性，看一下它的结构:<blockquote>
<img src="/images/MySQL/21/5.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>

<p><code>LOG_CHECKPOINT_NO</code>：8字节，服务器执行checkpoint的编号，每执行一次checkpoint，该值就加1。<br><code>LOG_CHECKPOINT_LSN</code>：8字节，服务器在结束checkpoint时对应的LSN值；系统在奔溃恢复时将从该值开始。<br><code>LOG_CHECKPOINT_OFFSET</code>：8字节，上个属性中的LSN值在redo日志文件组中的偏移量<br><code>LOG_CHECKPOINT_LOG_BUF_SIZE</code>：8字节，服务器在执行checkpoint操作时对应的log buffer的大小<br><code>LOG_BLOCK_CHECKSUM</code>：4字节，本block的校验值，所有block都有该值，我们不用关心</p>
<p>Tips: 小贴士:现在看不懂上边这些关于checkpoint和LSN的属性的释义是很正常的，我就是想让大家对上边这些属性混个脸熟，后边我们后详细唠叨的。</p>
</blockquote>
</li>
<li>第三个block未使用，忽略~</li>
<li><code>checkpoint2</code>: 结构和checkpoint1一样。</li>
</ul>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/20.3 redo日志的写入过程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/11/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/20.3%20redo%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B/">20.3 redo日志的写入过程</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-11T15:15:21.000Z" itemprop="datePublished">2021年12月11日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/11/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/20.3%20redo%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="redo-log-block-页"><a href="#redo-log-block-页" class="headerlink" title="redo log block(页)"></a>redo log <code>block(页)</code></h1><p>设计InnoDB的大叔为了更好的进行系统奔溃恢复，他们把通过<code>MTR</code>生成的redo日志都放在了大小为512字节的⻚中。</p>
<p>为了和我们前边提到的<code>表空间中的⻚</code>做区别，我们这里把用来存储redo日志的⻚称为 <code>block</code> (你心里清楚⻚和block的意思其实差不多就行了)。</p>
<p>一个 <code>redo log block</code> 的示意图如下:<br><img src="/images/MySQL/20/9.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>真正的redo日志都是存储到占用496字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。我们来看看这些所谓的管理信息都是啥:<br><img src="/images/MySQL/20/10.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<p>其中<code>log block header</code>的几个属性的意思分别如下:</p>
<ul>
<li><code>LOG_BLOCK_HDR_NO</code>: 每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</li>
<li><code>LOG_BLOCK_HDR_DATA_LEN</code>: 表示block中已经使用了多少字节，初始值为12(因为log block body从第12个字节处开始)。随着往block中写入的redo日志越来也多，本属性值也跟着增⻓。如果log block body已经被全部写满，那么本属性的值被设置为512。</li>
<li><code>LOG_BLOCK_FIRST_REC_GROUP</code>: 一条redo日志也可以称为一条redo日志记录(redo log record)。一个<code>mtr</code>会生产多条redo日志记录，这个<code>MTR</code>生成的这些redo日志记录被称为一个<code>redo日志记录组(redo log record group)</code>。<br><code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该block中第一个mtr生成的redo日志记录组的偏移量(其实也就是这个block里第一个mtr生成的第一条redo日志的偏移量)。<br>如果一个MTR生成的redo日志横跨了好多个block,那么最后一个block中的<code>LOG_BLOCK_FIRST_REC_GROUP</code>属性就表示这个MTR对应的redo日志结束的地方，也就是下一个MTR生成redo日志开始的地方。</li>
<li><code>LOG_BLOCK_CHECKPOINT_NO</code>: 表示所谓的checkpoint的序号，checkpoint是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</li>
</ul>
<p><code>log block trailer</code> 中属性的意思如下: </p>
<ul>
<li><code>LOG_BLOCK_CHECKSUM</code>:表示block的校验值，用于正确性校验，我们暂时不关心它。</li>
</ul>
<h1 id="redo日志缓冲区"><a href="#redo日志缓冲区" class="headerlink" title="redo日志缓冲区"></a>redo日志缓冲区</h1><p>我们前边说过，设计InnoDB的大叔为了解决磁盘速度过慢的问题而引入了 <code>Buffer Pool</code>。<br>同理，写入redo日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为 <code>redo log buffer(redo日志缓冲区)</code> 的连续内存空间，也可以简称为<code>log buffer</code>。这片内存空间被划分成若干个连续的<code>redo log block</code>，就像这样:<br><img src="/images/MySQL/20/11.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>我们可以通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小，在MySQL 5.7.21这个版本中，该启动参数的默认值为16MB。</p>
<h1 id="redo日志写入log-buffer"><a href="#redo日志写入log-buffer" class="headerlink" title="redo日志写入log buffer"></a>redo日志写入<code>log buffer</code></h1><p>向<code>log buffer</code>中写入<code>redo日志</code>的过程是<code>顺序写入</code>的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。<br>当想往<code>log buffer</code>中写入<code>redo日志</code>时，第一个遇到的问题就是应该写在哪个block的哪个偏移量处。设计InnoDB的大叔特意提供了一个称之为<code>buf_free的全局变量</code>，该变量指明后续写入的redo日志应该写入到log buffer中的哪个位置，如图所示:<br><img src="/images/MySQL/20/12.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<p>我们前边说过一个<code>mtr</code>执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以并不是每生成一条redo日志就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方；当该mtr结束的时候，再将过程中产生的一组redo日志全部复制到log buffer中。</p>
<blockquote>
<p>我们现在假设有两个名为T1、T2的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下:</p>
<ul>
<li>事务T1的两个mtr分别称为mtr_T1_1和mtr_T1_2；</li>
<li>事务T2的两个mtr分别称为mtr_T2_1和mtr_T2_2；</li>
</ul>
<p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况:<br><img src="/images/MySQL/20/13.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<p>不同的事务可能是并发执行的，所以T1、T2之间的mtr可能是交替执行的。每当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图(为了美观，我们把一个mtr中产生的所有的redo日志当作一个整体来画):<br><img src="/images/MySQL/20/14.png" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>从示意图中我们可以看出来，不同的mtr产生的一组redo日志占用的存储空间可能不一样</p>
<ul>
<li>有的mtr产生的redo日志量很少，比如 mtr_t1_1、mtr_t2_1就被放到同一个block中存储</li>
<li>有的mtr产生的redo日志量非常大，比如 mtr_t1_2 产生的redo日志甚至占用了3个block来存储。</li>
</ul>
</blockquote>
<blockquote>
<p>Tips:<br>对照着上图，自己分析一下每个block的 LOG_BLOCK_HDR_DATA_LEN、LOG_BLOCK_FIRST_REC_GROUP 属性值都是什么哈</p>
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/20.2 Mini-Transcation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/11/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/20.2%20Mini-Transcation/">20.2 Mini-Transcation</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-11T14:46:19.000Z" itemprop="datePublished">2021年12月11日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/11/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/20.2%20Mini-Transcation/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="以组的形式写入redo日志"><a href="#以组的形式写入redo日志" class="headerlink" title="以组的形式写入redo日志"></a>以组的形式写入redo日志</h1><p>语句在执行过程中可能修改若干个⻚面。比如我们前边说的一条INSERT语句可能修改 <code>系统表空间⻚号为7的⻚面的Max Row ID 属性</code> (当然也可能更新别的系统⻚面，只不过我们没有都列举出来而已)，还会更新<code>聚簇索引</code>和<code>二级索引</code>对应B+树中的⻚面。</p>
<p>由于对这些⻚面的更改都发生在<code>Buffer Pool</code>中，所以在修改完⻚面之后，需要记录一下相应的redo日志。</p>
<p>在执行语句的过程中产生的redo日志被设计InnoDB的大叔人为的划分成了若干个不可分割的组，比如:</p>
<blockquote>
<ul>
<li>更新<code>Max Row ID属性</code>时产生的redo日志是不可分割的。 </li>
<li>向聚簇索引对应B+树的⻚面中插入一条记录时产生的redo日志是不可分割的。 </li>
<li>向某个二级索引对应B+树的⻚面中插入一条记录时产生的redo日志是不可分割的。 </li>
<li>还有其他的一些对⻚面的访问操作时产生的redo日志是不可分割的。。。</li>
</ul>
</blockquote>
<p>怎么理解这个不可分割的意思呢? </p>
<blockquote>
<p>我们以向某个索引对应的B+树插入一条记录为例，在向B+树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据⻚中，定位到具体的数据⻚之后，有两种可能的情况:</p>
<ul>
<li>情况一: 该数据⻚的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据⻚中，记录一条类型为MLOG_COMP_REC_INSERT的redo日志就好了，我们把这种情况称之为<code>乐观插入</code>。</li>
<li>情况二: 该数据⻚剩余的空闲空间不足，那么事情就悲剧了， 我们前边说过，遇到这种情况要进行所谓的<code>⻚分裂</code>操作，也就是新建一个叶子节点，然后把原先数据⻚中的一部分记录复制到这个新的数据⻚中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条目录项记录指向这个新创建的⻚面。<br>很显然，这个过程要对多个⻚面进行修改，也就意味着会产生多条redo日志，我们把这种情况称之为<code>悲观插入</code>。<br>如果作为<code>内节点</code>的⻚a的剩余空闲空间也不足以容纳增加一条<code>目录项记录</code>，那需要继续做<code>内节点⻚a的分裂操作</code>，也就意味 着会修改更多的⻚面，从而产生更多的redo日志。<br>另外，对于 <code>悲观插入</code> 来说，由于需要新申请数据⻚，还需要改动一些系统⻚面，比方说要修改各种段、区的统计信息信息，各种链表的统计信息(比如什么FREE链表、FSP_FREE_FRAG链表吧啦吧啦，我们在唠叨表空间那一章中介绍过的各种东东)等等等等， 反正总共需要记录的redo日志有二、三十条。</li>
</ul>
</blockquote>
<p>设计InnoDB的大叔们认为向某个索引对应的B+树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。</p>
<blockquote>
<p>比方说在<code>悲观插入</code>过程中，新的⻚面已经分配好了，数据也复制过去了，新的记录也插入到⻚面中了，可是没有向内节点中插入一条目录项记录，这个插入过程就是不完整的，这样会形成一棵不正确的B+树。</p>
<p>而redo日志是为了在系统奔溃重启时恢复崩溃前的状态，<strong>如果在悲观插入的过程中只记录了一部分redo日志，那么在系统奔溃重启时会将索引对应的B+树恢复成一种不正确的状态</strong> ，这是设计InnoDB的大叔们所不能忍受的。</p>
<p>所以他们规定在执行这些<code>需要保证原子性的操作</code>时必须以<code>组</code>的形式来记录的redo日志，在进行系统奔溃重启恢复时，针对某个<code>组</code>中的redo日志，要么把全部的日志都恢复掉，要么一条也不恢复。</p>
</blockquote>
<p>怎么做到的呢? 这得分情况讨论:</p>
<blockquote>
<ul>
<li><p>有的需要保证原子性的操作会生成多条redo日志，比如向某个索引对应的B+树中进行一次<code>悲观插入</code>就需要生成许多条redo日志。<br>如何把这些redo日志划分到一个组里边儿呢? 设计InnoDB的大叔做了一个很简单的小把戏，就是在该组中的最后一条redo日志后边加上一条特殊类型的redo日志，该类型名称为 <code>MLOG_MULTI_REC_END</code>，type字段对应的十进制数字为31，该类型的redo日志结构很简单，只有一个<code>type</code>字段。<br>所以某个需要保证原子性的操作产生的一系列redo日志必须要以一个类型为MLOG_MULTI_REC_END结尾，就像这样:</p>
<img src="/images/MySQL/20/6.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
这样在系统奔溃重启进行恢复时，只有当解析到类型为 `MLOG_MULTI_REC_END` 的redo日志，才认为解析到了一组完整的redo日志，才会进行恢复。否则的话直接放弃前边解析到的redo日志。
</li>
<li><p>有的需要保证原子性的操作只生成一条redo日志，比如更新 Max Row ID属性的操作就只会生成一条redo日志。<br>其实在一条日志后边跟一个类型为<code>MLOG_MULTI_REC_END</code>的redo日志也是可以的，不过设计InnoDB的大叔比较勤俭节约，它们不想浪费一个比特位。别忘了虽然redo日志的类型比较多，但撑死了也就是几十种，是小于127这个数字的，也就是说我们用7个比特位就足以包括所有的redo日志类型，而type字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条redo日志，示意图如下:</p>
<img src="/images/MySQL/20/7.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
如果type字段的第一个比特为为1，代表该需要保证原子性的操作只产生了单一的一条redo日志，否则表示该需要保证原子性的操作产生了一系列的redo日志。</li>
</ul>
</blockquote>
<h1 id="Mini-Transaction的概念"><a href="#Mini-Transaction的概念" class="headerlink" title="Mini-Transaction的概念"></a>Mini-Transaction的概念</h1><p>设计MySQL的大叔把对底层⻚面中的一次<code>原子访问</code>的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如上边所说的修改一次Max Row ID的值算是一个Mini-Transaction，向某个索引对应的B+树中插入一条记录的过程也算是一个Mini-Transaction。</p>
<p>通过上边的叙述我们也知道，<strong>一个所谓的mtr可以包含一组redo日志 ， 在进行奔溃恢复时这一组redo日志作为一个不可分割的整体。</strong> </p>
<p>一个事务可以包含若干条语句，<strong>每一条语句其实是由若干个mtr组成</strong> ，<strong>每一个mtr又可以包含若干条redo日志</strong> ，画个图表示它们的关系就是这样:<br><img src="/images/MySQL/20/8.png" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/20.1 redo日志格式和类型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/11/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/20.1%20redo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E5%92%8C%E7%B1%BB%E5%9E%8B/">20.1 redo日志格式</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-11T14:16:41.000Z" itemprop="datePublished">2021年12月11日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/11/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/20.1%20redo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E5%92%8C%E7%B1%BB%E5%9E%8B/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="redo-日志格式"><a href="#redo-日志格式" class="headerlink" title="redo 日志格式"></a>redo 日志格式</h1><p>通过上边的内容我们知道，redo日志本质上只是记录了一下事务对数据库做了哪些修改。 </p>
<blockquote>
<p>设计InnoDB的大叔们针对 事务对数据库的不同修改场景 定义了多种类型的redo日志，但大部分类型都有下边这种通用的结构:<br><img src="/images/MySQL/20/1.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br><code>type</code>: 该条redo日志的类型 (在MySQL 5.7.21中，设计InnoDB的大叔一共为redo日志设计了53种不同的类型，稍后会详细介绍不同类型的redo日志。)<br><code>space ID</code>: 表空间ID<br><code>page number</code>: ⻚号<br><code>data</code>: 该条redo日志的具体内容</p>
</blockquote>
<h1 id="简单的redo日志类型"><a href="#简单的redo日志类型" class="headerlink" title="简单的redo日志类型"></a>简单的redo日志类型</h1><blockquote>
<p>前边介绍InnoDB的<code>记录行格式</code>时说过，如果我们没有为某个表显式的定义主键，并且表中也没有定义Unique键，InnoDB会自动的为表添加一个称之为<code>row_id</code>的隐藏列作为主键。</p>
<p>这个<code>row_id隐藏列</code>的赋值方式如下:</p>
<ul>
<li>服务器会在内存中维护一个<code>全局变量</code>，每当向某个包含隐藏的row_id列的表中插入一条记录时，就会把该<code>全局变量</code>的值当作新记录的row_id列的值，并且把该<code>全局变量</code>自增1。</li>
<li>每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的⻚号为7的⻚面中一个称之为<code>Max Row ID</code>的属性处(前边介绍表空间结构时详细说过)。</li>
<li>当系统启动时，会将上边提到的<code>Max Row ID</code>属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量(因为在上次关机时该<code>全局变量</code>的值可能大于<code>Max Row ID</code>属性值(lant: 关机时，全局变量可能会没即时刷到表空间的⻚号为7的⻚面中的Max Row ID属性 😝))。</li>
</ul>
</blockquote>
<blockquote>
<p>这个<code>Max Row ID</code>属性占用的存储空间是8个字节，当某个事务向某个包含row_id隐藏列的表插入一条记录，并且为该记录分配的row_id值为256的倍数时，就会向系统表空间⻚号为7的⻚面的相应偏移量处写入8个字节的值。<br>但是我们要知道，这个写入实际上是在 <code>Buffer Pool</code> 中完成的，我们需要为这个⻚面的修改记录一条redo日志，以便在系统奔溃后能将已经提交的该事务对该⻚面所做的修改恢复出来。<br>这种情况下对⻚面的修改是极其简单的，redo日志中只需要记录一下在某个⻚面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥就好了，设计InnoDB的大叔把这种极其简单的redo日志称之为 <code>物理日志</code>，并且根据在⻚面中写入数据的多少划分了几种不同的redo日志类型:</p>
<ul>
<li><code>MLOG_1BYTE</code>(type字段对应的十进制数字为1): 表示在⻚面的某个偏移量处写入1个字节的redo日志类型。</li>
<li><code>MLOG_2BYTE</code>(type字段对应的十进制数字为2): 表示在⻚面的某个偏移量处写入2个字节的redo日志类型。</li>
<li><code>MLOG_4BYTE</code>(type字段对应的十进制数字为4): 表示在⻚面的某个偏移量处写入4个字节的redo日志类型。</li>
<li><code>MLOG_8BYTE</code>(type字段对应的十进制数字为8): 表示在⻚面的某个偏移量处写入8个字节的redo日志类型。</li>
<li><code>MLOG_WRITE_STRING</code>(type字段对应的十进制数字 为30): 表示在⻚面的某个偏移量处写入一串数据。</li>
</ul>
</blockquote>
<blockquote>
<p>我们上边提到的 <code>Max Row ID</code> 属性实际占用8个字节的存储空间，所以在修改⻚面中的该属性时，会记录一条类型为 <code>MLOG_8BYTE</code> 的redo日志，MLOG_8BYTE的redo日志结构如下所示:<br><img src="/images/MySQL/20/2.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>其余 MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE类型的redo日志结构和MLOG_8BYTE的类似，只不过具体数据中包含对应个字节的数据罢了。</p>
<p>MLOG_WRITE_STRING类型的redo日志表示写入一串数据，但是因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个<code>len</code>字段:<br><img src="/images/MySQL/20/3.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
</blockquote>
<h1 id="复杂一些的redo日志类型"><a href="#复杂一些的redo日志类型" class="headerlink" title="复杂一些的redo日志类型"></a>复杂一些的redo日志类型</h1><blockquote>
<p>有时候执行一条语句会修改非常多的⻚面，包括<code>系统数据⻚面</code>和<code>用户数据⻚面</code>(用户数据指的就是聚簇索引和二级索引对应的B+树)。<br>以一条INSERT语句为例，它除了要向B+树的⻚面中插入数据，也可能更新系统数据<code>Max Row ID</code>的值，不过对于我们用户来说，平时更关心的是语句对B+树所做更新:</p>
<ul>
<li>表中包含多少个索引，一条INSERT语句就可能更新多少棵B+树。</li>
<li>针对某一棵B+树来说，既可能更新<code>叶子节点⻚面</code>，也可能更新<code>内节点⻚面</code>，也可能创建新的⻚面(<strong>在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行⻚面的分裂，在内节点⻚面中添加目录项记录</strong>)。</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>在语句执行过程中，INSERT语句对所有⻚面的修改都得保存到 <code>redo日志</code> 中去。<br>这句话说的比较轻巧，做起来可就比较麻烦了，比方说将记录插入到聚簇索引中时，如果定位到的叶子节点的剩余空间足够存储该记录时，那么只更新该叶子节点⻚面就好，那么只记录一条<code>MLOG_WRITE_STRING</code>类型的redo日志，表明在⻚面的某个偏移量处增加了哪些数据就好了么? 那就too young too naive了<br>别忘了一个数据⻚中除了存储实际的记录之后，还有什么 File Header、Page Header、Page Directory 等等部分(在唠叨数据⻚的章节有详细讲解)，所以每往叶子节点代表的数据⻚里插入一条记录时，还有其他很多地方会跟着更新，比如说:</p>
<ul>
<li>可能更新 <code>Page Directory</code> 中的<code>槽</code>信息</li>
<li>Page Header中的各种⻚面统计信息，比如 PAGE_N_DIR_SLOTS表示的槽数量可能会更改，PAGE_HEAP_TOP代表的还未使用的空间最小地址可能会更改，PAGE_N_HEAP代表的本⻚面中的记录数量可能会更改，吧啦吧啦，各种信息都可能会被修改。</li>
<li>我们知道在数据⻚里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的next_record属性来维护这个单向链表。</li>
<li>还有别的吧啦吧啦的更新的地方，就不一一唠叨了…</li>
</ul>
<p>画一个简易的示意图就像是这样:<br><img src="/images/MySQL/20/4.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
</blockquote>
<hr>
<blockquote>
<p>说了这么多，就是想表达: <strong>把一条记录插入到一个⻚面时需要更改的地方非常多</strong>。<br>这时我们如果使用上边介绍的简单的物理redo日志来记录这些修改时，可以有两种解决方案:</p>
<ul>
<li>方案一:在每个修改的地方都记录一条redo日志。<blockquote>
<p>也就是如上图所示，有多少个加粗的块，就写多少条物理redo日志。<br>这样子记录redo日志的缺点是显而易⻅的，因为被修改的地方是在太多了，可能记录的redo日志占用的空间都比整个⻚面占用的空间都多了 😓</p>
</blockquote>
</li>
<li>方案二:将整个⻚面的第一个被修改的字节到最后一个修改的字节之间所有的数据当成是一条物理redo日志中的具体数据。<blockquote>
<p>从图中也可以看出来，第一个被修改的字节到最后一个修改的字节之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到redo日志中去岂不是太浪费了 😓</p>
</blockquote>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>正因为上述两种使用<code>物理redo日志</code>的方式来记录某个⻚面中做了哪些修改比较浪费，设计InnoDB的大叔本着勤俭节约的初心，提出了一些新的redo日志类型，比如:</p>
<ul>
<li><code>MLOG_REC_INSERT</code>(对应的十进制数字为9): 表示插入一条使用非紧凑行格式的记录时的redo日志类型。</li>
<li><code>MLOG_COMP_REC_INSERT</code>(对应的十进制数字为38): 表示插入一条使用紧凑行格式的记录时的redo日志类型。<blockquote>
<p>Tips:<br>Redundant是一种比较原始的行格式，它就是非紧凑的。而 Compact、Dynamic以及Compressed行格式是较新的行格式，它们是紧凑的(占用更小的存储空间)。</p>
</blockquote>
</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>(type字段对应的十进制数字为58): 表示创建一个存储紧凑行格式记录的⻚面的redo日志类型。</li>
<li><code>MLOG_COMP_REC_DELETE</code>(type字段对应的十进制数字为42): 表示删除一条使用紧凑行格式记录的redo日志类型。</li>
<li><code>MLOG_COMP_LIST_START_DELETE</code>(type字段对应的十进制数字为44): 表示从某条给定记录开始删除⻚面中的一系列使用紧凑行格式记录的redo日志类型。</li>
<li><code>MLOG_COMP_LIST_END_DELETE</code>(type字段对应的十进制数字为43): 与MLOG_COMP_LIST_START_DELETE类型的redo日志呼应，表示删除一系列记录直到MLOG_COMP_LIST_END_DELETE类型的redo日志对应的记录为止。<blockquote>
<p>小贴士:<br>我们前边唠叨InnoDB数据⻚格式的时候重点强调过，数据⻚中的记录是按照索引列大小的顺序组成单向链表的。有时候我们会有删除索引列的值在某个区间范围内的所有记录的需求，这时候如果我们每删除一条记录就写一条redo日志的话，效率可能有点低，所以提出 <code>MLOG_COMP_LIST_START_DELETE</code> 和 <code>MLOG_COMP_LIST_END_DELETE</code> 类型的redo日志，<strong>可以很大程度上减少redo日志的条数</strong> 。</p>
</blockquote>
</li>
<li><code>MLOG_ZIP_PAGE_COMPRESS</code>(type字段对应的十进制数字为51): 表示压缩一个数据⻚的redo日志类型。<br>······还有很多很多种类型，这就不列举了，等用到再说哈~</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>这些类型的redo日志既包含<code>物理层面</code>的意思，也包含<code>逻辑层面</code>的意思，具体指:</p>
<ul>
<li>物理层面看，这些日志都指明了对哪个表空间的哪个⻚进行了修改。</li>
<li>逻辑层面看，在系统奔溃重启时，并不能直接根据这些日志里的记载，将⻚面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将⻚面恢复成系统奔溃前的样子。</li>
</ul>
<p>大家看到这可能有些懵逼，我们还是以类型为 <code>MLOG_COMP_REC_INSERT</code> 这个代表插入一条使用紧凑行格式的记录时的redo日志为例来理解一下我们上边所说的物理层面和逻辑层面到底是个啥意思。废话少说，直接看一下这个类型为 <code>MLOG_COMP_REC_INSERT</code> 的redo日志的结构(由于字段太多了，我们把它们竖着看效果好些):<br><img src="/images/MySQL/20/5.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>这个类型为<code>MLOG_COMP_REC_INSERT</code>的redo日志结构有几个地方需要大家注意:</p>
<ul>
<li>我们前边在唠叨索引的时候说过，在一个数据⻚里，不论是<code>叶子节点</code>还是<code>非叶子节点</code>，记录都是按照索引列从小到大的顺序排序的。对于二级索引来说，当索引列的值相同时，记录还需要按照主键值进行排序。<br>图中<code>n_uniques</code>的值的含义是在一条记录中，需要几个字段的值才能确保记录的唯一性，这样当插入一条记录时就可以按照记录的前<code>n_uniques</code>个字段进行排序。<br>对于<code>聚簇索引</code>来说，n_uniques的值为主键的列数，对于其他二级索引来说，该值为<code>索引列数+主键列数</code>。这里需要注意的是，唯一二级索引的值可能为NULL，所以该值仍然为 <code>索引列数+主键列数</code>。</li>
<li>field1_len ~ fieldn_len 代表着该记录若干个字段占用存储空间的大小，需要注意的是，这里不管该字段的类型是固定⻓度大小的(比如INT)，还是可变⻓度大小(比如 VARCHAR(M))的，该字段占用的大小始终要写入redo日志中。</li>
<li>offset 代表的是该记录的前一条记录在⻚面中的地址。为啥要记录前一条记录的地址呢? 这是因为每向数据⻚插入一条记录，都需要修改该⻚面中维护的记录链表，每条记录的记录头信息中都包含一个称为next_record的属性，所以在插入新记录时，需要修改前一条记录的next_record属性。</li>
<li>我们知道一条记录其实由<code>额外信息</code>和<code>真实数据</code>这两部分组成，这两个部分的总大小就是一条记录占用存储空间的总大小。通过<code>end_seg_len</code>的值可以间接的计算出一条记录占用存储空间的总大小，为啥不直接存储一条记录占用存储空间的总大小呢?<br>这是因为写redo日志是一个非常频繁的操作，设计InnoDB的大叔想方设法想减小redo日志本身占用的存储空间大小，所以想了一些弯弯绕的算法来实现这个目标，<code>end_seg_len</code>这个字段就是为了节省redo日志存储空间而提出来的。<br>至于具体设计InnoDB的大叔到底是用了什么神奇魔法减小redo日志大小的，我们这就不多唠叨了，因为的确有那么一丢丢小复杂，说清楚还是有一点点麻烦的，而且说明白了也没啥用。</li>
<li><code>mismatch_index</code>的值也是为了节省redo日志的大小而设立的，大家可以忽略。</li>
</ul>
<p>很显然这个类型为<code>MLOG_COMP_REC_INSERT</code>的redo日志并没有记录<code>PAGE_N_DIR_SLOTS</code>的值修改为了啥，PAGE_HEAP_TOP的值修改为了啥，PAGE_N_HEAP的值修改为了啥等等这些信息，而只是把在本⻚面中插入一条记录所有必备的要素记了下来，之后系统奔溃重启时，服务器会调用相关向某个⻚面插入一条记录的那个函数，而redo日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，⻚面中的 PAGE_N_DIR_SLOTS、PAGE_HEAP_TOP、PAGE_N_HEAP等等的值也就都被恢复到系统奔溃前的样子了。这就是所谓的<code>逻辑日志</code>的意思。</p>
</blockquote>
<h1 id="redo日志格式小结"><a href="#redo日志格式小结" class="headerlink" title="redo日志格式小结"></a>redo日志格式小结</h1><p>虽然上边说了一大堆关于redo日志格式的内容，但是如果你不是为了写一个解析redo日志的工具或者自己开发一套redo日志系统的话，那就没必要把InnoDB中的各种类型的redo日志格式都研究的透透的，没那个必要。<br>上边只是象征性的介绍了几种类型的redo日志格式，目的还是想让大家明白: redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。</p>
<p>Tips: 为了节省redo日志占用的存储空间大小，设计InnoDB的大叔对redo日志中的某些数据还可能进行压缩处理，比方说spacd ID和 page number一般占用4个字节来存储，但是经过压缩后，可能使用更小的空间来存储。具体压缩算法就不唠叨了。</p>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/20.0 redo日志" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/11/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/20.0%20redo%E6%97%A5%E5%BF%97/">20.0 redo日志是个啥</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-11T13:07:32.000Z" itemprop="datePublished">2021年12月11日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/11/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/20.0%20redo%E6%97%A5%E5%BF%97/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前置知识点 : InnoDB<code>记录行格式</code>、<code>⻚面格式</code>、<code>索引原理</code>、<code>表空间的组成</code>等各种基础知识</p>
<h1 id="redo日志是个啥"><a href="#redo日志是个啥" class="headerlink" title="redo日志是个啥"></a>redo日志是个啥</h1><div style="font-weight:500;border: 1px solid #33b045;border-radius: 5px;padding:10px 10px 0 25px;">

<div style="font-weight:500;color:#33b045;margin-bottom:10px;">

<p>我们知道 InnoDB存储引擎是以<code>⻚</code>为单位来管理存储空间的 ，我们进行的增删改查操作本质上都是在访问<code>⻚</code>(包括对⻚面的读、写、创建等操作)。</p>
</div>

<div style="font-weight:500;color:#f8b500;margin-bottom:10px;">

<p>我们前边讲<code>Buffer Pool</code>时说过，在真正访问<code>⻚</code>之前，需要把在<code>磁盘上的⻚</code>缓存到<code>内存中的 Buffer Pool</code>之后才可以访问。</p>
<p>但是在讲<code>事务</code>时又强调过一个称之为<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。<br><span style="color:#FF416C;">但如果我们只在内存的<code>Buffer Pool</code>中修改了⻚面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的。</span></p>
</div>

</div>

<div style="border: 1px solid #000;border-radius: 5px;padding:10px 10px 0 25px;margin-top:20px;">

<p>那到底该如何来保证这个持久性呢?</p>
<p>一个很简单的做法就是<span style="color:#FF416C;font-weight:600;">在事务提交完成之前把该事务所修改的所有⻚面都刷新到磁盘</span>，但是这个做法太<span style="color:#FF416C;">简单粗暴</span>了，是有问题的:</p>
<ul>
<li><span style="color:#FF416C;font-weight:600;">刷新一个完整的数据⻚太浪费了</span><br>有时候我们仅仅修改了某个⻚面中的一个字节，但是InnoDB是以⻚为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的⻚面从内存中刷新到磁盘，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了；</li>
<li><span style="color:#FF416C;font-weight:600;">随机IO刷起来比较慢</span><br>一个事务可能包含很多语句，即使是一条语句也可能修改许多个⻚，<span style="color:#FF416C;font-weight:600;">这些⻚可能并不相邻，这就意味着在将某个事务修改的<code>Buffer Pool</code>中的<code>⻚</code>刷新到磁盘时，需要进行很多的<code>随机IO</code></span>，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说；</li>
</ul>
</div>

<div style="border: 1px solid #000;border-radius: 5px;padding:10px 10px 0 25px;margin-top:20px;">

<p>咋办呢?<br><span style="color:#FF416C;font-weight:600;">其实没有必要在每次事务提交时就把该事务在内存中修改过的全部⻚面刷新到磁盘</span>，<span style="color:#33b045;font-weight:600;">只需要把修改了哪些东⻄记录一下就好</span>，比方说某个事务将系统表空间中的第100号⻚面中偏移量为1000处的那个字节的值1改成2我们只需要记录一下:<code>将第0号表空间的100号⻚面的偏移量为1000处的值更新为2。</code></p>
<p>这样我们在事务提交时，只用把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据⻚，那么该事务对数据库中所做的修改又可以被恢复出来。<br>因为在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据⻚，所以上述内容也被称之为<code>重做日志</code>，英文名为<code>redo log</code>。</p>
</div>

<div style="font-weight:500;border: 2px solid #33b045;border-radius: 5px;margin-top:10px;padding:10px 10px 0 25px;">

<p>与在事务提交时将所有修改过的内存中的⻚面刷新到磁盘中相比，只将该事务执行过程中产生的redo日志刷新到磁盘的好处如下:</p>
<ul>
<li><span style="color:#33b045;font-weight:600;">redo日志占用的空间非常小</span><br>存储表空间ID、⻚号、偏移量以及需要更新的值所需的存储空间是很小的，关于redo日志的格式我们稍后会详细唠叨，现在只要知道一条redo日志占用的空间不是很大就好了。</li>
<li><span style="color:#33b045;font-weight:600;">redo日志是顺序写入磁盘的</span><br>在执行事务的过程中，每执行一条语句，可能会产生若干条redo日志，不过，这些日志是按照产生的顺序写入磁盘的，也就是使用<code>顺序IO</code>，比你每次提交去将不相邻的页(<code>随机IO</code>)落盘强多了。</li>
</ul>
</div>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/19.事务简介" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/10/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/19.%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/">19. 事务简介</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-10T13:06:17.000Z" itemprop="datePublished">2021年12月10日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/10/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/19.%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="事务的起源"><a href="#事务的起源" class="headerlink" title="事务的起源"></a>事务的起源</h1><blockquote>
<p>对于大部分程序员来说，他们的任务就是把现实世界的业务场景映射到数据库世界。</p>
<p>比如银行为了存储人们的账户信息会建立一个account表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    name VARCHAR(100) COMMENT &#x27;客户名称&#x27;, </span><br><span class="line">    balance INT COMMENT &#x27;余额&#x27;,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>狗哥和猫爷是一对好基友，他们都到银行开一个账户，他们在现实世界中拥有的资产就会体现在数据库世界的account表中。<br>比如现在狗哥有11元，猫爷只有2元，那么现实中的这个情况映射到数据库的account表就是这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------+---------+ </span><br><span class="line">| id | name | balance | </span><br><span class="line">+----+------+---------+ </span><br><span class="line">| 1  |  狗哥 |    11   | </span><br><span class="line">| 2  |  猫爷 |    2    | </span><br><span class="line">+----+------+---------+</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<blockquote>
<p>随着时间的流逝，狗哥和猫爷可能陆续进行向账户中存钱、取钱或者向别人转账，这样他们账户中的余额就可能发生变动。<br>不变不知道，一变吓一跳，现实世界中一些看似很简单的状态转换，映射到数据库世界却不是那么容易的。</p>
<p>比方说有一次猫爷在赌场赌博输了钱，急忙打电话给狗哥要借10块钱，不然那些看场子的就会把自己剁了。<br>现实世界中的狗哥走向了ATM机，输入了猫爷的账号以及10元的转账金额，然后按下确认，狗哥就拔卡走人了。<br>对于数据库世界来说，相当于执行了下边这两条语句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br></pre></td></tr></table></figure>
</blockquote>
<div style="font-weight:500;border: 1px solid #33b045;border-radius: 5px;padding:10px 10px 0 25px;">

<p><strong>但是这里头有个问题，上述两条语句如果只执行了一条时，忽然服务器断电了咋办?</strong> </p>
<ul>
<li>把狗哥的钱扣了，但是没给猫爷转过去，那猫爷还是逃脱不了被砍死的噩运。</li>
<li><span style="font-weight:600;color:#FF416C">即使对于<code>单独的一条语句</code>，我们前边唠叨<code>Buffer Pool</code>时也说过，在对某个⻚面进行读写访问时，都会先把这个⻚面加载到<code>Buffer Pool</code>中，之后如果修改了某个⻚面，也不会立即把修改同步到磁盘，而只是把这个修改了的⻚面加到<code>Buffer Pool</code>的<code>flush链表</code>中，在之后的某个时间点才会刷新到磁盘。如果在将修改过的⻚刷新到磁盘之前系统崩溃了那岂不是猫爷还是要被砍死? </span></li>
<li>或者<span style="font-weight:600;color:#FF416C">在刷新磁盘的过程中 只刷新部分数据到磁盘上时，系统奔溃了</span> 猫爷也会被砍死?</li>
</ul>
</div>

<hr>
<p>怎么才能保证让可怜的猫爷不被砍死呢?<br>其实再仔细想想，我们只是想让某些数据库操作符合现实世界中状态转换的规则而已，设计数据库的大叔们仔细盘算了盘算，现实世界中状态转换的规则有好几条，待我们慢慢道来。</p>
<h1 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h1><p>现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。<br>设计数据库的大叔们把这种要么全做，要么全不做的规则称之为<code>原子性</code>。</p>
<div style="font-weight:500;border: 1px solid #33b045;border-radius: 5px;">

<ul>
<li>但是在现实世界中的<span style="font-weight:600;color:#FF416C">一个不可分割的操作却可能对应着数据库世界若干条不同的操作</span>；</li>
<li><span style="font-weight:600;color:#FF416C">数据库中的一条操作也可能被分解成若干个步骤</span> (比如<code>先修改缓存⻚</code>，<code>之后再刷新到磁盘</code>等)；</li>
<li><span style="color:#FF416C;font-weight:600;">最要命的是在任何一个可能的时间都可能发生意想不到的错误(可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的)而使操作执行不下去</span>；</li>
</ul>
<p>所以猫爷可能会被砍死。</p>
</div>

<p>为了保证在数据库世界中某些操作的<code>原子性</code>，设计数据库的大叔 <strong>需要费一些心机来保证如果在执行操作的过程中发生了错误，得把已经做了的操作恢复成没执行之前的样子</strong> ，这也是我们后边章节要仔细唠叨的内容。</p>
<h1 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h1><blockquote>
<p><strong>现实世界中的两次状态转换应该是互不影响的</strong> ，比如说狗哥向猫爷同时进行的两次金额为5元的转账(假设可以在两个ATM机上同时操作)。那么最后狗哥的账户里肯定会少10元，猫爷的账户里肯定多了10元。</p>
<p>但是到对应的数据库世界中，事情又变的复杂了一些。 为了简化问题，我们粗略的假设狗哥向猫爷转账5元的过程是由下边几个步骤组成的:</p>
<ul>
<li>步骤一: 读取狗哥账户的余额到变量A中，这一步骤简写为<code>read(A)</code>。</li>
<li>步骤二: 将狗哥账户的余额减去转账金额，这一步骤简写为 <code>A = A - 5</code>。</li>
<li>步骤三: 将狗哥账户修改过的余额写到磁盘里，这一步骤简写为 <code>write(A)</code>。</li>
<li>步骤四: 读取猫爷账户的余额到变量B，这一步骤简写为 <code>read(B)</code>。</li>
<li>步骤五: 将猫爷账户的余额加上转账金额，这一步骤简写为 <code>B = B + 5</code>。</li>
<li>步骤六: 将猫爷账户修改过的余额写到磁盘里，这一步骤简写为 <code>write(B)</code>。</li>
</ul>
<p>我们将狗哥向猫爷同时进行的<strong>两次</strong>转账操作分别称为T1和T2，在现实世界中T1和T2是应该没有关系的，可以先执行完T1，再执行T2，或者先执行完T2，再执行T1，对应的数据库操作就像这样:<br><img src="/images/MySQL/19/1.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br><span style="font-weight:600;color:#FF416C">但是很不幸，真实的数据库中T1和T2的操作可能交替执行</span>:<br><img src="/images/MySQL/19/2.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>如果按照上图中的执行顺序来进行两次转账的话，最终狗哥的账户里还剩6元钱，相当于只扣了5元钱，但是猫爷的账户里却成了12元钱，相当于多了10元钱，这银行岂不是要亏死了?</p>
</blockquote>
<hr>
<blockquote>
<p>所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以<code>原子性</code>的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为<code>隔离性</code>。<br>这时设计数据库的大叔们就需要采取一些措施来让访问相同数据(上例中的A账户和B账户)的不同状态转换(上例中的T1和T2)<strong>对应的数据库操作的执行顺序有一定规律</strong>，这也是我们后边章节要仔细唠叨的内容。</p>
</blockquote>
<h1 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h1><blockquote>
<p>lant:<br>一致性是指事务执行前后，数据库从一个一致性状态转换到另一个一致性状态。这个一致性包括业务上的一些规则。<br>换句话说，事务应确保数据库的完整性约束得到维护。</p>
<p>例如，如果有一个完整性约束要求一个账户的余额不能为负数，那么在事务执行之后，这个约束仍然应该得到满足。<br>再比如执行转账操作前，我们业务上认为 “A用户100元,B用户0元” 是一个一致性状态，转账成功后，“A用户0元,B用户100元” 是另一个一致性状态。 </p>
<p>事务应该保证这样的状态转变。</p>
</blockquote>
<h1 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h1><blockquote>
<p>lant: 持久性是指事务一旦提交，对数据库所做的修改将会在磁盘上保留下来。即使在系统故障或重启的情况下，已提交的事务对数据库的更改也不会丢失。</p>
</blockquote>
<h1 id="MySQL中事务的语法"><a href="#MySQL中事务的语法" class="headerlink" title="MySQL中事务的语法"></a>MySQL中事务的语法</h1><ol>
<li>开启事务(可以使用下边两种语句之一来开启一个事务)</li>
</ol>
<ul>
<li><code>BEGIN [WORK]</code> :<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//BEGIN 语句代表开启一个事务，后边的单词`WORK`可有可无。</span><br><span class="line">//开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。</span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure></li>
<li><code>START TRANSACTION</code> : 和<code>BEGIN</code>语句有着相同的功效，都标志着开启一个事务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>提交事务<br>开启事务之后就可以继续写需要放到该事务中的语句了，当最后一条语句写完了之后，我们就可以提交该事务了，提交的语句也很简单：<code>COMMIT [WORK]</code>， 一个简单的事务的完整过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">// `COMMIT`语句就代表提交一个事务，后边的`WORK`可有可无。</span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动中止事务<br>如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事务执行之前的样子：<code>ROLLBACK [WORK]</code>， 一个简单的事务回滚案例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">// `ROLLBACK`语句就代表中止并回滚一个事务，后边的`WORK`可有可无类似的</span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>这里需要强调一下，<code>ROLLBACK</code>语句是我们程序员手动的去回滚事务时才去使用的。 <strong>如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚。</strong></p>
</li>
</ol>
<h1 id="事务的-自动提交"><a href="#事务的-自动提交" class="headerlink" title="事务的 自动提交"></a>事务的 自动提交</h1><ol>
<li><p><code>MySQL</code>中有一个系统变量<code>autocommit</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到它的默认值为<code>ON</code>。<br>也就是说默认情况下，如果我们不显式的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么每一条sql语句都算是一个独立的事务，这种特性称之为事务的<code>自动提交</code>。</p>
</li>
<li><p>当然，如果我们想关闭这种<code>自动提交</code>的功能，可以使用下边两种方法之一：</p>
</li>
</ol>
<ul>
<li>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li>
<li>把系统变量<code>autocommit</code>的值设置为<code>OFF</code> (<code>SET autocommit = OFF;</code>)<br>这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出<code>COMMIT</code>语句来把这个事务提交掉，或者显式的写出<code>ROLLBACK</code>语句来把这个事务回滚掉。</li>
</ul>
<h1 id="事务的-隐式提交"><a href="#事务的-隐式提交" class="headerlink" title="事务的 隐式提交"></a>事务的 隐式提交</h1><p>当我们使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了一个事务，或者把系统变量<code>autocommit</code>的值设置为<code>OFF</code>时，事务就不会进行<code>自动提交</code>了。<br>但是如果我们输入了某些语句之后，事务是会<code>悄悄的</code>提交的，就像我们输入了<code>COMMIT</code>语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为<code>隐式提交</code>，这些会导致事务隐式提交的语句包括：</p>
<ol>
<li><p>定义或修改数据库对象的数据定义语言(Data definition language，缩写为：<code>DDL</code>)。</p>
<ul>
<li>所谓的数据库对象，指的就是<code>数据库</code>、<code>表</code>、<code>视图</code>、<code>存储过程</code>等等这些东西。</li>
<li>当我们使用<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务，就像这样：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE ... # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>隐式使用或修改<code>mysql</code>数据库中的表<br>当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。</p>
</li>
<li><p>事务控制或关于锁定的语句<br>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会隐式的提交上一个事务，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">BEGIN; # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>或者使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>加载数据的语句<br>比如我们使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>关于<code>MySQL</code>复制的一些语句<br>使用<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句时也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>其它的一些语句<br>使用<code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、 <code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code>等语句也会隐式的提交前边语句所属的事务。</p>
</li>
</ol>
<p>Tips: 上边提到的一些语句，如果你都认识并且知道是干嘛用的那再好不过了，不认识也不要气馁，这里写出来只是为了内容的完整性，把可能会导致事务隐式提交的情况都列举一下，具体每个语句都是干嘛用的等我们遇到了再说哈。</p>
<h1 id="事务的-保存点"><a href="#事务的-保存点" class="headerlink" title="事务的 保存点"></a>事务的 保存点</h1><ol>
<li><p>如果你开启了一个事务，并且已经敲了很多语句，忽然发现上一条语句有点问题，你只好使用<code>ROLLBACK</code>语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，总有一种一夜回到解放前的感觉。</p>
</li>
<li><p>所以设计数据库的大叔们提出了一个<code>保存点</code>(savepoint)的概念，就是在事务对应的数据库语句中打几个点，我们在调用<code>ROLLBACK</code>语句时可以指定会滚到哪个点，而不是回到最初的原点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义保存点的语法如下：</span><br><span class="line">SAVEPOINT 保存点名称;</span><br><span class="line"></span><br><span class="line">//当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词`WORK`和`SAVEPOINT`是可有可无的）：</span><br><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</span><br><span class="line">// 如果`ROLLBACK`语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。</span><br><span class="line"></span><br><span class="line">//如果我们想删除某个保存点，可以使用这个语句：</span><br><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面还是以转账的例子展示一下<code>保存点</code>的用法，在执行完扣除狗哥账户的钱<code>10</code>元的语句之后打一个<code>保存点</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |      11 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+-------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SAVEPOINT s1;    # 一个保存点</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2; # 更新错了</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK TO s1;  # 回滚到保存点s1处</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">-----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1  |</span><br><span class="line">|  2 | 猫爷   |       2  |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>







        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL-InnoDB-页结构/18.调节磁盘和CPU的矛盾--InnoDB的Buffer Pool" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/06/MySQL-InnoDB-%E9%A1%B5%E7%BB%93%E6%9E%84/18.%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCPU%E7%9A%84%E7%9F%9B%E7%9B%BE--InnoDB%E7%9A%84Buffer%20Pool/">18. 调节磁盘和CPU的矛盾--InnoDB的Buffer Pool</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-06T14:01:26.000Z" itemprop="datePublished">2021年12月06日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/06/MySQL-InnoDB-%E9%A1%B5%E7%BB%93%E6%9E%84/18.%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCPU%E7%9A%84%E7%9F%9B%E7%9B%BE--InnoDB%E7%9A%84Buffer%20Pool/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="缓存的重要性"><a href="#缓存的重要性" class="headerlink" title="缓存的重要性"></a>缓存的重要性</h1><p>通过前边的唠叨我们知道，对于使用InnoDB作为存储引擎的表来说，不管是用于存储用户数据的索引(包括<code>聚簇索引</code>和<code>二级索引</code>)， 还是各种系统数据，都是以<code>⻚</code>的形式存放在<code>表空间</code>中的，而<strong>所谓的<code>表空间</code>只不过是InnoDB对文件系统上一个或几个实际文件的抽象</strong> ，也就是说我们的数据说到底还是存储在磁盘上的。<br>但是各位也都知道，磁盘的速度慢的跟乌龟一样，怎么能配得上“快如⻛，疾如电”的CPU呢? 所以InnoDB存储引擎在处理客户端的请求时，<strong>当需要访问某个⻚的数据时，就会把完整的⻚的数据全部加载到内存中</strong> ，<span style="color:#FF416C">也就是说即使我们只需要访问一个⻚的一条记录，那也需要先把整个⻚的数据加载到内存中</span>。<br>将整个⻚加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该⻚对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该⻚面时，就可以省去磁盘IO的开销了。</p>
<h1 id="啥是个Buffer-Pool"><a href="#啥是个Buffer-Pool" class="headerlink" title="啥是个Buffer Pool"></a>啥是个Buffer Pool</h1><p>设计InnoDB的大叔为了缓存磁盘中的⻚，在MySQL服务器启动的时候就向操作系统申请了一片连续的内存，他们给这片内存起了个名，叫做 <code>Buffer Pool(中文名是缓冲池)</code>。</p>
<p>那它有多大呢? 这个其实看我们机器的配置，如果你是土豪，你有512G内存，你分配个几百G作为Buffer Pool也可以啊，当然你要是没那么有钱，设置小点也行呀。<br>默认情况下<code>Buffer Pool</code>只有128M大小。当然如果你嫌这个128M太大或者太小，可以在启动服务器的时候配置 <code>innodb_buffer_pool_size</code> 参数的值，它表示Buffer Pool 的大小，就像这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size = 268435456</span><br><span class="line"># 268435456的单位是字节，也就是我指定Buffer Pool的大小为256M。</span><br><span class="line"># 需要注意的是，Buffer Pool也不能太小，最小值为5M(当小于该值时会自动设置成5M)。</span><br></pre></td></tr></table></figure>

<h1 id="Buffer-Pool内部组成"><a href="#Buffer-Pool内部组成" class="headerlink" title="Buffer Pool内部组成"></a>Buffer Pool内部组成</h1><p><code>Buffer Pool</code>中默认的<code>缓存⻚</code>大小和在磁盘上默认的⻚大小是一样的，都是16KB。<br>为了更好的管理这些在Buffer Pool中的缓存⻚， 设计InnoDB的大叔为每一个缓存⻚都创建了一些所谓的控制信息， 这些控制信息包括该⻚所属的表空间编号、⻚号、缓存⻚在Buffer Pool中的地址、链表节点信息、一些锁信息以及LSN信息(锁和LSN 我们之后会具体唠叨，现在可以先忽略)，当然还有一些别的控制信息，我们这就不全唠叨一遍了，挑重要的说嘛。</p>
<p>每个缓存⻚对应的控制信息占用的内存大小是相同的，我们就把每个⻚对应的控制信息占用的一块内存称为一个<code>控制块</code>吧，<code>控制块</code>和<code>缓存⻚</code>是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存⻚被存放到 Buffer Pool 后边，所以整个Buffer Pool对应的内存空间看起来就是这样的:<br><img src="/images/MySQL/18/1.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<blockquote>
<p>咦? <code>控制块</code>和<code>缓存⻚</code>之间的那个碎片是个什么玩意儿?<br>你想想啊，每一个控制块都对应一个缓存⻚，那在分配足够多的控制块和缓存⻚后，可能剩余的那点儿空间不够一对控制块和缓存⻚的大小，自然就用不到喽，这个用不到的那点儿内存空间就被称为碎片了。<br>当然，如果你把Buffer Pool的大小设置的刚刚好的话，也可能不会产生碎片。</p>
</blockquote>
<blockquote>
<p>Tips:<br>每个<code>控制块</code>大约占用<code>缓存⻚</code>大小的5%，在MySQL5.7.21这个版本中，每个控制块占用的大小是808字节。而我们设置的<code>innodb_buffer_pool_size</code> 并不包含这部分控制块占用的内存空间大小，也就是说InnoDB在为Buffer Pool向操作系统申请连续的内存空间时，这片连续的内存空间一般会比 innodb_buffer_pool_size的值大5%左右。</p>
</blockquote>
<h1 id="free链表的管理"><a href="#free链表的管理" class="headerlink" title="free链表的管理"></a>free链表的管理</h1><p>当我们最初启动MySQL服务器的时候，需要完成对Buffer Pool的初始化过程，就是先向操作系统申请Buffer Pool的内存空间，然后把它划分成若干对<code>控制块</code>和<code>缓存⻚</code>。</p>
<p>但是此时并没有真实的磁盘⻚被缓存到Buffer Pool中(因为还没有用到)，之后随着程序的运行，会不断的有磁盘上的⻚被缓存到Buffer Pool中。</p>
<p>那么问题来了，从磁盘上读取一个⻚到Buffer Pool中的时候该放到哪个缓存⻚的位置呢? 或者说怎么区分Buffer Pool中哪些缓存⻚是空闲的，哪些已经被使用了呢?<br>我们最好在某个地方记录一下Buffer Pool中哪些缓存⻚是可用的，这个时候缓存⻚对应的控制块就派上大用场了，我们可以把所有空闲的缓存⻚对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作 <code>free链表</code>(或者说<code>空闲链表</code>)。<br>刚刚完成初始化的Buffer Pool中所有的缓存⻚都是空闲的，所以每一个缓存⻚对应的控制块都会被加入到free链表中，假设该Buffer Pool中可容纳的缓存⻚数量为n，那增加了free链表的效果图就是这样的:<br><img src="/images/MySQL/18/2.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>从图中可以看出，我们为了管理好这个free链表，特意为这个链表定义了一个<code>基节点</code>，里边儿包含着链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。<br>这里需要注意的是，链表的基节点占用的内存空间并不包含在为Buffer Pool申请的一大片连续内存空间之内，而是单独申请的一块内存空间。</p>
<p>Tips:<br>链表基节点占用的内存空间并不大，在MySQL5.7.21这个版本里， 每个基节点只占用40字节大小。<br>后边我们即将介绍许多不同的链表，它们的基节点和free链表的基节点的内存分配方式是一样一样的，都是单独申请的一块40字节大小的内存空间，并不包含在为 Buffer Pool申请的一大片连续内存空间之内。</p>
<p>有了这个<code>free链表</code>之后事儿就好办了，每当需要从磁盘中加载一个⻚到Buffer Pool中时，就从free链表中取一个空闲的缓存⻚，并且把该缓存⻚对应的控制块的信息填上(就是该⻚所在的表空间、⻚ 号之类的信息)，然后把该缓存⻚对应的free链表节点从链表中移除，表示该缓存⻚已经被使用了。</p>
<h1 id="缓存⻚的哈希处理"><a href="#缓存⻚的哈希处理" class="headerlink" title="缓存⻚的哈希处理"></a>缓存⻚的哈希处理</h1><p>我们前边说过，当我们需要访问某个⻚中的数据时，就会把该⻚从磁盘加载到Buffer Pool中，如果该⻚已经在Buffer Pool中的话直接使用就可以了。</p>
<p>那么问题也就来了，我们怎么知道该⻚在不在Buffer Pool中呢? 难不成需要依次遍历Buffer Pool中各个缓存⻚么? 一个Buffer Pool中的缓存⻚这么多，都遍历完岂不是要累死?<br>再回头想想，我们其实是根据 <code>表空间号 + ⻚号</code> 来定位一个⻚的，也就相当于 <code>表空间号 + ⻚号</code> 是一个key，缓存⻚就是对应的value， 怎么通过一个key来快速找着一个value呢? 哈哈，那肯定是哈希表喽。</p>
<p>所以我们可以用 <code>表空间号 + ⻚号</code> 作为key，缓存⻚作为value创建一个哈希表，在需要访问某个⻚的数据时，先从哈希表中根据 <code>表空间号 + ⻚号</code> 看看有没有对应的缓存⻚，如果有，直接使用该缓存⻚就好，如果没有，那就从<code>free链表</code>中选一个空闲的<code>缓存⻚</code>，然后把磁盘中对应的⻚加载到该缓存⻚的位置。</p>
<h1 id="flush链表的管理"><a href="#flush链表的管理" class="headerlink" title="flush链表的管理"></a>flush链表的管理</h1><p>如果我们修改了Buffer Pool中某个缓存⻚的数据，那它就和磁盘上的⻚不一致了，这样的缓存⻚也被称为<code>脏⻚</code>(英文名:dirty page)。<br>当然，最简单的做法就是每发生一次修改就立即同步到磁盘上对应的⻚上，<span style="color:#FF416C; font-weight:600;">但是频繁的往磁盘中写数据会严重的影响程序的性能(毕竟磁盘慢的像乌龟一样)</span>。<br>所以每次修改缓存⻚后，我们并不着急立即把修改同步到磁盘上，而是在未来的某个时间点进行同步， 至于这个同步的时间点我们后边会作说明说明的，现在先不用管哈。<br>但是如果不立即同步到磁盘的话，那之后再同步的时候我们怎么知道Buffer Pool中哪些⻚是脏⻚，哪些⻚从来没被修改过呢? 总不能把所有的缓存⻚都同步到磁盘上吧，假如Buffer Pool被设置的很大，比方说300G，那一次性同步这么多数据岂不是要慢死!<br>所以，我们不得不再创建一个<code>存储脏⻚的链表</code>，凡是修改过的缓存⻚对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存⻚都是需要被刷新到磁盘上的，所以也叫<code>flush链表</code>。链表的构造和free链表差不多，假设某个时间点Buffer Pool中的脏⻚数量为n，那么对应的flush链表就⻓这样:<br><img src="/images/MySQL/18/3.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<h1 id="LRU链表的管理"><a href="#LRU链表的管理" class="headerlink" title="LRU链表的管理"></a>LRU链表的管理</h1><h2 id="缓存不够的窘境"><a href="#缓存不够的窘境" class="headerlink" title="缓存不够的窘境"></a>缓存不够的窘境</h2><p>Buffer Pool对应的内存大小毕竟是有限的，如果需要缓存的⻚占用的内存大小超过了Buffer Pool大小，也就是<code>free链表</code>中已经没有多余的空闲缓存⻚的时候岂不是很尴尬，发生了这样的事儿该咋办?<br>当然是把某些旧的缓存⻚从Buffer Pool中移除，然后再把新的⻚放进来喽。 那么问题来了，移除哪些缓存⻚呢?</p>
<p>为了回答这个问题，我们还需要回到我们设立Buffer Pool的初衷，我们就是想减少和磁盘的IO交互，最好每次在访问某个⻚时它都已经被缓存到Buffer Pool中了。<br>假设我们一共访问了n次⻚，那么被访问的⻚已经在缓存中的次数除以n就是所谓的缓存命中率，我们的期望就是让缓存命中率越高越好。<br>从这个⻆度出发，回想一下我们的微信聊天列表，排在前边的都是最近很频繁使用的，排在后边的自然就是最近很少使用的，假如列表能容纳下的联系人有限，你是会把最近很频繁使用的留下还是最近很少使用的留下呢? 当然是留下最近很频繁使用的了。</p>
<h2 id="简单的LRU链表"><a href="#简单的LRU链表" class="headerlink" title="简单的LRU链表"></a>简单的LRU链表</h2><p>管理Buffer Pool的缓存⻚其实也是这个道理，当Buffer Pool 中不再有空闲的缓存⻚时，就需要淘汰掉部分最近很少使用的缓存⻚。</p>
<p>不过，我们怎么知道哪些缓存⻚最近频繁使用，哪些最近很少使用呢?<br>呵呵，神奇的链表再一次派上了用场，我们可以再创建一个链表，由于这个链表是为了按照<code>最近最少使用</code>的原则去淘汰缓存⻚的， 所以这个链表可以被称为<code>LRU链表</code>(LRU的英文全称:Least Recently Used)。<br>当我们需要访问某个⻚时，可以这样处理LRU链表:</p>
<ul>
<li>如果该⻚不在Buffer Pool中，在把该⻚从磁盘加载到Buffer Pool中的缓存⻚时，就把该缓存⻚对应的控制块作为节点塞到链表的头部。</li>
<li>如果该⻚已经缓存在Buffer Pool中，则直接把该⻚对应的控制块移动到LRU链表的头部。</li>
</ul>
<p>也就是说: 只要我们使用到某个缓存⻚，就把该缓存⻚调整到LRU链表的头部，这样LRU链表尾部就是最近最少使用的缓存⻚喽。<br>所以当Buffer Pool中的空闲缓存⻚使用完时，到LRU链表的尾部找些缓存⻚淘汰就OK啦，真简单，啧啧…</p>
<h2 id="划分区域的LRU链表"><a href="#划分区域的LRU链表" class="headerlink" title="划分区域的LRU链表"></a>划分区域的LRU链表</h2><p>高兴的太早了，上边的这个简单的LRU链表用了没多⻓时间就发现问题了，因为存在这两种比较尴尬的情况:</p>
<ol>
<li><p>情况一: InnoDB提供了一个看起来比较贴心的服务–预读 (英文名:read ahead)。</p>
<blockquote>
<p>所谓预读，就是InnoDB认为执行当前的请求可能之后会读取某些⻚面，就预先把它们加载到Buffer Pool中。<br>根据触发方式的不同，预读又可以细分为下边两种:</p>
<ul>
<li>线性预读<blockquote>
<p>设计InnoDB的大叔提供了一个系统变量 <code>innodb_read_ahead_threshold</code>，如果顺序访问了某个区(extent)的⻚面超过这个系统变量的值，就会触发一次异步读取下一个区中全部的⻚面到Buffer Pool的请求，注意异步读取意味着从磁盘中加载这些被预读的⻚面并不会影响到当前工作线程的正常执行。<br>这个 <code>innodb_read_ahead_threshold</code> 系统变量的值默认是56，我们可以在服务器启动时通过启动参数或者服务器运行过程中直接调整该系统变量的值，不过它是一个<code>全局变量</code>，注意使用<code>SET GLOBAL</code>命令来修改哦。<br>Tips:<br>InnoDB是怎么实现异步读取的呢? 在Windows或者 Linux平台上，可能是直接调用操作系统内核提供的AIO接口，在其它类Unix操作系统中，使用了一种模拟AIO接口的方式来实现异步读取，其实就是让别的线程去读取需要预读的⻚面。如果你读不懂上边这段话，那也就没必要懂了，和我们主题其实没太多关系，你只需要知道异步读取并不会影响到当前工作线程的正常执行就好了。其实这个过程涉及到操作系统如何处理IO以及多线程的问题，找本操作系统的书看看吧。</p>
</blockquote>
</li>
<li>随机预读<blockquote>
<p>如果Buffer Pool中已经缓存了某个区的13个连续的⻚面，不论这些⻚面是不是顺序读取的，都会触发一次异步读取本区中所有其的⻚面到Buffer Pool的请求。设计InnoDB的大叔同时提供了 <code>innodb_random_read_ahead</code> 系统变量，它的默认值为OFF，也就意味着InnoDB并不会默认开启随机预读的功能，如果我们想开启该功能，可以通过修改启动参数或者直接使用<code>SET GLOBAL</code>命令把该变量的值设置为ON。</p>
</blockquote>
</li>
</ul>
<p>预读本来是个好事儿，如果预读到Buffer Pool中的⻚成功的被使用到，那就可以极大的提高语句执行的效率。可是如果用不到呢?这些预读的⻚都会放到LRU链表的头部，但是如果此时Buffer Pool的容量不太大而且很多预读的⻚面都没有用到的话，这就会导致处在LRU链表尾部的一些缓存⻚会很快的被淘汰掉，也就是所谓的劣币驱逐良币，会大大降低缓存命中率。</p>
</blockquote>
</li>
<li><p>情况二:有的小伙伴可能会写一些需要扫描全表的查询语句(比如没有建立合适的索引或者压根儿没有WHERE子句的查询)。</p>
<blockquote>
<p>扫描全表意味着将访问到该表所在的所有⻚! 假设这个表中记录非常多的话，那该表会占用特别多的⻚，当需要访问这些⻚时，会把它们统统都加载到Buffer Pool中， 这也就意味着吧唧一下，Buffer Pool中的所有⻚都被换了一次血，其他查询语句在执行时又得执行一次从磁盘加载到Buffer Pool的操作。<br><strong>而这种全表扫描的语句执行的频率也不高，但每次执行都要把Buffer Pool中的缓存⻚换一次血，这严重的影响到其他查询对 Buffer Pool的使用，从而大大降低了缓存命中率。</strong></p>
</blockquote>
</li>
</ol>
<p>总结一下上边说的可能降低Buffer Pool的两种情况:</p>
<ul>
<li>加载到Buffer Pool中的⻚不一定被用到。</li>
<li>如果非常多的使用频率偏低的⻚被同时加载到Buffer Pool 时，可能会把那些使用频率非常高的⻚从Buffer Pool中淘汰掉。</li>
</ul>
<hr>
<p>因为有这两种情况的存在，所以设计InnoDB的大叔把这个LRU链表按照一定比例分成两截，分别是: </p>
<ul>
<li><p>一部分存储使用频率非常高的缓存⻚，所以这一部分链表也叫做<code>热数据</code>，或者称young区域。 </p>
</li>
<li><p>另一部分存储使用频率不是很高的缓存⻚，所以这一部分链表也叫做<code>冷数据</code>，或者称old区域。 </p>
</li>
<li><p>为了方便大家理解，我们把示意图做了简化，各位领会精神就好:</p>
<img src="/images/MySQL/18/4.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></li>
</ul>
<hr>
<p>大家要特别注意一个事儿:我们是按照某个比例将LRU链表分成两半的，不是某些节点固定是young区域的，某些节点固定是old区域的，随着程序的运行，某个节点所属的区域也可能发生变化。那这个划分成两截的比例怎么确定呢?对于InnoDB存储引擎来说，我们可以通过查看系统变量<code>innodb_old_blocks_pct</code>的值来确定old区域在LRU链表中所占的比例，比方说这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;innodb_old_blocks_pct&#x27;; </span><br><span class="line">+-----------------------+-------+ </span><br><span class="line">| Variable_name | Value | </span><br><span class="line">+-----------------------+-------+ </span><br><span class="line">| innodb_old_blocks_pct | 37 | </span><br><span class="line">+-----------------------+-------+ </span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>从结果可以看出来，默认情况下，old区域在LRU链表中所占的比例是37%，也就是说old区域大约占LRU链表的3&#x2F;8。这个比例我们是可以设置的，我们可以在启动时修改innodb_old_blocks_pct参数来控制old区域在LRU链表中所占的比例，比方说这样修改配置文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server] </span><br><span class="line">innodb_old_blocks_pct = 40</span><br></pre></td></tr></table></figure>
<p>这样我们在启动服务器后，old区域占LRU链表的比例就是40%。当然，如果在服务器运行期间，我们也可以修改这个系统变量的值，不过需要注意的是，这个系统变量属于全局变量，一经修改，会对所有客户端生效，所以我们只能这样修改:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL innodb_old_blocks_pct = 40;</span><br></pre></td></tr></table></figure>

<hr>
<p>有了这个被划分成young和old区域的LRU链表之后，设计InnoDB的大叔就可以针对我们上边提到的两种可能降低缓存命中率的情况进行优化了:</p>
<ul>
<li><p>针对预读的⻚面可能不进行后续访情况的优化<br>设计InnoDB的大叔规定，当磁盘上的某个⻚面在初次加载到Buffer Pool中的某个缓存⻚时，该缓存⻚对应的控制块会被放到old区域的头部。<br>这样针对预读到Buffer Pool却不进行后续访问的⻚面就会被逐渐从old区域逐出，而不会影响young区域中被使用比较频繁的缓存⻚。</p>
</li>
<li><p>针对全表扫描时，短时间内访问大量使用频率非常低的⻚面情况的优化<br>在进行全表扫描时，虽然首次被加载到Buffer Pool的⻚被放到了old区域的头部，但是后续会被⻢上访问到，每次进行访问的时候又会把该⻚放到young区域的头部，这样仍然会把那些使用频率比较高的⻚面给顶下去。<br>有同学会想:可不可以在第一次访问该⻚面时不将其从old区域移动到young区域的头部，后续访问时再将其移动到young区域的头部。<br>回答是: 行不通! 因为设计InnoDB的大叔规定每次去⻚面中读取一条记录时，都算是访问一次⻚面，而一个⻚面中可能会包含很多条记录，也就是说读取完某个⻚面的记录就相当于访问了这个⻚面好多次。<br>咋办? 全表扫描有一个特点，那就是它的执行频率非常低，谁也不会没事儿老在那写全表扫描的语句玩，而且在执行全表扫描的过程中，即使某个⻚面中有很多条记录，也就是去多次访问这个⻚面所花费的时间也是非常少的。<br>所以我们只需要规定，在对某个处在old区域的缓存⻚进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该⻚面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部。<br>上述的这个间隔时间是由系统变量 <code>innodb_old_blocks_time</code> 控制的，你看:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;innodb_old_blocks_time&#x27;; </span><br><span class="line">+------------------------+-------+ </span><br><span class="line">| Variable_name | Value | </span><br><span class="line">+------------------------+-------+ </span><br><span class="line">| innodb_old_blocks_time | 1000 | </span><br><span class="line">+------------------------+-------+ </span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>这个<code>innodb_old_blocks_time</code>的默认值是1000，它的单位是毫秒，也就意味着对于从磁盘上被加载到LRU链表的old区域的某个⻚来说，如果第一次和最后一次访问该⻚面的时间间隔小于1s(很明显在一次全表扫描的过程中，多次访问一个⻚面中的时间不会超过 1s)，那么该⻚是不会被加入到young区域的。<br>当然，像 <code>innodb_old_blocks_pct</code> 一样，我们也可以在服务器启动或运行时设置<code>innodb_old_blocks_time</code>的值，这里就不赘述了，你自己试试吧。<br>这里需要注意的是，如果我们把 <code>innodb_old_blocks_time</code> 的值设置为0，那么每次我们访问一个⻚面时就会把该⻚面放到young区域的头部。</p>
</li>
</ul>
<p>综上所述，正是因为将LRU链表划分为<code>young</code>和<code>old</code>区域这两个部分，又添加了<code>innodb_old_blocks_time</code>这个系统变量，才使得预读机制和全表扫描造成的缓存命中率降低的问题得到了遏制，因为用不到的预读⻚面以及全表扫描的⻚面都只会被放到old区域，而不影响young区域中的缓存⻚。</p>
<h1 id="更进一步优化LRU链表"><a href="#更进一步优化LRU链表" class="headerlink" title="更进一步优化LRU链表"></a>更进一步优化LRU链表</h1><p>LRU链表这就说完了么? 没有，早着呢…<br>对于young区域的缓存⻚来说，我们每次访问一个缓存⻚就要把它移动到LRU链表的头部，这样开销是不是太大啦，毕竟在young区域的缓存⻚都是热点数据，也就是可能被经常访问的，这样频繁的对LRU链表进行节点移动操作是不是不太好啊?<br>是的，为了解决这个问题其实我们还可以提出一些优化策略，比如只有被访问的缓存⻚位于young区域的1&#x2F;4的后边，才会被移动到LRU链表头部，这样就可以降低调整LRU链表的频率，从而提升性能(也就是说如果某个缓存⻚对应的节点在young区域的 1&#x2F;4中，再次访问该缓存⻚时也不会将其移动到LRU链表头部)。</p>
<p>Tips:<br>我们之前介绍随机预读的时候曾说，如果Buffer Pool中有某个区的13个连续⻚面就会触发随机预读，这其实是不严谨的(不幸的是MySQL文档就是这么说的[摊手])，其实还要求这13个⻚面是非常热的⻚面，所谓的非常热，指的是这些⻚面在整个young区域的头1&#x2F;4处。<br>还有没有什么别的针对LRU链表的优化措施呢? 当然有啊，你要是好好学，写篇论文，写本书都不是问题，可是这毕竟是一个介绍MySQL基础知识的文章，再说多了篇幅就受不了了，也影响大家的阅读体验，所以适可而止，想了解更多的优化知识，自己去看源码或者更多关于LRU链表的知识喽。<br>但是不论怎么优化，千万别忘了我们的初心:尽量高效的提高 Buffer Pool 的缓存命中率。</p>
<h1 id="刷新脏⻚到磁盘"><a href="#刷新脏⻚到磁盘" class="headerlink" title="刷新脏⻚到磁盘"></a>刷新脏⻚到磁盘</h1><p>后台有专⻔的线程每隔一段时间负责把脏⻚刷新到磁盘，这样可以不影响用户线程处理正常的请求。</p>
<p>主要有两种刷新路径:</p>
<ul>
<li>从<code>LRU链表</code>的<code>冷数据</code>中刷新一部分⻚面到磁盘<br>后台线程会定时从LRU链表尾部开始扫描一些⻚面，扫描的⻚面数量可以通过系统变量<code>innodb_lru_scan_depth</code>来指定，如果从里边儿发现脏⻚，会把它们刷新到磁盘。<br>这种刷新⻚面的方式被称之为<code>BUF_FLUSH_LRU</code>。</li>
<li>从<code>flush链表</code>中刷新一部分⻚面到磁盘<br>后台线程也会定时从flush链表中刷新一部分⻚面到磁盘，刷新的速率取决于当时系统是不是很繁忙。<br>这种刷新⻚面的方式 被称之为<code>BUF_FLUSH_LIST</code>。</li>
</ul>
<p>有时候后台线程刷新脏⻚的进度比较慢，导致用户线程在准备加载一个磁盘⻚到Buffer Pool时没有可用的缓存⻚，这时就会尝试看看LRU链表尾部有没有可以直接释放掉的未修改⻚面，如果没有的话会不得不将LRU链表尾部的一个脏⻚同步刷新到磁盘(和磁盘交互是很慢的，这会降低处理用户请求的速度)。这种刷新单个⻚面到磁盘中的刷新方式被称之为 <code>BUF_FLUSH_SINGLE_PAGE</code>。<br>当然，有时候系统特别繁忙时，也可能出现用户线程批量的从flush链表中刷新脏⻚的情况，很显然在处理用户请求过程中去刷新脏⻚是一种严重降低处理速度的行为(毕竟磁盘的速度满的要死)，这属于一种迫不得已的情况，不过这得放在后边唠叨redo日志的 checkpoint时说了。</p>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/16. explain详解(下)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/27/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/16.%20explain%E8%AF%A6%E8%A7%A3(%E4%B8%8B)/">16. explain详解(下)</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-11-27T14:11:31.000Z" itemprop="datePublished">2021年11月27日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/11/27/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/16.%20explain%E8%AF%A6%E8%A7%A3(%E4%B8%8B)/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        
        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/15.0 explain详解(上)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/24/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/15.0%20explain%E8%AF%A6%E8%A7%A3(%E4%B8%8A)/">15.0 explain详解(上)</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-11-24T05:02:16.000Z" itemprop="datePublished">2021年11月24日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/11/24/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/15.0%20explain%E8%AF%A6%E8%A7%A3(%E4%B8%8A)/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="尝试用Explain查看执行计划"><a href="#尝试用Explain查看执行计划" class="headerlink" title="尝试用Explain查看执行计划"></a>尝试用<code>Explain</code>查看<code>执行计划</code></h1><p>一条查询语句在经过MySQL<code>查询优化器</code>的各种<code>基于成本</code>和<code>规则</code>的优化后，会生成一个所谓的<code>执行计划</code>，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么<code>访问方法</code>来具体执行查询等等。</p>
<p>设计MySQL的大叔贴心的为我们提供了<code>EXPLAIN</code>语句来帮助我们查看某个查询语句的具体<code>执行计划</code>，本章的内容就是为了帮助大家看懂EXPLAIN语句的各个输出项都是干嘛使的，从而可以有针对性的提升我们查询语句的性能。</p>
<p>如果我们想看看某个查询的执行计划的话，可以在具体的<code>查询语句</code>前边加一个<code>EXPLAIN</code>，就像这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select 1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面输出的一大坨东⻄就是所谓的执行计划，我的任务就是带领大家看懂这一大坨东⻄里边的每个列都是干啥用的，以及在这个执行计划的辅助下，我们应该怎样改进自己的查询语句以使查询执行起来更高效。<br>其实除了以SELECT开头的查询语句，其余的 DELETE、INSERT、REPLACE以及UPDATE语句前边都可以加上EXPLAIN这个词儿，用来查看这些语句的执行计划，不过我们这里对SELECT语句更感兴趣，所以后边只会以SELECT语句为例来描述EXPLAIN语句的用法。<br>为了让大家先有一个感性的认识，我们把EXPLAIN语句输出的各个列的作用先大致罗列一下:</p>
<ul>
<li><code>id</code> : 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</li>
<li><code>select_type</code>: SELECT关键字对应的那个查询的类型 </li>
<li><code>table</code>: 表名</li>
<li><code>partitions</code>: 匹配的分区信息</li>
<li><code>type</code>: 针对单表的访问方法</li>
<li><code>possible_keys</code>: 可能用到的索引</li>
<li><code>key</code>: 实际上使用的索引</li>
<li><code>key_len</code>: 实际使用到的索引⻓度</li>
<li><code>ref</code>: 当使用索引列等值查询时，与索引列进行等值匹配的对象信息</li>
<li><code>rows</code>: 预估的需要读取的记录条数</li>
<li><code>filtered</code>: 某个表经过搜索条件过滤后剩余记录条数的百分比</li>
<li><code>Extra</code>: 一些额外的信息</li>
</ul>
</blockquote>
<p>需要注意的是，大家如果看不懂上边列的含义，那是正常的，千万不要纠结。<br>这里把它们都列出来只是为了描述一个轮廓，让大家有一个大致的印象，下边会细细道来，等会儿说完了不信你不会~<br>为了故事的顺利发展，我们还是要请出我们前边已经用了n遍的 single_table表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2,</span><br><span class="line">    key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>我们仍然假设有两个和single_table表构造一模一样的s1、s2表，而且这两个表里边儿有10000条记录，除id列外其余的列都插入随机值。<br>为了让大家有比较好的阅读体验，我们下边并不准备严格按照EXPLAIN输出列的顺序来介绍这些列分别是干嘛的，大家注意一下就好了。</p>
<h1 id="执行计划输出中的各列详解"><a href="#执行计划输出中的各列详解" class="headerlink" title="执行计划输出中的各列详解"></a>执行计划输出中的各列详解</h1><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行<code>单表访问</code>的。<br>所以设计MySQL的大叔规定 <code>EXPLAIN语句</code>输出的每条记录都对应着某个单表的<code>访问方法</code>，该条记录的<code>table列</code>代表着该表的表名。<br>所以我们看一条比较简单的查询语句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1; </span><br><span class="line">+----+-------------+-------+------------+------+- --------------+------+---------+------+------+--- -------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | </span><br><span class="line">+----+-------------+-------+------------+------+- --------------+------+---------+------+------+--- -------+-------+</span><br><span class="line">| 1  |   SIMPLE    |  s1   |    NULL    |  ALL |      NULL     | NULL|   NULL  | NULL| 9688 |  100.00  |  NULL | </span><br><span class="line">+----+-------------+-------+------------+------+- --------------+------+---------+------+------+--- -------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>这个查询语句只涉及对s1表的单表查询，所以EXPLAIN输出中只有一条记录，其中的table列的值是s1，表明这条记录是用来说明对s1表的单表访问方法的。</p>
<hr>
<p>再看一个<code>连接查询</code>的<code>执行计划</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2; </span><br><span class="line">+----+-------------+-------+------------+------+- --------------+------+---------+------+------+--- -------+---------------------------------------+ </span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra</span><br><span class="line">| +----+-------------+-------+------------+------+- --------------+------+---------+------+------+--- -------+---------------------------------------+ </span><br><span class="line">|  1 |   SIMPLE    |  s1   |    NULL    |  ALL |      NULL     | NULL|  NULL   | NULL| 9688 |  100.00  | NULL | </span><br><span class="line">|  1 |   SIMPLE    |  s2   |    NULL    |  ALL |      NULL     | NULL|  NULL   | NULL| 9954 |  100.00  | Using join buffer (Block Nested Loop) | </span><br><span class="line">+----+-------------+-------+------------+------+- --------------+------+---------+------+------+--- -------+---------------------------------------+ </span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。</p>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><p>我们写的查询语句一般都以SELECT关键字开头，比较简单的查询语句里只有一个SELECT关键字，比如:<code>SELECT * FROM s1 WHERE key1 = &#39;a&#39;;</code><br>稍微复杂一点的<code>连接查询</code>中也只有一个SELECT关键字，比如:<code>SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = &#39;a&#39;;</code></p>
<p>但是下边两种情况下, 在一条查询语句中会出现多个SELECT关键字: </p>
<ul>
<li>查询中包含子查询的情况，比如下边这个查询语句中就包含2个SELECT关键字:<br><code>SELECT * FROM s1 WHERE key1 IN (SELECT * FROM s2);</code></li>
<li>查询中包含<code>UNION语句</code>的情况 比如下边这个查询语句中也包含2个SELECT关键字:<br><code>SELECT * FROM s1 UNION SELECT * FROM s2;</code></li>
</ul>
<hr>
<p>查询语句中每出现一个SELECT关键字，设计MySQL的大叔就会为它分配一个唯一的id值。这个id值就是EXPLAIN语句的第一个列，比如下边这个查询中只有一个SELECT关键字，所以EXPLAIN的结果中也就只有一条id列为1的记录:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;; </span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys |   key    | key_len |  ref  | rows | filtered | Extra | </span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+-----+----------+-------+</span><br><span class="line">| 1  |   SIMPLE    |  s1   |   NULL     |  ref |    idx_key1   | idx_key1 |   303   | const |   8  |  100.00  | NULL  | </span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<hr>
<p>对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的<code>执行计划</code>中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2; </span><br><span class="line">+----+-------------+-------+------------+------+- --------------+------+---------+------+------+----------+------------------------------------+ </span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra</span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----+---------+-----+------+----------+---------------------------------------+ </span><br><span class="line">|  1 |   SIMPLE    |  s1   |    NULL    |  ALL |      NULL     | NULL|  NULL   | NULL| 9688 |  100.00  | NULL</span><br><span class="line">|  1 |   SIMPLE    |  s2   |    NULL    |  ALL |      NULL     | NULL|  NULL   | NULL| 9954 |  100.00  | Using join buffer (Block Nested Loop) | </span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----+---------+------+------+--- -------+-------------------------------------+ </span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到，上述连接查询中参与连接的s1和s2表分别对应一条记录，但是这两条记录对应的id值都是1。<br>这里需要大家记住的是，在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示<code>驱动表</code>，出现在后边的表表示<code>被驱动表</code>。<br>所以从上边的EXPLAIN输出中我们可以看出，查询优化器准备让s1表作为驱动表，让s2表作为被驱动表来执行查询。</p>
<hr>
<p>对于包含子查询的查询语句来说，就可能涉及多个SELECT关键字， 所以在包含子查询的查询语句的执行计划中，每个SELECT关键字都会对应一个唯一的id值，比如这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;; </span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys |   key    | key_len |  ref | rows | filtered |    Extra    | </span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-------------+ </span><br><span class="line">|  1 |   PRIMARY   |  s1   |    NULL    |  ALL |    idx_key3   |   NULL   |   NULL  | NULL | 9688 |  100.00  | Using where |</span><br><span class="line">|  2 |   SUBQUERY  |  s2   |    NULL    | index|    idx_key1   | idx_key1 |   303   | NULL | 9954 |  100.00  | Using index | </span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+---- --+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure>
<p>从输出结果中我们可以看到，s1表在外层查询中，外层查询有一个独立的SELECT关键字，所以第一条记录的id值就是1，s2表在子查询中，子查询有一个独立的SELECT关键字，所以第二条记录的id值就是2。<br>但是这里大家需要特别注意，查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。</p>
<hr>
<p>所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = &#x27;a&#x27;); </span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys |    key   | key_len |        ref        | rows | filtered | Extra</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">| 1  |    SIMPLE   |  s2   |   NULL     |  ALL |    idx_key3   |  NULL    |  NULL   |        NULL       | 9954 |  10.00   | Using where; Start temporary |</span><br><span class="line">| 1  |    SIMPLE   |  s1   |   NULL     |  ref |    idx_key1   | idx_key1 |  303    | xiaohaizi.s2.key3 |  1   |  100.00  | End temporary | </span><br><span class="line">+----+-------------+-------+------------+------+- --------------+----------+---------+------------- ------+------+----------+----------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的id值全部是1，<strong>这就表明了查询优化器将子查询转换为了连接查询</strong> 。</p>
<hr>
<p>对于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值也是没错的，不过还是有点儿特别的东⻄，比方说下边这个查询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2; </span><br><span class="line">+----+-------------+------------+------------+-- ----+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type |    table   | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | </span><br><span class="line">+----+-------------+------------+------------+------+---------------+-----+---------+-----+------+----------+-----------------+</span><br><span class="line">| 1  |   PRIMARY   |     s1     |    NULL    | ALL  |      NULL     |NULL |   NULL  | NULL| 9688 |  100.00  | NULL |</span><br><span class="line">| 2  |    UNION    |     s2     |    NULL    | ALL  |      NULL     |NULL |   NULL  | NULL| 9954 |  100.00  | NULL |</span><br><span class="line">|NULL| UNION RESULT| &lt;union1,2&gt; |    NULL    | ALL  |      NULL     |NULL |   NULL  | NULL| NULL |  NULL    | Using temporary | </span><br><span class="line">+----+-------------+------------+------------+------+---------------+-----+---------+------+-----+----------+-----------------+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>这个语句的执行计划的第三条记录是个什么⻤?  为毛id值是NULL， 而且table列⻓的也怪怪的?<br>大家别忘了UNION子句是干嘛用的，它会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢? MySQL使用的是内部的<code>临时表</code>。<br>正如上边的查询计划中所示，UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为&lt;union1, 2&gt;的临时表 (就是执行计划第三条记录的table列的名称)，id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<hr>
<p>跟UNION对比起来，<code>UNION ALL</code>就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。<br>所以在包含<code>UNION ALL</code>子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2; </span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----+---------+-----+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | </span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----+---------+------+------+---------+-------+</span><br><span class="line">| 1  |   PRIMARY   |  s1   |   NULL     |  ALL |      NULL     | NULL|  NULL   |  NULL|  9688| 100.00  |  NULL |</span><br><span class="line">| 2  |    UNION    |  s2   |   NULL     |  ALL |      NULL     | NULL|  NULL   |  NULL|  9954| 100.00  |  NULL | </span><br><span class="line">+----+-------------+-------+------------+------+---------------+-----+---------+------+------+---------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><p>通过上边的内容我们知道，一条大的查询语句里边可以包含若干个SELECT关键字，每个SELECT关键字代表着一个小的查询语句， 而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接查询)，每一张表都对应着执行计划输出中的一条记录，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。<br>设计MySQL的大叔为每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么⻆色，口说无凭，我们还是先来⻅识⻅识这个select_type都能取哪些值:</p>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/14. 基于规则的优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/21/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/14.%20%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96/">14. 基于规则的优化</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-11-21T12:31:27.000Z" itemprop="datePublished">2021年11月21日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/11/21/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/14.%20%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        
        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>



    <nav id="page-nav">

<a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
</nav>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> 最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/25/TCP/05.%E6%94%AF%E6%92%91TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%9F%B3--%E5%89%96%E6%9E%90%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/">05.支撑 TCP 协议的基石 —— 剖析首部字段</a>
          </li>
        
          <li>
            <a href="/2022/01/24/TCP/04.%E6%9D%A5%E8%87%AA%20Google%20%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%B5%8B%E8%AF%95%E7%A5%9E%E5%99%A8%20packetdrill/">04.来自 Google 的协议栈测试神器 —— packetdrill</a>
          </li>
        
          <li>
            <a href="/2022/01/23/TCP/03.TCP%E6%A6%82%E8%BF%B0%20--%20%E5%8F%AF%E9%9D%A0%E7%9A%84%E3%80%81%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%81%E5%9F%BA%E4%BA%8E%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%85%A8%E5%8F%8C%E5%B7%A5%E7%9A%84%E5%8D%8F%E8%AE%AE/">03.TCP概述 -- 可靠的、面向连接的、基于字节流、全双工的协议</a>
          </li>
        
          <li>
            <a href="/2022/01/22/TCP/02.TCP%E3%80%81IP%20%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/">02.TCP/IP 历史与分层模型</a>
          </li>
        
          <li>
            <a href="/2022/01/21/TCP/01.%E7%8E%AF%E5%A2%83/">01. 环境</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CAS/" style="font-size: 10px;">CAS</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/MySQL/" style="font-size: 20px;">MySQL</a> <a href="/tags/TCP/" style="font-size: 17.5px;">TCP</a> <a href="/tags/%E4%B8%8D%E8%A6%81-select/" style="font-size: 12.5px;">不要 select*</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> 分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">0</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a><span class="category-list-count">58</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSO/">SSO</a><span class="category-list-count">0</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">TCP 读书笔记</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">0</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">0</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> 归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022年</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年</a><span class="archive-list-count">58</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/" rel="tag">CAS</a><span class="tag-list-count">0</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">58</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8D%E8%A6%81-select/" rel="tag">不要 select*</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">0</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">0</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">网站地图</a>
        <span> | </span><a href="/atom.xml">订阅本站</a>
        <span> | </span><a href="/about/">联系博主</a>
      </p>
      
      <p>
        <span>Copyright &copy; 2024 Rymuscle.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>




<script src="/js/script.js"></script>












  



  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>
  <script src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async type="text/javascript"></script>

</body>
</html>