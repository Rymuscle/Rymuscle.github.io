<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rymuscle的技术博客</title>
  
  <subtitle>一切美好都如约而至!</subtitle>
  <link href="http://rymuscle.github.io/atom.xml" rel="self"/>
  
  <link href="http://rymuscle.github.io/"/>
  <updated>2023-11-16T08:05:43.744Z</updated>
  <id>http://rymuscle.github.io/</id>
  
  <author>
    <name>Rymuscle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis基本数据结构浅析 之 BitMap(位图)</title>
    <link href="http://rymuscle.github.io/2021/04/18/redis/04.%20basic-data-structure-sorted-BitMap/"/>
    <id>http://rymuscle.github.io/2021/04/18/redis/04.%20basic-data-structure-sorted-BitMap/</id>
    <published>2021-04-18T10:36:56.000Z</published>
    <updated>2023-11-16T08:05:43.744Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;</summary>
      
    
    
    
    <category term="redis" scheme="http://rymuscle.github.io/categories/redis/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>redis基本数据结构浅析 之 Sorted set(有序集合)</title>
    <link href="http://rymuscle.github.io/2021/04/17/redis/04.%20basic-data-structure-sorted-set/"/>
    <id>http://rymuscle.github.io/2021/04/17/redis/04.%20basic-data-structure-sorted-set/</id>
    <published>2021-04-17T06:09:51.000Z</published>
    <updated>2023-11-16T08:05:43.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;</summary>
      
    
    
    
    <category term="redis" scheme="http://rymuscle.github.io/categories/redis/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>redis基本数据结构浅析 之 set(集合)</title>
    <link href="http://rymuscle.github.io/2021/04/15/redis/03.%20basic-data-structure-set/"/>
    <id>http://rymuscle.github.io/2021/04/15/redis/03.%20basic-data-structure-set/</id>
    <published>2021-04-15T14:12:04.000Z</published>
    <updated>2023-11-16T08:05:43.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;</summary>
      
    
    
    
    <category term="redis" scheme="http://rymuscle.github.io/categories/redis/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>redis基本数据结构浅析 之 List(列表)</title>
    <link href="http://rymuscle.github.io/2021/04/14/redis/02.%20basic-data-structure-list/"/>
    <id>http://rymuscle.github.io/2021/04/14/redis/02.%20basic-data-structure-list/</id>
    <published>2021-04-14T12:43:20.000Z</published>
    <updated>2023-11-21T02:34:46.002Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的<code>list</code>底层采用的数据结构是<code>双向链表</code>(每个子元素都是String类型)，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。 获取越接近两端的元素速度越快，但通过索引访问时会比较慢。</p><blockquote><p><code>LPUSH key element [element ...]</code>： 将一个或多个值插入到列表头部<br>时间复杂度：每添加一个元素是<code>O(1)</code>，当添加 N 个元素时是 <code>O(N)</code>。</p></blockquote><blockquote><p>Lpop key [count] : 移出并获取列表的第一个元素<br>默认情况下，该命令从列表的开头弹出一个元素。当提供可选count参数时，将返回count个元素。<br>tip：count参数是从 Redis 版本 6.2.0 开始新增的。<br>时间复杂度：O(N) 其中 N 是返回的元素数，所以只返回一个元素的话，时间复杂度自然就是 O(1)。<br>#</p></blockquote><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol><li>Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。</li><li>List的另一个应用就是消息队列， 可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。</li></ol><p>比如微博： 在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start&#x2F;count参数超出了这个范围的时候，才需要去访问数据库。我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis的&lt;code&gt;list&lt;/code&gt;底层采用的数据结构是&lt;code&gt;双向链表&lt;/code&gt;(每个子元素都是String类型)，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。 获取越接近两端的元素速度越快</summary>
      
    
    
    
    <category term="redis" scheme="http://rymuscle.github.io/categories/redis/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>redis基本数据结构浅析 之 Hash表</title>
    <link href="http://rymuscle.github.io/2021/04/11/redis/01.%20basic-data-structure-hash/"/>
    <id>http://rymuscle.github.io/2021/04/11/redis/01.%20basic-data-structure-hash/</id>
    <published>2021-04-11T11:43:20.000Z</published>
    <updated>2023-11-17T05:13:20.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="O-1-时间复杂度的操作"><a href="#O-1-时间复杂度的操作" class="headerlink" title="O(1)时间复杂度的操作"></a>O(1)时间复杂度的操作</h3><ol><li>了解数据结构的都知道，<code>Hash表</code>这种数据结构最基本的 增<code>HSET</code>、删<code>HDEL</code>、改<code>HSET``HSETNX</code>、查<code>HGET</code>、<code>HEXISTS</code> 操作时间复杂度都是<code>O(1)</code>；</li><li><code>HLEN</code> 获取哈希中的字段数  (todo: redis估计也是在散列表发生变化时，对长度额外做了记录)</li><li>留意：<code>HSET</code>已经具备了<code>HMSET</code>同时为指定的一个hash key设置多个field&#x2F;value的功能，所以从 Redis 版本 4.0.0 开始，此命令被视为已弃用。(参考<a href="https://www.tkcnn.com/redis/commands/Hmset.html">redis手册</a>)</li></ol><h3 id="O-n-时间复杂度的操作"><a href="#O-n-时间复杂度的操作" class="headerlink" title="O(n)时间复杂度的操作"></a>O(n)时间复杂度的操作</h3><ol><li>不过，redis中 <code>HSET</code>、<code>HDEL</code> 都支持同时设置或者删除多个field, 此时的时间复杂度就是 <code>O(n)</code> 了。</li><li><code>HGETALL key</code> 获取哈希表中指定key 中的所有字段和值</li><li><code>HVALS key</code> 获取哈希表中指定key 中的所有值</li><li><code>HKEYS key</code> 获取哈希表中指定key 中的所有字段</li></ol><span style="color:#6A9113;font-weight:600">lant: 上面的操作虽然都是 O(n) 级的时间复杂度，但其实这些操作在操作Hash表时，都是针对指定 key 进行操作的。<br/>你的每个key中的 field/value 对儿会很多么?<br/>所以，效率下降应该不是特别严重，感觉也还算是常量级的时间复杂度吧!</span><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>特别适合存储对象信息</p><blockquote><p><strong>比如存储 用户信息 这种map信息:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;hset jm:user:1 name austin age 25 address guangzhou </span><br><span class="line">&gt;hset jm:user:2 name austin age 25 address guangzhou</span><br></pre></td></tr></table></figure><p><span style="color:red">如果用普通的 key&#x2F;value 结构来存储，主要有下面两种存储方式:</span><br>用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，key部分的用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;set user:1:name austin</span><br><span class="line">&gt;set user:1:age 25</span><br><span class="line">&gt;set user:1:address guangzhou</span><br></pre></td></tr></table></figure><p>将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化&#x2F;反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;set user:1 &#123;&quot;name&quot;:&quot;austin&quot;,&quot;age&quot;:&quot;25&quot;,&quot;address&quot;:&quot;guangzhou&quot;&#125; </span><br><span class="line">&gt;set user:1 &#123;&quot;name&quot;:&quot;austin&quot;,&quot;age&quot;:&quot;25&quot;,&quot;address&quot;:&quot;guangzhou&quot;&#125;</span><br><span class="line">&gt;set user:1 &#123;&quot;name&quot;:&quot;austin&quot;,&quot;age&quot;:&quot;25&quot;,&quot;address&quot;:&quot;guangzhou&quot;&#125;</span><br></pre></td></tr></table></figure></blockquote><br/><blockquote><p><strong>再比如存储 帖子 点赞数,评论数,点击数 信息</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;hset article:1 star 9 comment 3 click 21</span><br><span class="line">&gt;hset article:2 star 2 comment 0 click 7</span><br><span class="line">&gt;hset article:3 star 6 comment 4 click 19</span><br></pre></td></tr></table></figure></blockquote><br/><blockquote><p><strong>甚至存储 订单信息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;hset order:692343390123213 amount 218.5 orderTime 2021-04-11 19:20:20 productId 1232 productName 黑人牙膏 ...</span><br><span class="line">&gt;hset order:128043390155801 amount 18.9 orderTime 2021-04-11 13:11:09 productId 345 productName 黑人牙刷 ...</span><br><span class="line">&gt;hset order:752344450123149 amount 21.35 orderTime 2021-04-11 21:29:56 productId 124 productName 短袖 ...</span><br></pre></td></tr></table></figure></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.tkcnn.com/redis/commands/Hset.html">Redis手册</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;O-1-时间复杂度的操作&quot;&gt;&lt;a href=&quot;#O-1-时间复杂度的操作&quot; class=&quot;headerlink&quot; title=&quot;O(1)时间复杂度的操作&quot;&gt;&lt;/a&gt;O(1)时间复杂度的操作&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;了解数据结构的都知道，&lt;code&gt;Hash表&lt;/</summary>
      
    
    
    
    <category term="redis" scheme="http://rymuscle.github.io/categories/redis/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」图的遍历 (TODO)</title>
    <link href="http://rymuscle.github.io/2020/11/11/data-structure-algorithm/12-4.map/"/>
    <id>http://rymuscle.github.io/2020/11/11/data-structure-algorithm/12-4.map/</id>
    <published>2020-11-11T07:21:16.000Z</published>
    <updated>2023-11-21T05:22:08.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>树代表的是“一对多”的关系，而图则具有更高的自由度，可以表示任意的“多对多”关系。<br>因此，我们可以把树看作是图的一种特例。显然，树的遍历操作也是图的遍历操作的一种特例。</p></blockquote><br/><blockquote><p>图和树都需要应用搜索算法来实现遍历操作。<br>图的遍历方式可分为两种：「广度优先遍历 breadth-first traversal」和「深度优先遍历 depth-first traversal」。<br>它们也常被称为「广度优先搜索 breadth-first search」和「深度优先搜索 depth-first search」，简称 BFS 和 DFS 。</p></blockquote><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p><code>广度优先遍历</code>是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张。<br>如下图所示，从左上角顶点出发，先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻接顶点，以此类推，直至所有顶点访问完毕。</p><blockquote><img src="/images/data-structure-algorithm/graph_bfs.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></blockquote><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><blockquote><p>BFS 通常借助<code>队列</code>来实现。队列具有“先入先出”的性质，这与 BFS 的“由近及远”的思想异曲同工:</p><ol><li>将遍历起始顶点 startVet 加入队列，并开启循环。</li><li>在循环的每轮迭代中，弹出队首顶点并记录访问，然后将该顶点的所有邻接顶点加入到队列尾部。 </li><li>循环步骤 2. ，直到所有顶点被访问完成后结束。</li></ol><p>为了防止重复遍历顶点，我们需要借助一个哈希表 visited 来记录哪些节点已被访问。</p></blockquote><blockquote><div style="display:flex;"><img src="/images/data-structure-algorithm/graph_bfs_step1.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_bfs_step2.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_bfs_step3.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/graph_bfs_step4.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_bfs_step5.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_bfs_step6.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/graph_bfs_step7.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_bfs_step8.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_bfs_step9.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/graph_bfs_step10.png" width="275px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_bfs_step11.png" width="275px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div></blockquote><br/><blockquote><p>广度优先遍历的序列是否唯一？<br>不唯一。广度优先遍历只要求按“由近及远”的顺序遍历，而多个相同距离的顶点的遍历顺序是允许被任意打乱的。以图 9-10 为例，顶点 (1)、(3) 的访问顺序可以交换、顶点 (2)、(4)、(6) 的访问顺序也可以任意交换。</p></blockquote><p>TODO 代码</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度： 所有顶点都会入队并出队一次，使用 (O(|V|)) 时间；在遍历邻接顶点的过程中，由于是无向图，因此所有边都会被访问 (2) 次，使用 (O(2|E|)) 时间；总体使用 (O(|V| + |E|)) 时间。</p><p>空间复杂度： 列表 res ，哈希表 visited ，队列 que 中的顶点数量最多为 (|V|) ，使用 (O(|V|)) 空间。</p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><blockquote><p>深度优先遍历是一种优先走到底、无路可走再回头的遍历方式。<br>如下图所示，从左上角顶点出发，访问当前顶点的某个邻接顶点，直到走到尽头时返回，再继续走到尽头并返回，以此类推，直至所有顶点遍历完成。<br><img src="/images/data-structure-algorithm/graph_dfs.png" width="450px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><blockquote><p>这种“走到尽头再返回”的算法范式通常基于递归来实现。与广度优先遍历类似，在深度优先遍历中我们也需要借助一个哈希表 visited 来记录已被访问的顶点，以避免重复访问顶点。<br>深度优先遍历的算法流程如下图</p><ul><li>直虚线代表向下递推，表示开启了一个新的递归方法来访问新顶点。</li><li>曲虚线代表向上回溯，表示此递归方法已经返回，回溯到了开启此递归方法的位置。<br>为了加深理解，建议将图示与代码结合起来，在脑中（或者用笔画下来）模拟整个 DFS 过程，包括每个递归方法何时开启、何时返回。</li></ul></blockquote><blockquote><div style="display:flex;"><img src="/images/data-structure-algorithm/graph_dfs_step1.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_dfs_step2.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_dfs_step3.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/graph_dfs_step4.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_dfs_step5.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_dfs_step6.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/graph_dfs_step7.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_dfs_step8.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_dfs_step9.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/graph_dfs_step10.png" width="275px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/graph_dfs_step11.png" width="275px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div></blockquote><blockquote><p>深度优先遍历的序列是否唯一？<br>与广度优先遍历类似，深度优先遍历序列的顺序也不是唯一的。给定某顶点，先往哪个方向探索都可以，即邻接顶点的顺序可以任意打乱，都是深度优先遍历。<br>以树的遍历为例，“根 (\rightarrow) 左 (\rightarrow) 右”、“左 (\rightarrow) 根 (\rightarrow) 右”、“左 (\rightarrow) 右 (\rightarrow) 根”分别对应前序、中序、后序遍历，它们展示了三种不同的遍历优先级，然而这三者都属于深度优先遍历。</p></blockquote><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度： 所有顶点都会被访问 (1) 次，使用 (O(|V|)) 时间；所有边都会被访问 (2) 次，使用 (O(2|E|)) 时间；总体使用 (O(|V| + |E|)) 时间。<br>空间复杂度： 列表 res ，哈希表 visited 顶点数量最多为 (|V|) ，递归深度最大为 (|V|) ，因此使用 (O(|V|)) 空间。</p><p>TODO 代码</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="hhttps://www.hello-algo.com/chapter_graph/graph_traversal/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;树代表的是“一对多”的关系，而图则具有更高的自由度，可以表示任意的“多对多”关系。&lt;br&gt;因此，我们可以把树看作是</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」图的基础操作 (TODO)</title>
    <link href="http://rymuscle.github.io/2020/11/09/data-structure-algorithm/12-3.map/"/>
    <id>http://rymuscle.github.io/2020/11/09/data-structure-algorithm/12-3.map/</id>
    <published>2020-11-09T15:53:07.000Z</published>
    <updated>2023-11-21T03:11:35.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>图的基础操作可分为对<code>边</code>的操作和对<code>顶点</code>的操作。在“邻接矩阵”和“邻接表”两种表示方法下，实现方式有所不同。</p><h3 id="基于邻接矩阵存储"><a href="#基于邻接矩阵存储" class="headerlink" title="基于邻接矩阵存储"></a>基于邻接矩阵存储</h3><blockquote><p>给定一个顶点数量为 n 的<code>无向图</code>，其各种操作如下：</p><ul><li>初始化：传入 n 个顶点，初始化长度为 n 的顶点列表 vertices ，使用 O(n)时间；初始化 n*n 大小的邻接矩阵 adjMat ，使用 $O(n^2)$ 时间。</li><li>添加或删除边：直接在邻接矩阵中修改指定的边即可，使用 O(1) 时间。而由于是无向图，因此需要同时更新两个方向的边。</li><li>添加顶点：在邻接矩阵的尾部<strong>添加一行一列</strong>，并全部填 0 即可，使用 O(n) 时间。</li><li>删除顶点：在邻接矩阵中删除一行一列。当删除首行首列时达到最差情况，需要将 $(n-1)^2$ 个元素“向左上移动”，从而使用 $O(n^2)$ 时间。</li></ul></blockquote><blockquote><div style="display:flex;"><img src="/images/data-structure-algorithm/adjacency_matrix_initialization.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/adjacency_matrix_add_edge.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/adjacency_matrix_remove_edge.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/adjacency_matrix_add_vertex.png" width="275px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/adjacency_matrix_remove_vertex.png" width="275px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div></blockquote><p>代码实现可去参考本节末尾的文献</p><h3 id="基于邻接表存储"><a href="#基于邻接表存储" class="headerlink" title="基于邻接表存储"></a>基于邻接表存储</h3><blockquote><p>设无向图的顶点总数为n、边总数为m，则可根据下图所示的方法实现各种操作<br>初始化：在邻接表中创建 n 个顶点和 2m 条边，使用 O(n+m) 时间。<br>添加边：在顶点对应链表的末尾添加边即可，使用 O(1) 时间。因为是无向图，所以需要同时添加两个方向的边。<br>删除边：在顶点对应链表中查找并删除指定边，使用 O(m) 时间。在无向图中，需要同时删除两个方向的边。<br>添加顶点：在邻接表中添加一个链表，并将新增顶点作为链表头节点，使用 O(1) 时间。<br>删除顶点：需遍历整个邻接表，删除包含指定顶点的所有边，使用 O(n+m) 时间。</p></blockquote><blockquote><div style="display:flex;"><img src="/images/data-structure-algorithm/adjacency_list_initialization.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/adjacency_list_add_edge.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/adjacency_list_remove_edge.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/adjacency_list_add_vertex.png" width="275px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/adjacency_list_remove_vertex.png" width="275px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_graph/graph/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;图的基础操作可分为对&lt;code&gt;边&lt;/code&gt;的操作和对&lt;code&gt;顶点&lt;/code&gt;的操作。在“邻接矩阵”和“邻接表”两种表示方法下，实</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」图 的存储</title>
    <link href="http://rymuscle.github.io/2020/11/09/data-structure-algorithm/12-2.map/"/>
    <id>http://rymuscle.github.io/2020/11/09/data-structure-algorithm/12-2.map/</id>
    <published>2020-11-09T14:49:32.000Z</published>
    <updated>2023-11-21T01:57:39.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>在前面掌握了图的概念之后，我们今天聚焦在 <code>图存储</code> 这一方面，看下如何在<strong>内存中</strong>存储图这种数据结构。<br>实际上，涉及图的算法有很多，也非常复杂，比如 <code>图的搜索</code>、<code>最短路径</code>、<code>最小生成树</code>、<code>二分图</code>等等。 后面会分好几章节来依次讲解图相关的算法。</p></blockquote><h3 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h3><blockquote><p>图最直观的一种存储方法就是 <code>邻接矩阵</code>（Adjacency Matrix）。<code>邻接矩阵</code>的底层依赖一个<code>二维数组</code>。</p><ul><li>对于<code>无向图</code>来说，如果顶点 i 与顶点 j 之间有边，我们就将 <code>A[i][j]</code> 和 <code>A[j][i]</code> 标记为 1；</li><li>对于<code>有向图</code>来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 <code>A[i][j]</code> 标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 <code>A[j][i]</code> 标记为 1。</li><li>对于<code>带权图</code>，数组中就存储相应的权重。<img src="/images/data-structure-algorithm/WX20231121-092751@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></li></ul></blockquote><br/><blockquote><p>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。为什么这么说呢？</p><ul><li>对于<code>无向图</code>来说，如果 A[i][j] 等于 1，那 A[j][i] 也肯定等于 1。实际上，我们只需要存储一个就可以了。<span style="color:Red;font-weight:600;">也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了</span>。</li><li>还有，如果我们存储的是 <code>稀疏图</code>（Sparse Matrix），也就是说，<span style="color:Red;font-weight:600;">顶点很多，但每个顶点的边并不多</span>，那邻接矩阵的存储方法就更加浪费空间了。<br>比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。<br>如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</li></ul></blockquote><br/><blockquote><ul><li>但这也并不是说，邻接矩阵的存储方法就完全没有优点。<br>首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。<br>其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个Floyd-Warshall 算法，就是利用矩阵循环相乘若干次得到结果。</li></ul></blockquote><h3 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h3><blockquote><p>针对上面<code>邻接矩阵</code>比较浪费内存空间的问题，我们来看另外一种图的存储方法，<code>邻接表</code>（Adjacency List）。 下面是一张邻接表的图，你可以先看下<br><img src="/images/data-structure-algorithm/WX20231121-093652@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote><blockquote><p>乍一看，邻接表是不是有点像散列表？<br>每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。<br>另外需要说明的是，图中画的是一个<code>有向图</code>的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。<br>对于<code>无向图</code>来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点，你可以自己画下。</p></blockquote><br/><blockquote><p>还记得我们之前讲过的时间、空间复杂度互换的设计思想吗？<br><code>邻接矩阵</code>存储起来比较浪费空间，但是使用起来比较节省时间。<br>相反，<code>邻接表</code>存储起来比较节省空间，但是使用起来就比较耗时间。<br>就像图中的例子，如果我们要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。<br>而且，我们前面也讲过，链表的存储方式对缓存不友好。所以，比起<code>邻接矩阵</code>的存储方式，在<code>邻接表</code>中查询两个顶点之间的关系就没那么高效了。<br>在<code>散列表</code>那几节里，我讲到，在基于链表法解决冲突的散列表中，如果链过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构，比如<code>平衡二叉查找树</code>等。<br>我们刚刚也讲到，邻接表长得很像散列。所以，我们也可以将<code>邻接表</code>同<code>散列表</code>一样进行“改进升级”。 比如将<code>邻接表</code>中的<code>链表</code>改成<code>平衡二叉查找树</code>。 实际开发中，我们可以选择用<code>红黑树</code>。 这样，我们就可以更加快速地查找两个顶点之间是否存在边了。<br>当然，这里的二叉查找树可以换成其他动态数据结构，比如<code>跳表</code>、<code>散列表</code>等。<br>除此之外，我们还可以将链表改成<code>有序动态数组</code>，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。</p></blockquote><h3 id="精选留言"><a href="#精选留言" class="headerlink" title="精选留言"></a>精选留言</h3><img src="/images/data-structure-algorithm/WX20231121-094703@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/WX20231121-094454@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《数据结构与算法之美》王争</li><li><a href="https://www.hello-algo.com/chapter_graph/graph/">hello-algo</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在前面掌握了图的概念之后，我们今天聚焦在 &lt;code&gt;图存储&lt;/code&gt; 这一方面，看下如何在&lt;strong&gt;内</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」图</title>
    <link href="http://rymuscle.github.io/2020/11/09/data-structure-algorithm/12-1.map/"/>
    <id>http://rymuscle.github.io/2020/11/09/data-structure-algorithm/12-1.map/</id>
    <published>2020-11-09T14:01:12.000Z</published>
    <updated>2023-11-21T02:04:28.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>微博、微信、QQ 这些社交软件你肯定都玩过。 在微博中，两个人可以互相关注；在微信中，两个人可以互加好友。<br>那你知道，如何存储微博、微信等这些社交网络的好友关系吗？ 这就要用到我们今天要讲的这种数据结构：<code>图</code>。</p><p>实际上，涉及图的算法有很多，也非常复杂，比如 <code>图的搜索</code>、<code>最短路径</code>、<code>最小生成树</code>、<code>二分图</code>等等。<br>我们今天聚焦在 <code>图存储</code> 这一方面，后面会分好几节来依次讲解图相关的算法。</p></blockquote><h3 id="认识-图-无向"><a href="#认识-图-无向" class="headerlink" title="认识 图(无向)"></a>认识 图(无向)</h3><blockquote><p>前面已经学过了<code>树</code>这种<code>非线性数据结构</code>，今天我们要讲另一种<code>非线性数据结构</code> <code>图(Graph)</code>。 和<code>树</code>比起来，这是一种更加复杂的结构。</p></blockquote><h4 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h4><blockquote><p>我们知道，<code>树</code>中的元素我们称为<code>节点</code>，<code>图</code>中的元素我们就叫作<code>顶点</code>（vertex）。</p></blockquote><h4 id="边"><a href="#边" class="headerlink" title="边"></a>边</h4><blockquote><p>从下图可以看出，图中的一个<code>顶点</code>可以与任意其他顶点建立连接关系。我们把这种建立的关系叫作<code>边</code>（edge）。<br><img src="/images/data-structure-algorithm/WX20231121-085828@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote><h4 id="度"><a href="#度" class="headerlink" title="度"></a>度</h4><blockquote><p>我们生活中就有很多符合图这种结构的例子。比如，开篇问题中讲到的社交网络，就是一个非常典型的图结构。<br>我们就拿微信举例子吧。我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫作顶点的<code>度（degree）</code>，就是跟顶点相连接的边的条数。</p></blockquote><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><blockquote><p>实际上，微博的社交关系跟微信还有点不一样，或者说更加复杂一点。<br>微博允许单向关注，也就是说，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。那我们如何用图来表示这种单向的社交关系呢？</p></blockquote><blockquote><p>我们可以把刚刚讲的图结构稍微改造一下，引入边的“方向”的概念。<br>如果用户 A 关注了用户 B，我们就在图中画一条从 A 到 B 的带箭头的边，来表示边的方向。如果用户 A 和用户 B 互相关注了，那我们就画一条从 A 指向 B 的边，再画一条从 B指向 A 的边。我们把这种边有方向的图叫作“有向图”。以此类推，我们把边没有方向的图就叫作“无向图”。<br><img src="/images/data-structure-algorithm/WX20231121-090405@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote><h4 id="出度、入度"><a href="#出度、入度" class="headerlink" title="出度、入度"></a>出度、入度</h4><blockquote><p>我们刚刚讲过，无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，我们把度分为<code>入度</code>（In-degree）和 <code>出度</code>（Out-degree）。<br>顶点的入度，表示有多少条边指向这个顶点；<br>顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。<br>对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p></blockquote><h3 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h3><blockquote><p>前面讲到了微信、微博、无向图、有向图，现在我们再来看另一种社交软件：QQ。 QQ 中的社交关系要更复杂的一点。不知道你有没有留意过 QQ 亲密度这样一个功能。<br>QQ不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。 如何在图中记录这种好友关系的亲密度呢？<br>这里就要用到另一种图，<code>带权图</code>（weighted graph）。在带权图中，每条边都有一个权重 （weight），我们可以通过这个权重来表示 QQ 好友间的亲密度。<br><img src="/images/data-structure-algorithm/WX20231121-091103@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于图的概念比较多，今天也只是介绍了几个常用的，理解起来都不复杂。掌握了图的概念之后，我们再来看下，如何在内存中存储图这种数据结构呢？</p><h3 id="图常见应用"><a href="#图常见应用" class="headerlink" title="图常见应用"></a>图常见应用</h3><p>如下表所示，许多现实系统都可以用图来建模，相应的问题也可以约化为图计算问题。</p><table><thead><tr><th align="center"></th><th align="center">顶点</th><th align="center">边</th><th align="center">图计算问题</th></tr></thead><tbody><tr><td align="center">社交网络</td><td align="center">用户</td><td align="center">好友关系</td><td align="center">潜在好友推荐</td></tr><tr><td align="center">地铁线路</td><td align="center">站点</td><td align="center">站点间的连通性</td><td align="center">最短路线推荐</td></tr><tr><td align="center">太阳系</td><td align="center">星体</td><td align="center">星体间的万有引力作用</td><td align="center">行星轨迹计算</td></tr></tbody></table><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《数据结构与算法之美》王争</li><li><a href="https://www.hello-algo.com/chapter_graph/graph/">hello-algo</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;微博、微信、QQ 这些社交软件你肯定都玩过。 在微博中，两个人可以互相关注；在微信中，两个人可以互加好友。&lt;br&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」堆 的应用 -- TopK问题 (TODO)</title>
    <link href="http://rymuscle.github.io/2020/11/04/data-structure-algorithm/11-4.heap-TopK/"/>
    <id>http://rymuscle.github.io/2020/11/04/data-structure-algorithm/11-4.heap-TopK/</id>
    <published>2020-11-04T12:11:32.000Z</published>
    <updated>2023-11-20T03:12:43.419Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长度为 n 的无序数组 nums ，请返回数组中前 k 大的元素。</p><p>对于该问题，我们先介绍两种思路比较直接的解法，再介绍效率更高的堆解法</p><h3 id="方法一：遍历"><a href="#方法一：遍历" class="headerlink" title="方法一：遍历"></a>方法一：遍历</h3><blockquote><p>如下图所示，进行k轮遍历，分别在每轮中提取第 1、2、……、k大的元素，时间复杂度为 O(kn)。<br><img src="/images/data-structure-algorithm/top_k_traversal.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br><span style="color:red">此方法只适用于 k远小于n 的情况，因为当 k 与 n 比较接近时，其时间复杂度趋向于 O(n^2)，非常耗时。（因为 当 k&#x3D;n 时，我们可以得到完整的有序序列，此时等价于“选择排序”算法。）</span><br><br/></p></blockquote><h3 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h3><blockquote><p>如下图所示，我们可以先对数组 nums 进行排序，再返回最右边的 k 个元素，时间复杂度为 O(n logn)。<br>显然，该方法“超额”完成任务了，因为我们只需要找出最大的 k 个元素即可，而不需要排序其他元素。<br><img src="/images/data-structure-algorithm/top_k_sorting.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote><h3 id="高效解决Top-K问题-堆"><a href="#高效解决Top-K问题-堆" class="headerlink" title="高效解决Top-K问题 - - 堆"></a>高效解决Top-K问题 - - 堆</h3><p>我们可以基于堆更加高效地解决 Top-K 问题，流程如下：<br>*初始化一个小顶堆，其堆顶元素最小。<br>*先将数组的前 k 个元素依次入堆。<br>*从第 k+1 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。<br>*遍历完成后，堆中保存的就是最大的 k 个元素。</p><blockquote><div style="display:flex;"><img src="/images/data-structure-algorithm/top_k_heap_step1.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/top_k_heap_step2.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/top_k_heap_step3.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/top_k_heap_step4.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/top_k_heap_step5.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/top_k_heap_step6.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/top_k_heap_step7.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/top_k_heap_step8.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/top_k_heap_step9.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div></blockquote><p>总共执行了 n 轮入堆和出堆，堆的最大长度为 k，因此时间复杂度为 <code>O(nlogk)</code>。该方法的效率很高，当 k 较小时，时间复杂度趋向 <code>O(n)</code>；当<br>较大时，时间复杂度不会超过 <code>O(nlogn)</code>。</p><p>另外，该方法适用于<strong>动态数据流</strong>的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现最大 k 个元素的动态更新。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_heap/top_k/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个长度为 n 的无序数组 nums ，请返回数组中前 k 大的元素。&lt;/p&gt;
&lt;p&gt;对于该问题，我们先介绍两种思路比较直接的解法，再介绍效率更高的堆解法&lt;/p&gt;
&lt;h3 id=&quot;方法一：遍历&quot;&gt;&lt;a href=&quot;#方法一：遍历&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」建堆 从 O(nlogn) 到 O(n) 🐂🐂🐂</title>
    <link href="http://rymuscle.github.io/2020/11/03/data-structure-algorithm/11-3.heap/"/>
    <id>http://rymuscle.github.io/2020/11/03/data-structure-algorithm/11-3.heap/</id>
    <published>2020-11-03T14:07:39.000Z</published>
    <updated>2023-11-17T08:56:00.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方式一-逐个元素执行-入堆-操作"><a href="#方式一-逐个元素执行-入堆-操作" class="headerlink" title="方式一: 逐个元素执行 入堆 操作"></a>方式一: 逐个元素执行 <code>入堆</code> 操作</h3><ul><li>首先创建一个空堆，然后遍历数组，依次对每个元素执行“入堆操作”，即先将元素添加至堆的尾部，再对该元素执行<span style="color:orange;font-weight:600;">“从底至顶”堆化。</span></li><li>每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进<code>二叉树</code>的，因此<code>堆</code>是 <code>自上而下</code> 地构建的。</li><li>设元素数量为 n ，每个元素的入堆操作使用 <code>O(log n)</code> 时间，因此该建堆方法的时间复杂度为 <code>O(log n)</code>。</li></ul><h3 id="方式二-通过遍历堆化实现"><a href="#方式二-通过遍历堆化实现" class="headerlink" title="方式二: 通过遍历堆化实现"></a>方式二: 通过遍历堆化实现</h3><p>第一种建堆思路的处理过程是从前往后遍历数组数据，并且每个数据插入堆中时，都是<code>从下往上堆化</code>。<br>实际上，我们可以用一种更为高效的建堆方法(从后往前遍历数组，并且每个数据都是<code>从上往下堆化</code>)：</p><blockquote><img src="/images/data-structure-algorithm/WX20231117-161901@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>因为叶子节点往下堆化只能自己跟自己比较，不需要堆化，所以我们直接从第一个非叶子节点开始，依次堆化就行了。<span style="color:#6A9113;font-weight:600;">因此在开始倒序遍历数组时，要从下标为 n/2 开始往前遍历，因为只有 下标从 n/2 到 1 的数据才需要进行堆化，而下标从 n/2 + 1 到 n 的节点是叶子节点，不需要堆化</span>。<span style="color:orange;font-weight:600;">实际上，对于完全二叉树来说，下标从 n/2 到 n 的节点都是叶子节点。</span></blockquote><span id="more"></span><br/><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>这里主要是针对第二种建堆方法进行分析。</p><p>假设完全二叉树的节点数量为 n，则叶节点数量为 (n+1)&#x2F;2，其中 为向下整除。因此需要堆化的节点数量为 (n-1)&#x2F;2。<br>在从顶至底堆化的过程中，每个节点最多堆化到叶节点，因此最大迭代次数为二叉树高度 logn。<br>将上述两者相乘，可得到建堆过程的时间复杂度为 O(logn)。</p><p><strong>但这个估算结果并不准确，因为我们没有考虑到二叉树底层节点数量远多于顶层节点的性质（lant：越往下，节点越多，一棵完美的二叉树其叶节点就能占一半数量）。</strong></p><blockquote><p>为了减小计算难度，假设给定一个节点数量为 n，高度为 h 的“完美二叉树”，该假设不会影响计算结果的正确性。<br><img src="/images/data-structure-algorithm/heapify_operations_count.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br><img src="/images/data-structure-algorithm/WX20231117-165116@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote><p><span style="color:#6A9113;font-weight:600;">其时间复杂度最终为 O(n), 非常高效。</span>   🐂！</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_heap/build_heap/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;方式一-逐个元素执行-入堆-操作&quot;&gt;&lt;a href=&quot;#方式一-逐个元素执行-入堆-操作&quot; class=&quot;headerlink&quot; title=&quot;方式一: 逐个元素执行 入堆 操作&quot;&gt;&lt;/a&gt;方式一: 逐个元素执行 &lt;code&gt;入堆&lt;/code&gt; 操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;首先创建一个空堆，然后遍历数组，依次对每个元素执行“入堆操作”，即先将元素添加至堆的尾部，再对该元素执行&lt;span style=&quot;color:orange;font-weight:600;&quot;&gt;“从底至顶”堆化。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进&lt;code&gt;二叉树&lt;/code&gt;的，因此&lt;code&gt;堆&lt;/code&gt;是 &lt;code&gt;自上而下&lt;/code&gt; 地构建的。&lt;/li&gt;
&lt;li&gt;设元素数量为 n ，每个元素的入堆操作使用 &lt;code&gt;O(log n)&lt;/code&gt; 时间，因此该建堆方法的时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;方式二-通过遍历堆化实现&quot;&gt;&lt;a href=&quot;#方式二-通过遍历堆化实现&quot; class=&quot;headerlink&quot; title=&quot;方式二: 通过遍历堆化实现&quot;&gt;&lt;/a&gt;方式二: 通过遍历堆化实现&lt;/h3&gt;&lt;p&gt;第一种建堆思路的处理过程是从前往后遍历数组数据，并且每个数据插入堆中时，都是&lt;code&gt;从下往上堆化&lt;/code&gt;。&lt;br&gt;实际上，我们可以用一种更为高效的建堆方法(从后往前遍历数组，并且每个数据都是&lt;code&gt;从上往下堆化&lt;/code&gt;)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;img src=&quot;/images/data-structure-algorithm/WX20231117-161901@2x.png&quot; width=&quot;350px&quot; style=&quot;margin-left:0px;border: 1px solid #ccc;border-radius: 5px;&quot;/&gt;
因为叶子节点往下堆化只能自己跟自己比较，不需要堆化，所以我们直接从第一个非叶子节点开始，依次堆化就行了。
&lt;span style=&quot;color:#6A9113;font-weight:600;&quot;&gt;因此在开始倒序遍历数组时，要从下标为 n/2 开始往前遍历，因为只有 下标从 n/2 到 1 的数据才需要进行堆化，而下标从 n/2 + 1 到 n 的节点是叶子节点，不需要堆化&lt;/span&gt;。
&lt;span style=&quot;color:orange;font-weight:600;&quot;&gt;实际上，对于完全二叉树来说，下标从 n/2 到 n 的节点都是叶子节点。&lt;/span&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」堆 基本操作</title>
    <link href="http://rymuscle.github.io/2020/11/03/data-structure-algorithm/11-2.heap/"/>
    <id>http://rymuscle.github.io/2020/11/03/data-structure-algorithm/11-2.heap/</id>
    <published>2020-11-03T11:43:20.000Z</published>
    <updated>2023-11-17T08:54:28.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="建堆-暂无基础-后面再说"><a href="#建堆-暂无基础-后面再说" class="headerlink" title="建堆 - 暂无基础 后面再说"></a>建堆 - 暂无基础 后面再说</h3><p>之前已经了解 <code>堆</code> 这种数据结构的底层采用是 <code>数组</code> 这种最基本数据结构进行存储的(即 物理上是<code>顺序存储</code>)。<br>现在的问题是，假如给了我们一组数据，我们如何使用这些元素在<strong>逻辑上</strong>构建出一个 <code>堆</code> 呢？<br>毕竟要讲对某个数据结构的操作效率，就得写代码去操作这个数据结构，所以我们得先构造出这个数据结构才行啊 😝</p><p>不过，建堆操作比较特殊，堆的建造过程需要我们先了解它的一些基本的核心操作，所以，我们先假设有了一个堆，然后先看它的一些基本操作，之后再来看如何建堆。</p><h3 id="访问堆顶元素"><a href="#访问堆顶元素" class="headerlink" title="访问堆顶元素"></a>访问堆顶元素</h3><p>堆顶元素即为二叉树的根节点，也就是数组的首个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 访问堆顶元素 */</span><br><span class="line">int peek() &#123;</span><br><span class="line">    return maxHeap.get(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><br/><h3 id="元素入堆-heapify-堆化操作"><a href="#元素入堆-heapify-堆化操作" class="headerlink" title="元素入堆 - -  heapify 堆化操作"></a>元素入堆 - -  <span style="color:orange">heapify 堆化操作</span></h3><p>我们首先将元素添加到堆底。 之后，<span style="color:red;">由于元素值可能大于堆中其他元素，堆的成立条件可能会被破坏</span>。因此，需要修复从插入节点到根节点的路径上的各个节点，这个操作被称为<span style="color:orange;font-weight:600;">「堆化 heapify」</span>。</p><p>考虑从入堆节点开始，从底至顶执行堆化。如下图所示，我们比较插入节点与其父节点的值，如果插入节点更大，则将它们交换。然后继续执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无须交换的节点时结束。</p><div style="display:flex;"><img src="/images/data-structure-algorithm/heap_push_step1.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_push_step2.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_push_step3.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/heap_push_step4.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_push_step5.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_push_step6.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/heap_push_step7.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_push_step8.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_push_step9.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><p><strong>设节点总数为n，则树的高度为<code>log(n)</code>。由此可知，堆化操作的循环轮数最多为<code>O(logn)</code>，元素入堆操作的时间复杂度为<code>O(logn)</code>。</strong><br>代码参考<a href="https://www.hello-algo.com/chapter_heap/heap/">hello-algo</a></p><h3 id="堆顶元素出堆"><a href="#堆顶元素出堆" class="headerlink" title="堆顶元素出堆"></a>堆顶元素出堆</h3><p>堆顶元素是二叉树的根节点，即数组首元素。 如果我们直接从数组中删除首元素，那<span style="color:red;">最后堆化出来的堆可能并不满足完全二叉树的特性</span>。如下图案例：<br><img src="/images/data-structure-algorithm/WX20231116-151752@2x.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p><p><span style="color:#6A9113;font-weight:600">因此我们需要改变一下思路，比如以下这个巧妙的步骤:</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">交换堆顶元素与堆底元素（即交换根节点与最右叶节点）。</span><br><span class="line">交换完成后，将堆底从列表中删除（由于已经交换，实际上删除的是原来的堆顶元素）。</span><br><span class="line">从根节点开始，从顶至底执行堆化。</span><br></pre></td></tr></table></figure><p><span style="color:#6A9113;font-weight:600">因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</span></p><blockquote><p>如下图，“从顶至底堆化”的操作方向与“从底至顶堆化”相反，我们将根节点的值与其两个子节点的值进行比较，将最大的子节点与根节点交换。然后循环执行此操作，直到越过叶节点或遇到无须交换的节点时结束。</p><div style="display:flex;"><img src="/images/data-structure-algorithm/heap_pop_step1.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_pop_step2.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_pop_step3.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/heap_pop_step4.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_pop_step5.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_pop_step6.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><div style="display:flex;"><img src="/images/data-structure-algorithm/heap_pop_step7.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_pop_step8.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/heap_pop_step9.png" width="350px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div><img src="/images/data-structure-algorithm/heap_pop_step10.png" width="262px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></blockquote><p>与元素入堆操作相似，堆顶元素出堆操作的时间复杂度也为 <code>O(logn)</code>。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_heap/build_heap/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;建堆-暂无基础-后面再说&quot;&gt;&lt;a href=&quot;#建堆-暂无基础-后面再说&quot; class=&quot;headerlink&quot; title=&quot;建堆 - 暂无基础 后面再说&quot;&gt;&lt;/a&gt;建堆 - 暂无基础 后面再说&lt;/h3&gt;&lt;p&gt;之前已经了解 &lt;code&gt;堆&lt;/code&gt; 这种数据结构的底层采用是 &lt;code&gt;数组&lt;/code&gt; 这种最基本数据结构进行存储的(即 物理上是&lt;code&gt;顺序存储&lt;/code&gt;)。&lt;br&gt;现在的问题是，假如给了我们一组数据，我们如何使用这些元素在&lt;strong&gt;逻辑上&lt;/strong&gt;构建出一个 &lt;code&gt;堆&lt;/code&gt; 呢？&lt;br&gt;毕竟要讲对某个数据结构的操作效率，就得写代码去操作这个数据结构，所以我们得先构造出这个数据结构才行啊 😝&lt;/p&gt;
&lt;p&gt;不过，建堆操作比较特殊，堆的建造过程需要我们先了解它的一些基本的核心操作，所以，我们先假设有了一个堆，然后先看它的一些基本操作，之后再来看如何建堆。&lt;/p&gt;
&lt;h3 id=&quot;访问堆顶元素&quot;&gt;&lt;a href=&quot;#访问堆顶元素&quot; class=&quot;headerlink&quot; title=&quot;访问堆顶元素&quot;&gt;&lt;/a&gt;访问堆顶元素&lt;/h3&gt;&lt;p&gt;堆顶元素即为二叉树的根节点，也就是数组的首个元素&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* 访问堆顶元素 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int peek() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return maxHeap.get(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」堆</title>
    <link href="http://rymuscle.github.io/2020/11/02/data-structure-algorithm/11-1.heap/"/>
    <id>http://rymuscle.github.io/2020/11/02/data-structure-algorithm/11-1.heap/</id>
    <published>2020-11-02T13:16:14.000Z</published>
    <updated>2023-11-17T08:11:10.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识堆"><a href="#认识堆" class="headerlink" title="认识堆"></a>认识堆</h3><blockquote><p>lant:<br><span style="color:#363795"><br><strong>之所以<code>树</code>这种数据结构学完紧接着就是<code>堆</code>，是因为其实<code>堆</code>也是<code>树</code>，不过是一种<code>特殊的树</code>，怎么个特殊法呢?<br>首先它得是一棵<code>完全二叉树</code>；<br>其次，堆中的每个节点的值都必须 大于等于&#x2F;小于等于 其子树中每个节点的值；(前者叫<code>大顶堆</code>，后者叫<code>小顶堆</code>)</strong><br></span><br><img src="/images/data-structure-algorithm/min_heap_and_max_heap.png" width="450px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>对于大顶堆（小顶堆），堆顶元素（即根节点）的值分别是最大（最小）的。</p></blockquote><span id="more"></span><br/><blockquote><p>根据堆的特性区判断下面这几个<code>二叉树</code>是不是<code>堆</code><br><img src="/images/data-structure-algorithm/4c452a1ad3b2d152daa2727d06097099.webp" width="450px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>其中第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆。<br/><br><span style="color:darkorange;font-weight: bold;">除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。</span></p></blockquote><h3 id="堆的存储与表示"><a href="#堆的存储与表示" class="headerlink" title="堆的存储与表示"></a>堆的存储与表示</h3><p>之前在学<code>二叉树</code>时，已经了解到<code>完全二叉树</code>非常适合用<code>数组</code>来存储。而<code>堆</code>正是一种<code>完全二叉树</code>，所以我们也将采用<code>数组</code>来存储<code>堆</code>。</p><p>当使用<code>数组</code>表示<code>二叉树</code>时，元素代表节点值，索引代表节点在二叉树中的位置。节点指针通过<code>索引映射公式</code>来实现。<br>如下图，给定索引 i，其左子节点索引为 2<em>i，右子节点索引为 2</em>i+1，父节点索引为 i&#x2F;2（向下取整）。当索引越界时，表示空节点或节点不存在。<br><img src="/images/data-structure-algorithm/representation_of_heap.png" width="550px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p><p>我们可以将索引映射公式封装成函数，方便后续使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 获取左子节点索引 */</span><br><span class="line">int left(int i) &#123;</span><br><span class="line">    return 2 * i + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 获取右子节点索引 */</span><br><span class="line">int right(int i) &#123;</span><br><span class="line">    return 2 * i + 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 获取父节点索引 */</span><br><span class="line">int parent(int i) &#123;</span><br><span class="line">    return (i - 1) / 2; // 向下整除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><p>其实我们从<code>堆的存储</code>原理中看出，将<code>堆</code>中元素放入数组的顺序，其实是个 <code>“层序遍历”(即 广度优先遍历)</code> 的顺序来的。</p><h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h3><p>在熟悉<code>堆</code>这种数据结构的常用操作前，我们还是先了解下<code>堆</code>一般被用到哪些场景吧。</p><ol><li><p>首先就是 <code>优先队列</code>：<code>堆</code>通常作为实现<code>优先队列</code>的首选数据结构</p><blockquote><p>lant:<br>因为我们如果对一个<code>堆</code>结构不断地做<code>堆顶元素出堆</code>操作(下一篇会讲到这个操作)，你会发现元素会根据大顶堆&#x2F;小顶堆的不同，按照从大到小&#x2F;从小到大的顺序依次排列出来，且元素入堆和出堆的时间复杂度均为<code>O(logn)</code>。<br>如果是个大顶堆的话，我们就可以将其看做一个<code>优先队列</code>(元素进入后，可以按值从大到小被取出)，其入队和出队操作的时间复杂度均为 <code>O(logn)</code>，而建堆操作为 <code>O(n)</code>，这些操作都非常高效。</p></blockquote></li><li><p>堆排序：<br>给定一组数据，我们可以用它们建立一个堆，然后不断地执行元素出堆操作，从而得到有序数据。然而，我们通常会使用一种更优雅的方式实现堆排序，详见后续的堆排序章节。</p></li><li><p>求解 <code>Top K</code> (即获取最大的K个元素)：<br>这是一个经典的算法问题，同时也是一种典型应用，例如选择热度前 10 的新闻作为微博热搜，选取销量前 10 的商品等。</p></li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_heap/heap/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;认识堆&quot;&gt;&lt;a href=&quot;#认识堆&quot; class=&quot;headerlink&quot; title=&quot;认识堆&quot;&gt;&lt;/a&gt;认识堆&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;lant:&lt;br&gt;&lt;span style=&quot;color:#363795&quot;&gt;&lt;br&gt;&lt;strong&gt;之所以&lt;code&gt;树&lt;/code&gt;这种数据结构学完紧接着就是&lt;code&gt;堆&lt;/code&gt;，是因为其实&lt;code&gt;堆&lt;/code&gt;也是&lt;code&gt;树&lt;/code&gt;，不过是一种&lt;code&gt;特殊的树&lt;/code&gt;，怎么个特殊法呢?&lt;br&gt;首先它得是一棵&lt;code&gt;完全二叉树&lt;/code&gt;；&lt;br&gt;其次，堆中的每个节点的值都必须 大于等于&amp;#x2F;小于等于 其子树中每个节点的值；(前者叫&lt;code&gt;大顶堆&lt;/code&gt;，后者叫&lt;code&gt;小顶堆&lt;/code&gt;)&lt;/strong&gt;&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;img src=&quot;/images/data-structure-algorithm/min_heap_and_max_heap.png&quot; width=&quot;450px&quot; style=&quot;margin-left:0px;border: 1px solid #ccc;border-radius: 5px;&quot;/&gt;&lt;br&gt;对于大顶堆（小顶堆），堆顶元素（即根节点）的值分别是最大（最小）的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」红黑树 Red-Black Tree</title>
    <link href="http://rymuscle.github.io/2020/10/31/data-structure-algorithm/10-9.red-blackTree/"/>
    <id>http://rymuscle.github.io/2020/10/31/data-structure-algorithm/10-9.red-blackTree/</id>
    <published>2020-10-31T06:06:23.000Z</published>
    <updated>2023-11-16T02:38:15.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《数据结构与算法之美》王争</li><li><a href="https://blog.csdn.net/yang_yulei/article/details/26066409">https://blog.csdn.net/yang_yulei/article/details/26066409</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;《数据结构与算法之美》王争&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/ya</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」2-3树</title>
    <link href="http://rymuscle.github.io/2020/10/30/data-structure-algorithm/10-8.2-3Tree/"/>
    <id>http://rymuscle.github.io/2020/10/30/data-structure-algorithm/10-8.2-3Tree/</id>
    <published>2020-10-30T15:13:09.000Z</published>
    <updated>2023-11-16T02:38:15.271Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>《数据结构与算法之美》王争</li><li><a href="https://blog.csdn.net/yang_yulei/article/details/26066409">从2-3树到 红黑树</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;《数据结构与算法之美》王争&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/ya</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」平衡二叉搜索树--AVL树（下）</title>
    <link href="http://rymuscle.github.io/2020/10/29/data-structure-algorithm/10-7.AVL/"/>
    <id>http://rymuscle.github.io/2020/10/29/data-structure-algorithm/10-7.AVL/</id>
    <published>2020-10-29T15:13:09.000Z</published>
    <updated>2023-11-16T02:38:15.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AVL-树常用操作"><a href="#AVL-树常用操作" class="headerlink" title="AVL 树常用操作"></a>AVL 树常用操作</h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>AVL 树的节点插入操作与二叉搜索树在主体上类似。唯一的区别在于，在 AVL 树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。因此，我们需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>类似地，在二叉搜索树的删除节点方法的基础上，需要从底至顶地执行旋转操作，使所有失衡节点恢复平衡</p><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>AVL 树的节点查找操作与二叉搜索树一致，在此不再赘述。</p><h3 id="AVL-树典型应用"><a href="#AVL-树典型应用" class="headerlink" title="AVL 树典型应用"></a>AVL 树典型应用</h3><p>组织和存储大型数据，适用于高频查找、低频增删的场景。<br>用于构建数据库中的索引系统。<br>红黑树在许多应用中比 AVL 树更受欢迎。这是因为<strong>红黑树的平衡条件相对宽松</strong>，在红黑树中插入与删除节点所需的旋转操作相对较少，其节点增删操作的平均效率更高。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/avl_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li><li><a href="https://blog.csdn.net/yang_yulei/article/details/26066409">https://blog.csdn.net/yang_yulei/article/details/26066409</a></li><li><a href="https://zhuanlan.zhihu.com/p/594775323">https://zhuanlan.zhihu.com/p/594775323</a></li><li><a href="https://zhuanlan.zhihu.com/p/604835603?utm_id=0">https://zhuanlan.zhihu.com/p/604835603?utm_id=0</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;AVL-树常用操作&quot;&gt;&lt;a href=&quot;#AVL-树常用操作&quot; class=&quot;headerlink&quot; title=&quot;AVL 树常用操作&quot;&gt;&lt;/a&gt;AVL 树常用操作&lt;/h3&gt;&lt;h4 id=&quot;插入操作&quot;&gt;&lt;a href=&quot;#插入操作&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」平衡二叉搜索树--AVL树（上）</title>
    <link href="http://rymuscle.github.io/2020/10/29/data-structure-algorithm/10-6.AVL/"/>
    <id>http://rymuscle.github.io/2020/10/29/data-structure-algorithm/10-6.AVL/</id>
    <published>2020-10-29T14:09:21.000Z</published>
    <updated>2023-11-16T02:42:56.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lant："><a href="#lant：" class="headerlink" title="lant："></a>lant：</h3><p>通过上一篇对 <code>BST</code> 和 <code>hash表</code> 这两种数据结构的对比，我们知道虽然 <code>BST</code>在平衡状态下的 查、插、删 时间复杂度能达到<code>O(logn)</code>，但相比 <code>hash表</code>的 <code>O(1)</code>常量级时间复杂度还是逊色一点，不过它有<code>hash表</code>无法做到的，所以有存在的必要性和合理性。<br>但上面也提到了，BST需要在平衡状态下才能发挥出威力，否则它的操作效率会逐渐降低到<code>O(n)</code>级。<br>为了解决极端情况下，二叉树会退化为链表的情况，我们就需要设计一种<code>平衡二叉查找树</code>，也就是今天要讲的这种数据结构。<br>通俗的讲，<code>平衡二叉查找树</code>就是说，一棵<code>二叉查找树</code>在频繁地增删改查操作后，它依然能不断通过自我修复来维护自身的平衡性，从而始终保持高效的数据操作性能。</p><h3 id="自平衡二叉查找树"><a href="#自平衡二叉查找树" class="headerlink" title="自平衡二叉查找树"></a>自平衡二叉查找树</h3><p>其实<code>平衡二叉查找树</code>有挺多，常见的比如 <code>AVL树</code>，<code>SplayTree(伸展树)</code>、<code>Treap(树堆)</code>、<code>红黑树</code>。<br>不过你可能留意到，每当提到<code>平衡二叉查找树</code>，听到的基本都是<code>红黑树</code>。它的出镜率甚至要高于“平衡二叉查找 树”这几个字，有时候，我们甚至默认<code>平衡二叉查找树</code>就是<code>红黑树</code>，不过本篇暂时不聊这个明星树，后面会专门再聊。<br>下面先看最早的AVL树。</p><span id="more"></span><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><ol><li>AVL树是最先被发明的自平衡二叉查找树, 它严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</li><li>AVL 树既是<code>二叉搜索树</code>也是<code>平衡二叉树</code>，同时满足这两类二叉树的所有性质，因此也被称为<code>「平衡二叉搜索树 balanced binary search tree」</code>。</li></ol><h3 id="AVL树如何实现自平衡"><a href="#AVL树如何实现自平衡" class="headerlink" title="AVL树如何实现自平衡"></a>AVL树如何实现自平衡</h3><ol><li><p>AVL 树之所以在不断地增删改查操作后，依然能保持自身的平衡，就是因为它的“旋转”操作。<br>它的旋转操做能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”。</p></li><li><p>在介绍AVL树的旋转操作之前，我们先了解一个概念叫 <code>平衡因子</code>， 它用来标识当前节点是否是<code>失衡节点</code>，如果是，就需要对其做旋转操作来保证二叉树的平衡。</p></li><li><p>当发现<code>失衡因子</code>时，如何对其进行旋转才能保证二叉树的平衡呢？<br>下面根据节点失衡情况的不同，将旋转操作分为四种：<code>右旋</code>、<code>左旋</code>、<code>先右旋后左旋</code>、<code>先左旋后右旋</code>。下面我们将详细介绍这些旋转操作。</p></li></ol><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><blockquote><p>其实我们可以想下，为什么是四种旋转操作呢？<br>其实很简单，平衡的条件是 <code>任意节点**的左子树和右子树的高度之差的绝对值不超过 1 </code>，那就意味着，当你插入一个节点时，只要破坏了这个条件，就得做旋转操作。<br>所以，我们只用看插入节点后，破坏平衡的状况有哪几种，无非就四种：<code>父是左节点，自己是左节点</code>，<code>父左,自己右</code>; <code>父右,自己左</code>，<code>父左,字节右</code><br><img src="/images/data-structure-algorithm/avltree_rotation_cases.png" width="450px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>每种失衡情况有各自对应的旋转操作。</p></blockquote><br/><blockquote><p>另外 ，在学习具体的旋转操作之前，我们切记要做到有的放矢，不要太执迷于一些玄学，比如陷入”为什么这么转就能保持平衡，怎么能论证这个结论?”、“这么神奇的操作是怎么想出来的，为什么我就想不出这个方法?” …..<br>可以你看看技术大咖们对此的看法：</p><div style="display: flex"><img src="/images/data-structure-algorithm/b-s-t-0006.png" width="460px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><div style="display: flex;flex-direction: column;"><img src="/images/data-structure-algorithm/b-s-t-0007.png" width="300px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><img src="/images/data-structure-algorithm/WX20231116-101427@2x.png" width="300px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></div></div></blockquote><h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p><a href="https://www.hello-algo.com/chapter_tree/avl_tree/#1_1">https://www.hello-algo.com/chapter_tree/avl_tree/#1_1</a></p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p><a href="https://www.hello-algo.com/chapter_tree/avl_tree/#2_1">https://www.hello-algo.com/chapter_tree/avl_tree/#2_1</a></p><h4 id="先左旋后右旋"><a href="#先左旋后右旋" class="headerlink" title="先左旋后右旋"></a>先左旋后右旋</h4><p><a href="https://www.hello-algo.com/chapter_tree/avl_tree/#3">https://www.hello-algo.com/chapter_tree/avl_tree/#3</a></p><h4 id="先右旋后左旋"><a href="#先右旋后左旋" class="headerlink" title="先右旋后左旋"></a>先右旋后左旋</h4><p><a href="https://www.hello-algo.com/chapter_tree/avl_tree/#4">https://www.hello-algo.com/chapter_tree/avl_tree/#4</a></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/avl_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;lant：&quot;&gt;&lt;a href=&quot;#lant：&quot; class=&quot;headerlink&quot; title=&quot;lant：&quot;&gt;&lt;/a&gt;lant：&lt;/h3&gt;&lt;p&gt;通过上一篇对 &lt;code&gt;BST&lt;/code&gt; 和 &lt;code&gt;hash表&lt;/code&gt; 这两种数据结构的对比，我们知道虽然 &lt;code&gt;BST&lt;/code&gt;在平衡状态下的 查、插、删 时间复杂度能达到&lt;code&gt;O(logn)&lt;/code&gt;，但相比 &lt;code&gt;hash表&lt;/code&gt;的 &lt;code&gt;O(1)&lt;/code&gt;常量级时间复杂度还是逊色一点，不过它有&lt;code&gt;hash表&lt;/code&gt;无法做到的，所以有存在的必要性和合理性。&lt;br&gt;但上面也提到了，BST需要在平衡状态下才能发挥出威力，否则它的操作效率会逐渐降低到&lt;code&gt;O(n)&lt;/code&gt;级。&lt;br&gt;为了解决极端情况下，二叉树会退化为链表的情况，我们就需要设计一种&lt;code&gt;平衡二叉查找树&lt;/code&gt;，也就是今天要讲的这种数据结构。&lt;br&gt;通俗的讲，&lt;code&gt;平衡二叉查找树&lt;/code&gt;就是说，一棵&lt;code&gt;二叉查找树&lt;/code&gt;在频繁地增删改查操作后，它依然能不断通过自我修复来维护自身的平衡性，从而始终保持高效的数据操作性能。&lt;/p&gt;
&lt;h3 id=&quot;自平衡二叉查找树&quot;&gt;&lt;a href=&quot;#自平衡二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;自平衡二叉查找树&quot;&gt;&lt;/a&gt;自平衡二叉查找树&lt;/h3&gt;&lt;p&gt;其实&lt;code&gt;平衡二叉查找树&lt;/code&gt;有挺多，常见的比如 &lt;code&gt;AVL树&lt;/code&gt;，&lt;code&gt;SplayTree(伸展树)&lt;/code&gt;、&lt;code&gt;Treap(树堆)&lt;/code&gt;、&lt;code&gt;红黑树&lt;/code&gt;。&lt;br&gt;不过你可能留意到，每当提到&lt;code&gt;平衡二叉查找树&lt;/code&gt;，听到的基本都是&lt;code&gt;红黑树&lt;/code&gt;。它的出镜率甚至要高于“平衡二叉查找 树”这几个字，有时候，我们甚至默认&lt;code&gt;平衡二叉查找树&lt;/code&gt;就是&lt;code&gt;红黑树&lt;/code&gt;，不过本篇暂时不聊这个明星树，后面会专门再聊。&lt;br&gt;下面先看最早的AVL树。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」二叉搜索树 binary search tree</title>
    <link href="http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-5.bst/"/>
    <id>http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-5.bst/</id>
    <published>2020-10-28T13:35:43.000Z</published>
    <updated>2023-11-16T02:42:56.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说到<code>二叉查找树</code>，从名字你也能猜出这种数据结构的估计就是用二叉树来做快速查找的。<br>事实上<code>二叉搜索树</code>最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。<br>而我们之前学过的<code>散列表</code>也是支持这些操作的，并且<code>散列表</code>的这些操作比<code>二叉查找树</code>更高效，时间复杂度是 <code>O(1)</code>。<br>既然有了这么高效的<code>散列表</code>，还要<code>二叉查找树</code>干啥？有没有哪些地方是<code>散列表</code>做不了，必须要用<code>二叉查找树</code>来做的呢？</p><p>带着这些问题，下面来学习今天的内容，<strong>二叉查找树</strong>！</p><h3 id="二叉搜索树-binary-search-tree"><a href="#二叉搜索树-binary-search-tree" class="headerlink" title="二叉搜索树 binary search tree"></a>二叉搜索树 binary search tree</h3><p>首先<code>二叉查找树</code>是建立在<code>二叉树</code>的基础上的，不过，它在<code>二叉树</code>的基础上又新增了自己的特性：<br><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong>下面是几个<code>二叉查找树</code>的例子，估计你一看应该就清楚了<br><img src="/images/data-structure-algorithm/b-s-t-0001.png" width="450px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p><span id="more"></span><h3 id="TODO-初始化一棵平衡的二叉查找树-学到本篇-目前还有难度-😰"><a href="#TODO-初始化一棵平衡的二叉查找树-学到本篇-目前还有难度-😰" class="headerlink" title="TODO 初始化一棵平衡的二叉查找树 学到本篇,目前还有难度 😰"></a>TODO 初始化一棵平衡的二叉查找树 学到本篇,目前还有难度 😰</h3><p><strong>lant:</strong> <a href="/2020/10/27/data-structure-algorithm/10-3.binary-tree/#lant">回忆</a><br>之前我们的<code>二叉树</code>一直都是把一些节点通过指针随意串连起来的，<span style="color:orange;">只不过在串连的时候，我们会尽量让它<strong>更像</strong>一棵树(你要是追求完美的话，还能让它更像一棵 <code>完美二叉树</code>)</span>。<br><strong>而现在的<code>二叉搜索树</code>不一样了，它要求我们在串连节点时，除了尽量更像一棵树，还要遵循它的额外特性。</strong></p><p>所以，如果你使用一组数据来初始化一棵 二叉查找树，你可能要花费点时间了，你除了要保证二叉查找树的特性，又要尽可能让树平衡… 还是要花费点时间的 (可以点击<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">这个</a>数据结构可视化站点试试)</p><blockquote><p>比如给你一组数 [1~10] 做节点，让你做个二叉搜索树<br>如果你直接挨个拿出节点连接，企图构建一棵二叉树，那效果就尴尬了：<br><img src="/images/data-structure-algorithm/b-s-t-0004.png" width="300px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>而一棵平衡的二叉查找树应该像下面这样：<br><span style="color:red;font-weight:600;">如果让你手动将这些节点连接成一棵平衡的二叉查找树，怕是不告诉你用什么技巧，你可能要连一阵子了 😝<span><br><img src="/images/data-structure-algorithm/b-s-t-0005.png" width="300px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote><p>我们暂时先不考虑如何能初始化一棵平衡的二叉搜索树，这个问题后面再聊…<br>下面先假设我们已经有了一棵平衡的 <code>二叉搜索树</code>，然后看我们能用它做些什么操作，时间复杂度怎么样。</p><h3 id="二叉搜索树的操作"><a href="#二叉搜索树的操作" class="headerlink" title="二叉搜索树的操作"></a>二叉搜索树的操作</h3><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ol><li><p><strong>假设我们现在已经有了一棵平衡的二叉查找树</strong>，那如何在二叉查找树中查找一个节点？ </p><blockquote><p>从根节点开始，如果它等于我们要查找的数据，那就返回;<br>如果要查找的数据比根节点的值小，那就在左子树中<strong>递归</strong>查找；<br>如果要查找的数据比根节点的值大，那就在右子树中<strong>递归</strong>查找。<br><img src="/images/data-structure-algorithm/b-s-t-0002.png" width="220px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p></blockquote></li><li><p>二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，<strong>当二叉树平衡时</strong>，使用 <code>O(log n)</code>时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 查找节点 */</span><br><span class="line">TreeNode search(int num) &#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    // 循环查找，越过叶节点后跳出</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        // 目标节点在 cur 的右子树中</span><br><span class="line">        if (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        // 目标节点在 cur 的左子树中</span><br><span class="line">        else if (cur.val &gt; num)</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        // 找到目标节点，跳出循环</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回目标节点</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><ol><li><p>如何在<code>二叉查找树</code>中插入节点？</p><blockquote><p>二叉查找树的插入过程有点类似查找操作。 我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。<br>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置； 如果不为空，就再递归遍历右子树，查找插入位置。<br>同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。<br><img src="/images/data-structure-algorithm/b-s-t-0003.png" width="220px" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>代码参考 <a href="https://www.hello-algo.com/chapter_tree/binary_search_tree/#2">这里</a></p></blockquote></li><li><p>很显然，即便你最初拥有一棵非常平衡的二叉查找树，随着你不断地插入节点(或者后面的删除节点)，你原本的 <code>平衡二叉查找树</code> 可能就逐渐退化成了<code>链表</code>。这时各种操作的时间复杂度也会退化为 <code>O(n)</code>。</p></li></ol><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>如何在<code>二叉查找树</code>中删除节点？<br>参考 <a href="https://www.hello-algo.com/chapter_tree/binary_search_tree/#3">这里</a></p><h4 id="二叉搜索树-中序遍历-的-福利"><a href="#二叉搜索树-中序遍历-的-福利" class="headerlink" title="二叉搜索树 中序遍历 的 福利"></a>二叉搜索树 中序遍历 的 福利</h4><p>由于 <code>二叉查找树</code> 有 任意节点<code>左子节点 &lt; 根节点 &lt; 右子节点</code>的特性。而二叉树<code>中序遍历</code>的遍历顺序正好又是<code>左-&gt;根-&gt;右</code>。<br>所以，对于<code>二查找叉树</code>来说，它的中序遍历得到的序列就是个升序序列。</p><p><span style="color:orange">利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需<code>O(n)</code>时间，无须进行额外的排序操作，非常高效。</span></p><h3 id="二叉搜索树的效率"><a href="#二叉搜索树的效率" class="headerlink" title="二叉搜索树的效率"></a>二叉搜索树的效率</h3><p>在理想情况下，二叉搜索树是“平衡”的，这样就可以在 <code>O(log n)</code> 的时间复杂度下，查、插、删 节点。</p><h3 id="开头的问题"><a href="#开头的问题" class="headerlink" title="开头的问题"></a>开头的问题</h3><p>之前我们学过，<code>散列表</code> 的插入、删除、查找操作的时间复杂度可以做到常量级的<code>O(1)</code>，非常高效;<br>而<code>二叉查找树</code>在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 <code>O(logn)</code>; 相对<code>散列表</code>，好像并没有什么优势，那我们为什么还要用<code>二叉查找树</code>呢？</p><p>我认为有下面几个原因：</p><ul><li>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。<br>  比如，如果做索引的话(如mysql)，用户一般会有排序要求，散列表当然不能满足了。</li><li>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)。</li><li>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li><li>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li><li>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。<br>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</li></ul><h3 id="二叉搜索树常见应用"><a href="#二叉搜索树常见应用" class="headerlink" title="二叉搜索树常见应用"></a>二叉搜索树常见应用</h3><p><strong>用作系统中的多级索引，实现高效的查找、插入、删除操作。</strong><br>作为某些搜索算法的底层数据结构。<br>用于存储数据流，以保持其有序状态。</p><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><p>所以我们现在的问题是</p><ol><li>如果我们有了一棵平衡的二叉搜索树，我们只能对树上现有的静态数据做查询操作，如果频繁地做插入，删除操作，我们目前还没办法保持树继续平衡，极端情况下，树有可能退化为链表。</li><li>即便我们只是想对一组静态数据进行查询操作，我们目前也还没办法先将他们逻辑地组成一棵平衡的 二叉搜索树 😓。</li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/binary_search_tree/#2">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;说到&lt;code&gt;二叉查找树&lt;/code&gt;，从名字你也能猜出这种数据结构的估计就是用二叉树来做快速查找的。&lt;br&gt;事实上&lt;code&gt;二叉搜索树&lt;/code&gt;最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。&lt;br&gt;而我们之前学过的&lt;code&gt;散列表&lt;/code&gt;也是支持这些操作的，并且&lt;code&gt;散列表&lt;/code&gt;的这些操作比&lt;code&gt;二叉查找树&lt;/code&gt;更高效，时间复杂度是 &lt;code&gt;O(1)&lt;/code&gt;。&lt;br&gt;既然有了这么高效的&lt;code&gt;散列表&lt;/code&gt;，还要&lt;code&gt;二叉查找树&lt;/code&gt;干啥？有没有哪些地方是&lt;code&gt;散列表&lt;/code&gt;做不了，必须要用&lt;code&gt;二叉查找树&lt;/code&gt;来做的呢？&lt;/p&gt;
&lt;p&gt;带着这些问题，下面来学习今天的内容，&lt;strong&gt;二叉查找树&lt;/strong&gt;！&lt;/p&gt;
&lt;h3 id=&quot;二叉搜索树-binary-search-tree&quot;&gt;&lt;a href=&quot;#二叉搜索树-binary-search-tree&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树 binary search tree&quot;&gt;&lt;/a&gt;二叉搜索树 binary search tree&lt;/h3&gt;&lt;p&gt;首先&lt;code&gt;二叉查找树&lt;/code&gt;是建立在&lt;code&gt;二叉树&lt;/code&gt;的基础上的，不过，它在&lt;code&gt;二叉树&lt;/code&gt;的基础上又新增了自己的特性：&lt;br&gt;&lt;strong&gt;二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。&lt;/strong&gt;下面是几个&lt;code&gt;二叉查找树&lt;/code&gt;的例子，估计你一看应该就清楚了&lt;br&gt;&lt;img src=&quot;/images/data-structure-algorithm/b-s-t-0001.png&quot; width=&quot;450px&quot; style=&quot;margin-left:0px;border: 1px solid #ccc;border-radius: 5px;&quot;/&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」用数组表示(存储)二叉树</title>
    <link href="http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-4.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/28/data-structure-algorithm/10-4.binary-tree/</id>
    <published>2020-10-28T12:57:19.000Z</published>
    <updated>2023-11-16T02:42:56.815Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>之前我们的<code>二叉树</code>是使用<code>链表</code>这种最基本的数据结构来存储的（<code>链式存储</code>）。 而本篇我们将使用<code>数组</code>这种最基本的结构来存储<code>二叉树</code>（<code>顺序存储</code>）。</p><img src="/images/data-structure-algorithm/WX20231115-113301@2x.png" width="400px" style="margin-left:0px;"/></li><li><p>尝试用数组存储一棵二叉树</p><blockquote><p>如果将根节点A存储在下标 <code>i = 1</code> 的位置，那左子节点B会存储在下标 <code>2 * i = 2</code> 的位置，右子节点C会存储在 <code>2 * i + 1 = 3</code> 的位置。<br>以此类推，B 节点的左子节点D会存储在 <code>2 * i = 2 * 2 = 4</code> 的位置，右子节点E存储在 <code>2 * i + 1 = 2 * 2 + 1 = 5</code> 的位置。<br>……<br>最终的二叉树和数组的对应关系如下图:<br><img src="/images/data-structure-algorithm/WX20231115-114707@2x.png" width="250px" style="margin-left:0px;"/><br>总结一下，就是，<strong>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是它的左子节点，下标为 2 * i + 1 的位置存储的就是它的右子节点。反过来，下标为 i&#x2F;2 的位置存储就是它的父节点。</strong><br><strong>通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。</strong></p></blockquote></li><li><p>比较遗憾的是，刚刚我们举的例子是将一棵完全二叉树存储到了数组中，为了方便通过下标计算树中各节点位置，所以“浪费”了一个下标为 0 的存储位置。<span style="color:red">但如果我们往数组中存储的是一棵非完全二叉树，那就会浪费比较多的数组存储空间了</span>。</p><div style="display: flex;align-content: center;"><img src="/images/data-structure-algorithm/WX20231115-115837@2x.png" width="260px" /><img src="/images/data-structure-algorithm/array_representation_with_empty.png" width="350px" style="margin-left: 20px;"/></div></li></ol><p>可以看到，我们为了使  <code>根节点下标为i, 左子节点下标为2 * i, 右子节点下标为 2 * i + 1</code> 这个公式来仍然生效(<strong>方便计算各节点位置从而串起整棵树</strong>)，<span style="color:red">就不得不将一些None节点的位置也在数组中留出来。 这样就会浪费比较多的数组存储空间。</span></p><span id="more"></span><p>以下代码实现了一个基于数组表示的二叉树，包括以下几种操作</p><ul><li>给定某节点，获取它的值、左（右）子节点、父节点。</li><li>获取前序遍历、中序遍历、后序遍历、层序遍历序列。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/* 数组表示下的二叉树类 */</span><br><span class="line">class ArrayBinaryTree &#123;</span><br><span class="line">    private List&lt;Integer&gt; tree;</span><br><span class="line"></span><br><span class="line">    /* 构造方法 */</span><br><span class="line">    public ArrayBinaryTree(List&lt;Integer&gt; arr) &#123;</span><br><span class="line">        tree = new ArrayList&lt;&gt;(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 节点数量 */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return tree.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的值 */</span><br><span class="line">    public Integer val(int i) &#123;</span><br><span class="line">        // 若索引越界，则返回 null ，代表空位</span><br><span class="line">        if (i &lt; 0 || i &gt;= size())</span><br><span class="line">            return null;</span><br><span class="line">        return tree.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的左子节点的索引 */</span><br><span class="line">    public Integer left(int i) &#123;</span><br><span class="line">        return 2 * i + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的右子节点的索引 */</span><br><span class="line">    public Integer right(int i) &#123;</span><br><span class="line">        return 2 * i + 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取索引为 i 节点的父节点的索引 */</span><br><span class="line">    public Integer parent(int i) &#123;</span><br><span class="line">        return (i - 1) / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 层序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; levelOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        // 直接遍历数组</span><br><span class="line">        for (int i = 0; i &lt; size(); i++) &#123;</span><br><span class="line">            if (val(i) != null)</span><br><span class="line">                res.add(val(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 深度优先遍历 */</span><br><span class="line">    private void dfs(Integer i, String order, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        // 若为空位，则返回</span><br><span class="line">        if (val(i) == null)</span><br><span class="line">            return;</span><br><span class="line">        // 前序遍历</span><br><span class="line">        if (order == &quot;pre&quot;)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(left(i), order, res);</span><br><span class="line">        // 中序遍历</span><br><span class="line">        if (order == &quot;in&quot;)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(right(i), order, res);</span><br><span class="line">        // 后序遍历</span><br><span class="line">        if (order == &quot;post&quot;)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 前序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; preOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, &quot;pre&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 中序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; inOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, &quot;in&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 后序遍历 */</span><br><span class="line">    public List&lt;Integer&gt; postOrder() &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(0, &quot;post&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>lant:</p><blockquote><p>所以，其实二叉树中，也就<code>完全二叉树</code>比较适合用 数组来存储。 因为如果一棵二叉树是一棵<code>完全二叉树</code>，那它用数组存储就会非常节省空间，它不需要像链式存储那样要存储额外的左右子节点的指针。<br>这也是为什么<code>完全二叉树</code>要求最后一层的子节点都靠左的原因，因为右边的None节点会一起排在数组的末尾，可以直接省略，也不影响 <code>数组存储二叉树的公式</code> 计算。<br><img src="/images/data-structure-algorithm/WX20231115-120907@2x.png" width="420px" /><br><img src="/images/data-structure-algorithm/WX20231115-120750@2x.png" width="420px" /></p></blockquote></li><li><p>优势与局限性<br>二叉树的数组表示主要有以下优点：</p></li></ol><ul><li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。</li><li>不需要存储指针，比较节省空间。</li><li>允许随机访问节点。</li></ul><p>然而，数组表示也存在一些局限性：</p><ul><li>数组存储需要连续内存空间，因此不适合存储数据量过大的树。</li><li>增删节点需要通过数组插入与删除操作实现，效率较低。</li><li>当二叉树中存在大量None时，数组中包含的节点数据比重较低，空间利用率较低。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/array_representation_of_tree/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;之前我们的&lt;code&gt;二叉树&lt;/code&gt;是使用&lt;code&gt;链表&lt;/code&gt;这种最基本的数据结构来存储的（&lt;code&gt;链式存储&lt;/code&gt;）。 而本篇我们将使用&lt;code&gt;数组&lt;/code&gt;这种最基本的结构来存储&lt;code&gt;二叉树&lt;/code&gt;（&lt;code&gt;顺序存储&lt;/code&gt;）。&lt;/p&gt;
&lt;img src=&quot;/images/data-structure-algorithm/WX20231115-113301@2x.png&quot; width=&quot;400px&quot; style=&quot;margin-left:0px;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尝试用数组存储一棵二叉树&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果将根节点A存储在下标 &lt;code&gt;i = 1&lt;/code&gt; 的位置，那左子节点B会存储在下标 &lt;code&gt;2 * i = 2&lt;/code&gt; 的位置，右子节点C会存储在 &lt;code&gt;2 * i + 1 = 3&lt;/code&gt; 的位置。&lt;br&gt;以此类推，B 节点的左子节点D会存储在 &lt;code&gt;2 * i = 2 * 2 = 4&lt;/code&gt; 的位置，右子节点E存储在 &lt;code&gt;2 * i + 1 = 2 * 2 + 1 = 5&lt;/code&gt; 的位置。&lt;br&gt;……&lt;br&gt;最终的二叉树和数组的对应关系如下图:&lt;br&gt;&lt;img src=&quot;/images/data-structure-algorithm/WX20231115-114707@2x.png&quot; width=&quot;250px&quot; style=&quot;margin-left:0px;&quot;/&gt;&lt;br&gt;总结一下，就是，&lt;strong&gt;如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是它的左子节点，下标为 2 * i + 1 的位置存储的就是它的右子节点。反过来，下标为 i&amp;#x2F;2 的位置存储就是它的父节点。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比较遗憾的是，刚刚我们举的例子是将一棵完全二叉树存储到了数组中，为了方便通过下标计算树中各节点位置，所以“浪费”了一个下标为 0 的存储位置。&lt;span style=&quot;color:red&quot;&gt;但如果我们往数组中存储的是一棵非完全二叉树，那就会浪费比较多的数组存储空间了&lt;/span&gt;。&lt;/p&gt;
&lt;div style=&quot;display: flex;align-content: center;&quot;&gt;
&lt;img src=&quot;/images/data-structure-algorithm/WX20231115-115837@2x.png&quot; width=&quot;260px&quot; /&gt;
&lt;img src=&quot;/images/data-structure-algorithm/array_representation_with_empty.png&quot; width=&quot;350px&quot; style=&quot;margin-left: 20px;&quot;/&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到，我们为了使  &lt;code&gt;根节点下标为i, 左子节点下标为2 * i, 右子节点下标为 2 * i + 1&lt;/code&gt; 这个公式来仍然生效(&lt;strong&gt;方便计算各节点位置从而串起整棵树&lt;/strong&gt;)，&lt;span style=&quot;color:red&quot;&gt;就不得不将一些None节点的位置也在数组中留出来。 这样就会浪费比较多的数组存储空间。&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>「数据结构与算法」二叉树遍历</title>
    <link href="http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-3.binary-tree/"/>
    <id>http://rymuscle.github.io/2020/10/27/data-structure-algorithm/10-3.binary-tree/</id>
    <published>2020-10-27T13:52:36.000Z</published>
    <updated>2023-11-16T02:42:56.803Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们的<code>二叉树</code>从下层的<code>物理结构</code>角度来看, 仍然是使用<code>链表</code>这种最基本的的数据结构进行的存储，因此其遍历方式仍是通过指针逐个访问节点。 <span style="color:red;">然而</span>，从上层的<code>逻辑角度</code>来看，<code>二叉树</code>是一种<code>非线性数据结构</code>，这就使得二叉树(<span style="color:orange;">在应用层逻辑上</span>)的遍历要比遍历链表更加复杂，需要借助搜索算法来实现。</p><p>二叉树常见的遍历方式包括 <code>层序遍历</code>、<code>前序遍历</code>、<code>中序遍历</code> 和 <code>后序遍历</code> 等。</p><h3 id="广度优先遍历-–-「层序遍历-level-order-traversal」"><a href="#广度优先遍历-–-「层序遍历-level-order-traversal」" class="headerlink" title="广度优先遍历 – 「层序遍历 level-order traversal」"></a>广度优先遍历 – 「层序遍历 level-order traversal」</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。<br>层序遍历本质上属于 <code>「广度优先遍历 breadth-first traversal」</code> ，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。</p><div style="display: flex;"><img src="/images/data-structure-algorithm/binary_tree_bfs.png" width="400px" style="margin-left:0px;"/><img src="/images/data-structure-algorithm/WX20231114-210129@2x.png" width="350px" style="margin-left:10px;border: 1px solid #ccc;border-radius: 5px;"/></div><span id="more"></span><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>仔细看上图的 广度优先遍历 方式，你会发现它遍历节点时，节点出现的方式 和 队列的“先进先出”规则很像，因此广度优先遍历也通常借助“队列”来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 层序遍历 */</span><br><span class="line">List&lt;Integer&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    // 初始化队列，加入根节点</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    // 初始化一个列表，用于保存遍历序列</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll(); // 队列出队</span><br><span class="line">        list.add(node.val);           // 保存节点值</span><br><span class="line">        if (node.left != null)</span><br><span class="line">            queue.offer(node.left);   // 左子节点入队</span><br><span class="line">        if (node.right != null)</span><br><span class="line">            queue.offer(node.right);  // 右子节点入队</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(n)</code>：所有节点被访问一次，使用 O(n) 时间，其中 n 为节点数量。<br>空间复杂度<code>O(n)</code>：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 <code>(n+1)/2</code> 个节点，占用 O(n) 空间。<br><code>二叉树的层数越往下，每层的节点越多，所以 只有二叉树是满二叉树时，最底层的节点数会达到最大。此时，当最底层节点(叶子节点)全部放入队列时，也是队列占用空间最大时。此时叶子结点数量为  (n+1)/2</code></p><h3 id="深度优先遍历-前、中、后-序遍历"><a href="#深度优先遍历-前、中、后-序遍历" class="headerlink" title="深度优先遍历 - 前、中、后 序遍历"></a>深度优先遍历 - 前、中、后 序遍历</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><img src="/images/data-structure-algorithm/WX20231115-102257@2x.png" width="450px" style="margin-left:10px;border: 1px solid #ccc;border-radius: 5px;"/><blockquote><p>“前序”、”中序”、”后序” 是基于遍历时 “根节点” 的顺序来说的。前序：根在前；中序：根在中；后序：根在后; </p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* 前序遍历 */</span><br><span class="line">void preOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 中序遍历 */</span><br><span class="line">void inOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 后序遍历 */</span><br><span class="line">void postOrder(TreeNode root) &#123;</span><br><span class="line">    if (root == null)</span><br><span class="line">        return;</span><br><span class="line">    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 <code>O(n)</code>：所有节点被访问一次，使用 O(n) 时间。<br>空间复杂度 <code>O(n)</code>：在最差情况下，即树退化为链表时，递归深度达到 n，系统占用 O(n) 栈帧空间。</p><h3 id="lant"><a href="#lant" class="headerlink" title="lant:"></a>lant:</h3><p>到目前为止，我们的二叉树都还只是自己手动将一些 数据节点 随意串连起来的，父子节点之间也没什么大小顺序之分，节点们的组合还没什么规律可言。<br>我们也只是在串连时尽量保证它们连起来像一棵二叉树，尽量<code>完全</code> 或 <code>完美</code>。</p><p>但即便我们好手动连出了一棵完美二叉树，由于各节点之间并没有什么规则，这棵树貌似既不能帮我们完成排序，也无法帮我们完成某种快速检索。 貌似还没什么用……</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.hello-algo.com/chapter_tree/binary_tree_traversal/">hello-algo</a></li><li>《数据结构与算法之美》王争</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止，我们的&lt;code&gt;二叉树&lt;/code&gt;从下层的&lt;code&gt;物理结构&lt;/code&gt;角度来看, 仍然是使用&lt;code&gt;链表&lt;/code&gt;这种最基本的的数据结构进行的存储，因此其遍历方式仍是通过指针逐个访问节点。 &lt;span style=&quot;color:red;&quot;&gt;然而&lt;/span&gt;，从上层的&lt;code&gt;逻辑角度&lt;/code&gt;来看，&lt;code&gt;二叉树&lt;/code&gt;是一种&lt;code&gt;非线性数据结构&lt;/code&gt;，这就使得二叉树(&lt;span style=&quot;color:orange;&quot;&gt;在应用层逻辑上&lt;/span&gt;)的遍历要比遍历链表更加复杂，需要借助搜索算法来实现。&lt;/p&gt;
&lt;p&gt;二叉树常见的遍历方式包括 &lt;code&gt;层序遍历&lt;/code&gt;、&lt;code&gt;前序遍历&lt;/code&gt;、&lt;code&gt;中序遍历&lt;/code&gt; 和 &lt;code&gt;后序遍历&lt;/code&gt; 等。&lt;/p&gt;
&lt;h3 id=&quot;广度优先遍历-–-「层序遍历-level-order-traversal」&quot;&gt;&lt;a href=&quot;#广度优先遍历-–-「层序遍历-level-order-traversal」&quot; class=&quot;headerlink&quot; title=&quot;广度优先遍历 – 「层序遍历 level-order traversal」&quot;&gt;&lt;/a&gt;广度优先遍历 – 「层序遍历 level-order traversal」&lt;/h3&gt;&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。&lt;br&gt;层序遍历本质上属于 &lt;code&gt;「广度优先遍历 breadth-first traversal」&lt;/code&gt; ，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。&lt;/p&gt;
&lt;div style=&quot;display: flex;&quot;&gt;
&lt;img src=&quot;/images/data-structure-algorithm/binary_tree_bfs.png&quot; width=&quot;400px&quot; style=&quot;margin-left:0px;&quot;/&gt;
&lt;img src=&quot;/images/data-structure-algorithm/WX20231114-210129@2x.png&quot; width=&quot;350px&quot; style=&quot;margin-left:10px;border: 1px solid #ccc;border-radius: 5px;&quot;/&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://rymuscle.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
