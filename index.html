<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>rymuscle的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="rymuscle的技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
    
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">rymuscle的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一切美好都如约而至!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> 首页</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> 归档</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> 关于</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> 订阅</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  <article id="post-TCP/05.支撑TCP协议的基石--剖析首部字段" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/25/TCP/05.%E6%94%AF%E6%92%91TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%9F%B3--%E5%89%96%E6%9E%90%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/">05.支撑 TCP 协议的基石 —— 剖析首部字段</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-01-25T14:03:16.000Z" itemprop="datePublished">2022年01月25日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/TCP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">TCP 读书笔记</a>
  </div>

      
      
<a href="/2022/01/25/TCP/05.%E6%94%AF%E6%92%91TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%9F%B3--%E5%89%96%E6%9E%90%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这篇文章来讲讲 TCP 报文首部相关的概念，这些头部是支撑 TCP 复杂功能的基石。 完整的 TCP 头部如下图所示<br><img src="/images/tcp/05/1.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>我们用一次访问百度网页抓包的例子来开始。<br><code>curl -v www.baidu.com</code><br>完整的抓包文件可以来 github 下载：curl_baidu.pcapng<br><img src="/images/tcp/05/2.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<h1 id="源端口号、目标端口号"><a href="#源端口号、目标端口号" class="headerlink" title="源端口号、目标端口号"></a>源端口号、目标端口号</h1><p>在第一个包的详情中，首先看到的高亮部分的源端口号（Src Port）和目标端口号（Dst Port)，这个例子中本地源端口号为 61024，百度目标端口号是 80。<br><img src="/images/tcp/05/3.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>TCP 报文头部里没有源 ip 和目标 ip 地址，只有源端口号和目标端口号</p>
<p>这也是初学 wireshark 抓包时很多人会有的一个疑问：过滤 ip 地址为 172.19.214.24 包的条件为什么不是 “tcp.addr &#x3D;&#x3D; 172.19.214.24”，而是 “ip.addr &#x3D;&#x3D; 172.19.214.24”<br>TCP 的报文里是没有源 ip 和目标 ip 的，因为那是 IP 层协议的事情，TCP 层只有源端口和目标端口。<br><img src="/images/tcp/05/4.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<p>源 IP、源端口、目标 IP、目标端口构成了 TCP 连接的「四元组」。一个四元组可以唯一标识一个连接。</p>
<p>后面文章中专门有一节是用来介绍端口号相关的知识。</p>
<p>接下来，我们看到的是序列号，如截图中 2 的标识。</p>
<h1 id="序列号（Sequence-number）"><a href="#序列号（Sequence-number）" class="headerlink" title="序列号（Sequence number）"></a>序列号（Sequence number）</h1><p>TCP 是面向字节流的协议，通过 TCP 传输的字节流的每个字节都分配了序列号，序列号（Sequence number）指的是本报文段第一个字节的序列号。<br><img src="/images/tcp/05/5.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>序列号加上报文的长度，就可以确定传输的是哪一段数据。序列号是一个 32 位的无符号整数，达到 2^32-1 后循环到 0。</p>
<p>在 SYN 报文中，序列号用于交换彼此的初始序列号，在其它报文中，序列号用于保证包的顺序。</p>
<p>因为网络层（IP 层）不保证包的顺序，TCP 协议利用序列号来解决网络包乱序、重复的问题，以保证数据包以正确的顺序组装传递给上层应用。</p>
<p>如果发送方发送的是四个报文序列号分别是1、2、3、4，但到达接收方的顺序是 2、4、3、1，接收方就可以通过序列号的大小顺序组装出原始的数据。</p>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-TCP/04.来自 Google 的协议栈测试神器 packetdrill" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/24/TCP/04.%E6%9D%A5%E8%87%AA%20Google%20%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%B5%8B%E8%AF%95%E7%A5%9E%E5%99%A8%20packetdrill/">04.来自 Google 的协议栈测试神器 —— packetdrill</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-01-24T13:17:36.000Z" itemprop="datePublished">2022年01月24日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/TCP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">TCP 读书笔记</a>
  </div>

      
      
<a href="/2022/01/24/TCP/04.%E6%9D%A5%E8%87%AA%20Google%20%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%B5%8B%E8%AF%95%E7%A5%9E%E5%99%A8%20packetdrill/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>从大学开始懵懵懂懂粗略学习（死记硬背）了一些 TCP 协议的内容，到工作多年以后，一直没有找到顺手的<code>网络协议栈调试工具</code>，对于纷繁复杂 TCP 协议。<br>业界流行的 scapy 不是很好用，有很多局限性。直到前段时间看到了 Google 开源的 <code>packetdrill</code>，真有一种相见恨晚的感觉。<br>这篇文章讲介绍 packetdrill 的基本原理和用法。</p>
<p>packetdrill 在 2013 年开源，在 Google 内部久经考验，Google 用它发现了 10 余个 Linux 内核 bug，同时用测试驱动开发的方式开发新的网络特性和进行回归测试，确保新功能的添加不影响网络协议栈的可用性。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>以 centos7 为例</p>
<ol>
<li>首先从 github 上 clone 最新的源码 <code>github.com/google/pack…</code></li>
<li>进入源码目录 <code>cd gtests/net/packetdrill</code></li>
<li>安装 bison 和 flex 库：<code>sudo yum install -y bison flex</code></li>
<li>为避免 offload 机制对包大小的影响，修改 netdev.c 注释掉 set_device_offload_flags 函数所有内容</li>
<li>执行 .&#x2F;configure</li>
<li>修改 Makefile，去掉第一行的末尾的 -static</li>
<li>执行 make 命令编译</li>
<li>确认编译无误地生成了 packetdrill 可执行文件</li>
</ol>
<h1 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h1><p>packetdrill 脚本采用 c 语言和 tcpdump 混合的语法。脚本文件名一般以 .pkt 为后缀，执行脚本的方式为 <code>sudo ./packetdrill test.pkt</code></p>
<p>脚本的每一行可以由以下几种类型的语句构成：</p>
<ul>
<li>执行系统调用（system call），对比返回值是否符合预期</li>
<li>把数据包（packet）注入到内核协议栈，模拟协议栈收到包</li>
<li>比较内核协议栈发出的包与预期是否相符</li>
<li>执行 shell 命令</li>
<li>执行 python 命令</li>
</ul>
<p>脚本每一行都有一个时间参数用来表明执行的时间或者预期事件发生的时间，packetdrill 支持绝对时间和相对时间。绝对时间就是一个简单的数字，相对时间会在数字前面添加一个+号。比如下面这两个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 300ms 时执行 accept 调用</span><br><span class="line">0.300 accept(3, ..., ...) = 4</span><br><span class="line"></span><br><span class="line">// 在上一行语句执行结束 10ms 以后执行</span><br><span class="line">+.010 write(4, ..., 1000) = 1000`</span><br></pre></td></tr></table></figure>
<p>如果预期的事件在指定的时间没有发生，脚本执行会抛出异常，由于不同机器的响应时间不同，所以 packetdrill 提供了参数（–tolerance_usecs）用来设置误差范围，默认值是 4000us（微秒），也即 4ms。这个参数默认值在 config.c 的 set_default_config 函数里进行设置config-&gt;tolerance_usecs &#x3D; 4000;</p>
<p>我们以一个最简单的 demo 来演示 packetdrill 的用法。乍一看很懵，容我慢慢道来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 0   socket(..., SOCK_STREAM, IPPROTO_TCP) = 3</span><br><span class="line">2 +0  setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0</span><br><span class="line">3 +0  bind(3, ..., ...) = 0</span><br><span class="line">4 +0  listen(3, 1) = 0</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7 +0  &lt; S 0:0(0) win 4000 &lt;mss 1000&gt;</span><br><span class="line">8 +0  &gt; S. 0:0(0) ack 1 &lt;...&gt;</span><br><span class="line">9 +.1 &lt; . 1:1(0) ack 1 win 1000</span><br><span class="line">10</span><br><span class="line">11 +0 accept(3, ..., ...) = 4</span><br><span class="line">12 +0 &lt; P. 1:201(200) win 4000</span><br><span class="line">13 +0 &gt; . 1:1(0) ack 201</span><br></pre></td></tr></table></figure>
<p>第 1 行：0 socket(…, SOCK_STREAM, IPPROTO_TCP) &#x3D; 3<br>在脚本执行的第 0s 创建一个 socket，使用的是系统调用的方式，socket 函数的签名和用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line"></span><br><span class="line">成功时返回文件描述符，失败时返回 -1</span><br><span class="line">int socket_fd = socket(AF_INET, SOCK_STREAM, 0);</span><br></pre></td></tr></table></figure>
<ul>
<li>domain 表示套接字使用的协议族信息，IPv4、IPv6等。AF_INET 表示 IPv4 协议族，AF_INET6 表示 IPv6 协议族。绝大部分使用场景下都是用 AF_INET，即 IPv4 协议族</li>
<li>type 表示套接字数据传输类型信息，主要分为两种：面向连接的套接字（SOCK_STREAM）和面向无连接报文的套接字（SOCK_DGRAM）。众所周知，SOCK_STREAM 默认协议是 TCP，SOCK_DGRAM 的默认协议是 UDP。</li>
<li>protocol 这个参数通常是 0，表示为给定的协议族和套接字类型选择默认协议。</li>
</ul>
<p>在 packetdrill 脚本中用 … 来表示当前参数省略不相关的细节信息，使用 packetdrill 程序的默认值。</p>
<p>脚本返回新建的 socket 文件句柄，这里用&#x3D;来断言会返回3，因为linux 在每个程序开始的时刻，都会有 3 个已经打开的文件句柄，分别是：标准输入stdin(0)、标准输出stdout(1)、错误输出stderr(2) 默认的，其它新建的文件句柄则排在之后，从 3 开始。</p>
<img src="/images/tcp/04/1.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 +0  setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0</span><br><span class="line">3 +0  bind(3, ..., ...) = 0</span><br><span class="line">4 +0  listen(3, 1) = 0</span><br></pre></td></tr></table></figure>
第 2 行：调用 setsockopt 函数设置端口重用。
第 3 行：调用 bind 函数，这里的 socket 地址省略会使用默认的端口 8080，第一个参数 3 是套接字的 fd
第 4 行：调用 listen 函数，第一个参数 3 也是套接字 fd 到此为止，socket 已经可以接受客户端的 tcp 连接了。
第 7 ~ 9 行是经典的三次握手，packetdrill 的语法非常类似 tcpdump 的语法

<p><code>&lt;</code> 表示输入的数据包（input packets)， packetdrill 会构造一个真实的数据包，注入到内核协议栈。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 构造 SYN 包注入到协议栈</span><br><span class="line">+0  &lt; S 0:0(0) win 32792 &lt;mss 1000,sackOK,nop,nop,nop,wscale 7&gt;</span><br><span class="line">// 构造 icmp echo_reply 包注入到协议栈</span><br><span class="line">0.400 &lt; icmp echo_reply</span><br></pre></td></tr></table></figure>

<p><code>&gt;</code> 表示预期协议栈会响应的包（outbound packets），这个包不是 packetdrill 构造的，是由协议栈发出的，packetdrill 会检查协议栈是不是真的发出了这个包，如果没有，则脚本报错停止执行。比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 调用 write 函数调用以后，检查协议栈是否真正发出了 PSH+ACK 包</span><br><span class="line">+0  write(4, ..., 1000) = 1000</span><br><span class="line">+0  &gt; P. 1:1001(1000) ack 1</span><br><span class="line"></span><br><span class="line">// 三次握手中过程向协议栈注入 SYN 包以后，检查协议栈是否发出了 SYN+ACK 包以及 ack 是否等于 1</span><br><span class="line">0.100 &lt; S 0:0(0) win 32792 &lt;mss 1000,nop,wscale 7&gt;</span><br><span class="line">0.100 &gt; S. 0:0(0) ack 1 &lt;mss 1460,nop,wscale 6&gt;</span><br></pre></td></tr></table></figure>
<img src="/images/tcp/04/2.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>


<p>第 7 行：+0 &lt; S 0:0(0) win 1000 &lt;mss 1000&gt;</p>
<p>packetdrill 构造一个 SYN 包发送到协议栈，它使用与 tcpdump 类似的相对 sequence 序号，S 后面的三个 0 ，分别表示发送包的起始 seq、结束 seq、包的长度。比如P. 1:1001(1000)表示发送的包起始序号为 1，结束 seq 为 1001，长度为1000。紧随其后的 win 表示发送端的接收窗口大小 1000。依据 TCP 协议，SYN 包也必须带上自身的 MSS 选项，这里的 MSS 大小为 1000</p>
<p>第 8 行：+0 &gt; S. 0:0(0) ack 1 &lt;…&gt;</p>
<p>预期协议栈会立刻回复 SYN+ACK 包，因为还没有发送数据，所以包的 seq开始值、结束值、长度都为 0，ack 为上次 seq + 1，表示第一个 SYN 包已收到。</p>
<p>第 9 行：+.1 &lt; . 1:1(0) ack 1 win 1000</p>
<p>0.1s 以后注入一个 ACK 包到协议栈，没有携带数据，包的长度为 0，至此三次握手完成，过程如下图<br><img src="/images/tcp/04/3.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<p>+0 accept(3, …, …) &#x3D; 4 accept 系统调用返回了一个值为 4 的新的文件 fd，这时 packetdrill 可以往这个 fd 里面写数据了</p>
<p>+0 write(4, …, 10)&#x3D;10<br>+0 &gt; P. 1:11(10) ack 1<br>+.1 &lt; . 1:1(0) ack 11 win 1000<br>packetdrill 调用 write 函数往 socket 里写了 10 字节的数据，协议栈立刻发出这 10 个字节数据包，同时把 PSH 标记置为 1。这个包的起始 seq 为 1，结束 seq 为 10，长度为 10。100ms 以后注入 ACK 包，模拟协议栈收到 ACK 包。</p>
<p>整个过程如下<br><img src="/images/tcp/04/4.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>采用 tcpdump 对 8080 端口进行抓包，结果如下</p>
<p>sudo tcpdump -i any port 8080 -nn<br>10:02:36.591911 IP 192.0.2.1.37786 &gt; 192.168.31.139.8080: Flags [S], seq 0, win 4000, options [mss 1000], length 0<br>10:02:36.591961 IP 192.168.31.139.8080 &gt; 192.0.2.1.37786: Flags [S.], seq 2327356581, ack 1, win 29200, options [mss 1460], length 0<br>10:02:36.693785 IP 192.0.2.1.37786 &gt; 192.168.31.139.8080: Flags [.], ack 1, win 1000, length 0<br>10:02:36.693926 IP 192.168.31.139.8080 &gt; 192.0.2.1.37786: Flags [P.], seq 1:11, ack 1, win 29200, length 10<br>10:02:36.801092 IP 192.0.2.1.37786 &gt; 192.168.31.139.8080: Flags [.], ack 11, win 1000, length 0</p>
<h1 id="packetdrill-原理简述"><a href="#packetdrill-原理简述" class="headerlink" title="packetdrill 原理简述"></a>packetdrill 原理简述</h1><p>在脚本的最后一行，加上<br>+0 <code>sleep 1000000</code><br>让脚本执行完不要退出，执行 ifconfig 可以看到，比没有执行脚本之前多了一个虚拟的网卡 tun0。<br><img src="/images/tcp/04/5.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>packetdrill 就是在执行脚本前创建了一个名为 tun0 的虚拟网卡，脚本执行完，tun0 会被销毁。该虚拟网卡对应于操作系统中&#x2F;dev&#x2F;net&#x2F;tun文件，每次程序通过 write 等系统调用将数据写入到这个文件 fd 时，这些数据会经过 tun0 这个虚拟网卡，将数据写入到内核协议栈，read 系统调用读取数据的过程类似。协议栈可以向操作普通网卡一样操作虚拟网卡 tun0。</p>
<p>关于 linux 下 tun 的详细使用介绍，可以参考 IBM 的文章 <a target="_blank" rel="noopener" href="http://www.ibm.com/developerwo%E2%80%A6">www.ibm.com/developerwo…</a></p>
<h1 id="把-packetdrill-命令加到环境变量里"><a href="#把-packetdrill-命令加到环境变量里" class="headerlink" title="把 packetdrill 命令加到环境变量里"></a>把 packetdrill 命令加到环境变量里</h1><p>把 packetdrill 加入到环境变量里以便于可以在任意目录可以执行。第一步是修改&#x2F;etc&#x2F;profile或者.zshrc（如果你用的是最好用的 zsh 的话）等可以修改环境变量的文件。</p>
<p>export PATH&#x3D;&#x2F;path_to_packetdrill&#x2F;:$PATH</p>
<p>source ~&#x2F;.zshrc<br>在命令行中输入 packetdrill 如果有输出 packetdrill 的 usage 文档说明第一步成功啦。</p>
<p>但是 packetdrill 命令是需要 sudo 权限执行的，如果现在我们在命令行中输入sudo packetdrill，会提示找不到 packetdrill 命令</p>
<p>sudo：packetdrill：找不到命令<br>这是因为 sudo 命令为了安全性的考虑，覆盖了用户自己 PATH 环境变量，我们可以用sudo sudo -V | grep PATH 来看</p>
<p>sudo sudo -V | grep  PATH<br>覆盖用户的 $PATH 变量的值：&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin<br>可以看到 sudo 命令覆盖了用户的 PATH 变量。这些初始值是在&#x2F;etc&#x2F;sudoers中定义的</p>
<p>sudo cat &#x2F;etc&#x2F;sudoers | grep -i PATH<br>Defaults    secure_path &#x3D; &#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin<br>一个最简单的办法是在sudo 启动时重新赋值它的 PATH 变量：sudo env PATH&#x3D;”$PATH” cmd_x，可以用sudo env PATH&#x3D;”$PATH” env | grep PATH与sudo env | grep PATH做前后对比</p>
<p>对于本文中的 packetdrill，可以用sudo env PATH&#x3D;$PATH packetdrill delay_ack.pkt来执行，当然你可以做一个 sudo 的 alias</p>
<p>alias sudo&#x3D;’sudo env PATH&#x3D;”$PATH”‘<br>这样就可以在任意地方执行sudo packetdrill了</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>packetdrill 上手的难度有一点大，但是熟悉了以后用起来特别顺手，后面很多 TCP 包超时重传、快速重传、滑动窗口、nagle 算法都是会用这个工具来进行测试，希望你可以熟练掌握。</p>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-TCP/03.TCP概述 -- 可靠的、面向连接的、基于字节流、全双工的协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/23/TCP/03.TCP%E6%A6%82%E8%BF%B0%20--%20%E5%8F%AF%E9%9D%A0%E7%9A%84%E3%80%81%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%81%E5%9F%BA%E4%BA%8E%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%85%A8%E5%8F%8C%E5%B7%A5%E7%9A%84%E5%8D%8F%E8%AE%AE/">03.TCP概述 -- 可靠的、面向连接的、基于字节流、全双工的协议</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-01-23T11:43:20.000Z" itemprop="datePublished">2022年01月23日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/TCP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">TCP 读书笔记</a>
  </div>

      
      
<a href="/2022/01/23/TCP/03.TCP%E6%A6%82%E8%BF%B0%20--%20%E5%8F%AF%E9%9D%A0%E7%9A%84%E3%80%81%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%81%E5%9F%BA%E4%BA%8E%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%85%A8%E5%8F%8C%E5%B7%A5%E7%9A%84%E5%8D%8F%E8%AE%AE/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>如果要用一句话来描述 TCP 协议，我想应该是：TCP 是一个<code>可靠的(reliable)</code>、<code>面向连接的(connection-oriented)</code>、<code>基于字节流(byte-stream)</code>、<code>全双工的(full-duplex)</code> 协议。</p>
<h1 id="TCP-是面向连接的协议"><a href="#TCP-是面向连接的协议" class="headerlink" title="TCP 是面向连接的协议"></a>TCP 是<code>面向连接</code>的协议</h1><p>一开始学习 TCP 的时候，我们就被告知 TCP 是面向连接的协议，那什么是面向连接，什么是无连接呢？</p>
<ul>
<li><code>面向连接(connection-oriented)</code>：面向连接的协议要求正式发送数据之前需要通过「握手」建立一个逻辑连接，结束通信时也是通过有序的四次挥手来断开连接。</li>
<li><code>无连接(connectionless)</code>：无连接的协议则不需要</li>
</ul>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>建立连接的过程是通过「三次握手」来完成的，顾名思义，通过三次数据交换建立一个连接。 通过三次握手协商好双方后续通信的<code>起始序列号</code>、<code>窗口缩放大小</code>等信息。<br><img src="/images/tcp/03/1.awebp" width="400" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<h1 id="TCP-协议是可靠的"><a href="#TCP-协议是可靠的" class="headerlink" title="TCP 协议是可靠的"></a>TCP 协议是可靠的</h1><p>IP 是一种无连接、不可靠的协议：它尽最大可能将数据报从发送者传输给接收者，但并不保证包到达的顺序会与它们被传输的顺序一致，也不保证包是否重复，甚至都不保证包是否会达到接收者。</p>
<p>TCP 要想在 IP 基础上构建可靠的传输层协议，必须有一个复杂的机制来保障可靠性。 主要有下面几个方面：</p>
<ul>
<li>对每个包提供校验和</li>
<li>包的序列号解决了接收数据的乱序、重复问题</li>
<li>超时重传</li>
<li>流量控制、拥塞控制</li>
</ul>
<h2 id="校验和（checksum）"><a href="#校验和（checksum）" class="headerlink" title="校验和（checksum）"></a>校验和（checksum）</h2><p>每个 TCP 包首部中都有两字节用来表示校验和，防止在传输过程中有损坏。如果收到一个校验和有差错的报文，TCP 不会发送任何确认直接丢弃它，等待发送端重传。<br><img src="/images/tcp/03/2.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
<h2 id="包的序列号保证了接收数据的乱序和重复问题"><a href="#包的序列号保证了接收数据的乱序和重复问题" class="headerlink" title="包的序列号保证了接收数据的乱序和重复问题"></a>包的序列号保证了接收数据的乱序和重复问题</h2><p>假设我们往 TCP 套接字里写 3000 字节的数据导致 TCP发送了 3 个数据包，每个数据包大小为 1000 字节：第一个包序列号为[11001)，第二个包序列号为 [10012001)，第三个包序号为[2001~3001)<br><img src="/images/tcp/03/3.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>假如因为网络的原因导致第二个、第三个包先到接收端，第一个包最后才到，接收端也不会因为他们到达的顺序不一致把包弄错，TCP 会根据他们的序号进行重新的排列然后把结果传递给上层应用程序。<br>如果 TCP 接收到重复的数据，可能的原因是超时重传了两次但这个包并没有丢失，接收端会收到两次同样的数据，它能够根据包序号丢弃重复的数据。</p>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>TCP 发送数据后会启动一个定时器，等待对端确认收到这个数据包。如果在指定的时间内没有收到 ACK 确认，就会重传数据包，然后等待更长时间，如果还没有收到就再重传，在多次重传仍然失败以后，TCP 会放弃这个包。<br>后面我们讲到超时重传模块的时候会详细介绍这部分内容。</p>
<h2 id="流量控制、拥塞控制"><a href="#流量控制、拥塞控制" class="headerlink" title="流量控制、拥塞控制"></a>流量控制、拥塞控制</h2><p>这部分内容较复杂，后面有专门的文章进行讲解，这里先不展开。</p>
<h1 id="TCP-是面向字节流的协议"><a href="#TCP-是面向字节流的协议" class="headerlink" title="TCP 是面向字节流的协议"></a>TCP 是面向字节流的协议</h1><p>TCP 是一种字节流（byte-stream）协议，流的含义是没有固定的报文边界。</p>
<p>假设你调用 2 次 write 函数往 socket 里依次写 500 字节、800 字节。write 函数只是把字节拷贝到内核缓冲区，最终会以多少条报文发送出去是不确定的，如下图所示<br><img src="/images/tcp/03/4.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>情况 1：分为两条报文依次发出去 500 字节 和 800 字节数据<br>情况 2：两部分数据合并为一个长度为 1300 字节的报文，一次发送<br>情况 3：第一部分的 500 字节与第二部分的 500 字节合并为一个长度为 1000 字节的报文，第二部分剩下的 300 字节单独作为一个报文发送<br>情况 4：第一部分的 400 字节单独发送，剩下100字节与第二部分的 800 字节合并为一个 900 字节的包一起发送<br>情况 N：还有更多可能的拆分组合</p>
<p>上面出现的情况取决于诸多因素：<code>路径最大传输单元 MTU</code>、<code>发送窗口大小</code>、<code>拥塞窗口大小</code>等。</p>
<p>当接收方从 TCP 套接字读数据时，它是没法得知对方每次写入的字节是多少的。接收端可能分2次每次 650 字节读取，也有可能先分三次，一次 100 字节，一次 200 字节，一次 1000 字节进行读取。</p>
<h1 id="TCP-是全双工的协议"><a href="#TCP-是全双工的协议" class="headerlink" title="TCP 是全双工的协议"></a>TCP 是全双工的协议</h1><p>在 TCP 中发送端和接收端可以是客户端&#x2F;服务端，也可以是服务器&#x2F;客户端，通信的双方在任意时刻既可以是接收数据也可以是发送数据，每个方向的数据流都独立管理<code>序列号</code>、<code>滑动窗口大小</code>、<code>MSS</code> 等信息。</p>
<h1 id="小结与思考"><a href="#小结与思考" class="headerlink" title="小结与思考"></a>小结与思考</h1><p>TCP 是一个可靠的（reliable）、面向连接的（connection-oriented）、基于字节流（byte-stream）、全双工（full-duplex）的协议。发送端在发送数据以后启动一个定时器，如果超时没有收到对端确认会进行重传，接收端利用序列号对收到的包进行排序、丢弃重复数据，TCP 还提供了流量控制、拥塞控制等机制保证了稳定性。<br><img src="/images/tcp/03/5.awebp" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-TCP/02.TCP、IP 历史与分层模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/22/TCP/02.TCP%E3%80%81IP%20%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/">02.TCP/IP 历史与分层模型</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-01-22T11:43:20.000Z" itemprop="datePublished">2022年01月22日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/TCP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">TCP 读书笔记</a>
  </div>

      
      
<a href="/2022/01/22/TCP/02.TCP%E3%80%81IP%20%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        
        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-TCP/01.环境" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/21/TCP/01.%E7%8E%AF%E5%A2%83/">01. 环境</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-01-21T11:43:20.000Z" itemprop="datePublished">2022年01月21日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/TCP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">TCP 读书笔记</a>
  </div>

      
      
<a href="/2022/01/21/TCP/01.%E7%8E%AF%E5%A2%83/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        
        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/23.锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/19/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/23.%E9%94%81/">23. 锁</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-19T14:08:18.000Z" itemprop="datePublished">2021年12月19日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/19/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/23.%E9%94%81/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        
        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/22.undo日志(上)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/22.undo%E6%97%A5%E5%BF%97(%E4%B8%8A)/">22. undo日志(上)</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-15T13:19:56.000Z" itemprop="datePublished">2021年12月15日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/22.undo%E6%97%A5%E5%BF%97(%E4%B8%8A)/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        
        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/22.undo日志(下)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/22.undo%E6%97%A5%E5%BF%97(%E4%B8%8B)/">22. undo日志</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-15T13:19:56.000Z" itemprop="datePublished">2021年12月15日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/22.undo%E6%97%A5%E5%BF%97(%E4%B8%8B)/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        
        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/21.2 redo日志 后续知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/13/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/21.2%20redo%E6%97%A5%E5%BF%97%20%E5%90%8E%E7%BB%AD%E7%9F%A5%E8%AF%86%E7%82%B9/">21.2 redo日志后续知识点</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-13T05:10:27.000Z" itemprop="datePublished">2021年12月13日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/13/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/21.2%20redo%E6%97%A5%E5%BF%97%20%E5%90%8E%E7%BB%AD%E7%9F%A5%E8%AF%86%E7%82%B9/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h1><p>有一个很不幸的事实就是我们的<code>redo日志文件组</code>容量是有限的，我们不得不选择循环使用<code>redo日志文件组</code>中的文件，但是这会造成<span style="font-weight:600;color:#FF416C">最后写的redo日志与最开始写的redo日志追尾</span>。</p>
<p>这时应该想到: redo日志只是为了在系统奔溃后恢复脏⻚用的，如果对应的脏⻚已经刷新到了磁盘，那么即使现在系统奔溃，那么在重启后也用不着使用redo日志恢复该⻚面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。也就是说: 判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是<code>它对应的脏⻚是否已经刷新到磁盘里</code>。</p>
<p>我们看一下前边一直唠叨的那个例子:</p>
<blockquote>
<img src="/images/MySQL/21/17.png" width="550" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
如图，虽然mtr_1和mtr_2生成的redo日志都已经被写到了磁盘上，但是它们修改的脏⻚仍然留在Buffer Pool中，所以它们生成的redo日志在磁盘上的空间是不可以被覆盖的。

<p>之后随着系统的运行，如果⻚a被刷新到了磁盘，那么它对应的控制块就会从flush链表中移除，就像这样子:<br><img src="/images/MySQL/21/18.png" width="550" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>这样mtr_1生成的redo日志就没有用了，这些redo日志占用的磁盘空间就可以被覆盖掉了。</p>
<p>设计InnoDB的大叔提出了一个<code>全局变量 checkpoint_lsn</code> 来代表当前系统中可以被覆盖的redo日志总量是多少，这个变量初始值也是8704。<br>比方说现在⻚a被刷新到了磁盘，mtr_1生成的redo日志就可以被覆盖了，所以我们需要进行一个增加<code>checkpoint_lsn</code>的操作，我们把这个过程称为<code>执行一次checkpoint</code>。<br>执行一次checkpoint其实可 以分为两个步骤:</p>
<ul>
<li>步骤一:计算一下当前系统中可以被覆盖的redo日志对应的lsn值最大是多少。<br>redo日志可以被覆盖，意味着它对应的脏⻚被刷到了磁盘，只要我们计算出当前系统中被最早修改的脏⻚对应的 oldest_modification 值，那凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的，我们就把该脏⻚的oldest_modification赋值给 checkpoint_lsn。<br>比方说当前系统中⻚a已经被刷新到磁盘，那么flush链表的尾节点就是⻚c，该节点就是当前系统中最早修改的脏⻚了， 它的oldest_modification值为8404，我们就把8404赋值给checkpoint_lsn(也就是说在redo日志对应的lsn值小于8404时就可以被覆盖掉)。</li>
<li>步骤二:将checkpoint_lsn和对应的redo日志文件组偏移量以及此次checkpint的编号写到日志文件的管理信息(就是checkpoint1或者checkpoint2)中。<br>设计InnoDB的大叔维护了一个目前系统做了多少次checkpoint的变量checkpoint_no，每做一次checkpoint，该变量的值就加1。我们前边说过计算一个lsn值对应的redo日志文件组偏移量是很容易的，所以可以计算得到该checkpoint_lsn在redo日志文件组中对应的偏移量checkpoint_offset，然后把这三个值都写到redo日志文件组的管理信息中。</li>
</ul>
</blockquote>
<blockquote>
<p>我们说过，每一个redo日志文件都有2048个字节的管理信息，但是上述关于checkpoint的信息只会被写到日志文件组的第一个日志文件的管理信息中。<br>不过它们应该存储到checkpoint1中还是checkpoint2中呢? 设计InnoDB的大叔规定，当checkpoint_no的值是偶数时，就写到checkpoint1中，是奇数时，就写到checkpoint2中。</p>
</blockquote>
<blockquote>
<p>记录完checkpoint的信息之后，redo日志文件组中各个lsn值的关系就像这样:<br><img src="/images/MySQL/21/19.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></p>
</blockquote>
<h1 id="批量从flush链表中刷出脏⻚"><a href="#批量从flush链表中刷出脏⻚" class="headerlink" title="批量从flush链表中刷出脏⻚"></a>批量从flush链表中刷出脏⻚</h1><p>我们在介绍Buffer Pool的时候说过，一般情况下都是后台的线程在对<code>LRU链表</code>和<code>flush链表</code>进行刷脏操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。<br>但是如果当前系统修改⻚面的操作十分频繁，这样就导致写日志操作十分频繁，系统lsn值增⻓过快。 如果后台的刷脏操作不能将脏⻚刷出，那么系统无法及时做checkpoint，可能就需要用户线程同步的从flush链表中把那些最早修改的脏⻚(oldest_modification最小的脏⻚)刷新到磁盘，这样这些脏⻚对应的redo日志就没用了，然后就可以去做checkpoint了。</p>
<h1 id="查看系统中的各种LSN值"><a href="#查看系统中的各种LSN值" class="headerlink" title="查看系统中的各种LSN值"></a>查看系统中的各种LSN值</h1><p>我们可以使用<code>SHOW ENGINE INNODB STATUS</code>命令查看当前InnoDB存储引擎中的各种LSN值的情况，比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line">(...省略前边的许多状态)</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 124476971</span><br><span class="line">Log flushed up to 124099769</span><br><span class="line">Pages flushed up to 124052503</span><br><span class="line">Last checkpoint at 124052494</span><br><span class="line">0 pending log flushes, 0 pending chkp writes 24 log i/o&#x27;s done, 2.00 log i/o&#x27;s/second ----------------------</span><br><span class="line">(...省略后边的许多状态)</span><br></pre></td></tr></table></figure>
<p>其中:<br>Log sequence number: 代表系统中的lsn值，也就是当前 系统已经写入的redo日志量，包括写入log buffer中的日 志。<br>Log flushed up to: 代表flushed_to_disk_lsn的 值，也就是当前系统已经写入磁盘的redo日志量。<br>Pages flushed up to: 代表flush链表中被最早修改的那 个⻚面对应的oldest_modification属性值。<br>Last checkpoint at: 当前系统的checkpoint_lsn值。</p>
<h1 id="innodb-flush-log-at-trx-commit的用法"><a href="#innodb-flush-log-at-trx-commit的用法" class="headerlink" title="innodb_flush_log_at_trx_commit的用法"></a>innodb_flush_log_at_trx_commit的用法</h1><p>我们前边说为了保证事务的持久性，用户线程在事务提交时需要将该事务执行过程中产生的所有redo日志都刷新到磁盘上。这一条要求太狠了，会很明显的降低数据库性能。</p>
<p>如果有的同学对事务的持久性要求不是那么强烈的话，可以选择修改一个名为<code>innodb_flush_log_at_trx_commit</code>的系统变量的值，该变量有3个可选的值:</p>
<ul>
<li>0: 当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步redo日志，这个任务是交给后台线程做的。<br>这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将redo日志刷新到磁盘，那么该事务对⻚面的修改会丢失。</li>
<li>1: 当该系统变量值为0时，表示在事务提交时需要将redo日志同步到磁盘，可以保证事务的持久性。1也是默认值。</li>
<li>2: 当该系统变量值为0时，表示在事务提交时需要将redo日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。<br>这种情况下如果数据库挂了，操作系统没挂的话，事务的持久性还是可以保证的，但是操作系统也挂了的话，那就不能保证持久性了。</li>
</ul>
<h1 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h1><p>在服务器不挂的情况下，redo日志简直就是个大累赘，不仅没用，反而让性能变得更差。<br>但是万一数据库挂了，那redo日志可是个宝了，我们就可以在重启时根据redo日志中的记录就可以将⻚面恢复到系统奔溃前的状态。<br>接下来大致看一下恢复过程是个啥样。</p>
<h2 id="确定恢复的起点"><a href="#确定恢复的起点" class="headerlink" title="确定恢复的起点"></a>确定恢复的起点</h2><p>我们前边说过，<code>checkpoint_lsn</code>之前的redo日志都可以被覆盖， 也就是说这些redo日志对应的脏⻚都已经被刷新到磁盘中了，既然它们已经被刷盘，我们就没必要恢复它们了。<br>对于 <code>checkpoint_lsn</code> 之后的redo日志，它们对应的脏⻚可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要从 <code>checkpoint_lsn</code> 开始读取redo日志来恢复⻚面。<br>当然，redo日志文件组的第一个文件的管理信息中有两个block都存储了checkpoint_lsn的信息，我们当然是要选取最近发生的那次checkpoint的信息。衡量checkpoint发生时间早晚的信息就是所谓的<code>checkpoint_no</code>，我们只要把checkpoint1和checkpoint2这两个block中的checkpoint_no值读出来比一下大小，哪个的 checkpoint_no值更大，说明哪个block存储的就是最近的一次checkpoint信息。这样我们就能拿到最近发生的checkpoint对应的checkpoint_lsn值以及它在redo日志文件组中的偏移量 checkpoint_offset。</p>
<h2 id="确定恢复的终点"><a href="#确定恢复的终点" class="headerlink" title="确定恢复的终点"></a>确定恢复的终点</h2><p>redo日志恢复的起点确定了，那终点是哪个呢?这个还得从block的结构说起。我们说在写redo日志的时候都是顺序写的，写满了一个 block之后会再往下一个block中写:</p>
<blockquote>
<img src="/images/MySQL/21/20.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
普通block的`log block header`部分有一个名为`LOG_BLOCK_HDR_DATA_LEN`的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为512。如果该属性的值不为512，那么就是它了，它就是此次奔溃恢复中需要扫描的最后一个block。
</blockquote>
<h2 id="怎么恢复"><a href="#怎么恢复" class="headerlink" title="怎么恢复"></a>怎么恢复</h2><p>确定了需要扫描哪些redo日志进行奔溃恢复之后，接下来就是怎么进行恢复了。假设现在的redo日志文件中有5条redo日志，如图:</p>
<blockquote>
<img src="/images/MySQL/21/21.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
</blockquote>
<p>由于redo 0在checkpoint_lsn后边，恢复时可以不管它。我们现在可以按照redo日志的顺序依次扫描checkpoint_lsn之后的各条redo日志，按照日志中记载的内容将对应的⻚面恢复出来。这样没什么问题，不过设计InnoDB的大叔还是想了一些办法加快这个恢复的过程:</p>
<ul>
<li><p>使用哈希表<br>根据redo日志的space ID和page number属性计算出散列值，把space ID和page number相同的redo日志放到哈希表的同一个槽里，如果有多个space ID和page number都相同的redo日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，如图所示:</p>
<blockquote>
<img src="/images/MySQL/21/22.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
之后就可以遍历哈希表，因为对同一个⻚面进行修改的redo日志都放在了一个槽里，所以可以一次性将一个⻚面修复好(避免了很多读取⻚面的随机IO)，这样可以加快恢复速度。另外需要注意一点的是，同一个⻚面的redo日志是按照生成时间顺序进行排序的，所以恢复的时候也是按照这个顺序进行恢复， 如果不按照生成时间顺序进行排序的话，那么可能出现错误。 比如原先的修改操作是先插入一条记录，再删除该条记录，如果恢复时不按照这个顺序来，就可能变成先删除一条记录，再插入一条记录，这显然是错误的。
</blockquote>
</li>
<li><p>跳过已经刷新到磁盘的⻚面<br>我们前边说过，checkpoint_lsn之前的redo日志对应的脏⻚确定都已经刷到磁盘了，但是checkpoint_lsn之后的redo日志我们不能确定是否已经刷到磁盘，主要是因为在最近做的一次checkpoint后，可能后台线程又不断的从LRU链表和flush链表中将一些脏⻚刷出Buffer Pool。这些在checkpoint_lsn之后的redo日志，如果它们对应的脏⻚在奔溃发生时已经刷新到磁盘，那在恢复时也就没有必要根据redo日志的内容修改该⻚面了。</p>
</li>
</ul>
<p>那在恢复时怎么知道某个redo日志对应的脏⻚是否在奔溃发生时已经刷新到磁盘了呢?这还得从⻚面的结构说起，我们前边说过每个⻚面都有一个称之为File Header的部分，在File Header里有一个称之为FIL_PAGE_LSN的属性，该属性记载了最近一次修改⻚面时对应的lsn值(其实就是⻚面控制块中 的newest_modification值)。如果在做了某次checkpoint之后有脏⻚被刷新到磁盘中，那么该⻚对应的 FIL_PAGE_LSN代表的lsn值肯定大于checkpoint_lsn的值，凡是符合这种情况的⻚面就不需要做恢复操作了，所以更进一步提升了奔溃恢复的速度。</p>
<h1 id="遗漏的问题-LOG-BLOCK-HDR-NO是如何计算的"><a href="#遗漏的问题-LOG-BLOCK-HDR-NO是如何计算的" class="headerlink" title="遗漏的问题:LOG_BLOCK_HDR_NO是如何计算的"></a>遗漏的问题:LOG_BLOCK_HDR_NO是如何计算的</h1><p>我们前边说过，对于实际存储redo日志的普通的log block来说， 在log block header处有一个称之为LOG_BLOCK_HDR_NO的属 性(忘记了的话回头再看看哈)，我们说这个属性代表一个唯一的标 号。这个属性是初次使用该block时分配的，跟当时的系统lsn值有 关。使用下边的公式计算该block的LOG_BLOCK_HDR_NO值:<br><code>((lsn / 512) &amp; 0x3FFFFFFFUL) + 1</code></p>
<p>这个公式里的0x3FFFFFFFUL可能让大家有点困惑，其实它的二进 制表示可能更亲切一点:</p>
<blockquote>
<img src="/images/MySQL/21/23.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
从图中可以看出，0x3FFFFFFFUL对应的二进制数的前2位为0，后 30位的值都为1。我们刚开始学计算机的时候就学过，一个二进制位 与0做与运算(&)的结果肯定是0，一个二进制位与1做与运算 (&)的结果就是原值。让一个数和0x3FFFFFFFUL做与运算的意思 就是要将该值的前2个比特位的值置为0，这样该值就肯定小于或等 于0x3FFFFFFFUL了。这也就说明了，不论lsn多大，((lsn / 512) & 0x3FFFFFFFUL)的值肯定在0~0x3FFFFFFFUL之间，再 加1的话肯定在1~0x40000000UL之间。而0x40000000UL这个值 大家应该很熟悉，这个值就代表着1GB。也就是说系统最多能产生不 重复的LOG_BLOCK_HDR_NO值只有1GB个。设计InnoDB的大叔规定 redo日志文件组中包含的所有文件大小总和不得超过512GB，一个 block大小是512字节，也就是说redo日志文件组中包含的block块 最多为1GB个，所以有1GB个不重复的编号值也就够用了。
另外，LOG_BLOCK_HDR_NO值的第一个比特位比较特殊，称之 为flush bit，如果该值为1，代表着本block是在某次将log buffer中的block刷新到磁盘的操作中的第一个被刷入的block。
</blockquote>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-MySQL知识点整理/21.1 Log Sequeue Number" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/12/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/21.1%20Log%20Sequeue%20Number/">21.1 Log Sequeue Number</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-12-12T14:19:04.000Z" itemprop="datePublished">2021年12月12日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a>
  </div>

      
      
<a href="/2021/12/12/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/21.1%20Log%20Sequeue%20Number/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Log-Sequeue-Number"><a href="#Log-Sequeue-Number" class="headerlink" title="Log Sequeue Number"></a>Log Sequeue Number</h1><p>自系统开始运行，就在不断地修改⻚面，这也就意味着会不断的生成redo日志。redo日志的量在不断的递增，就像人的年龄一样，自打出生起就不断递增，永远不可能缩减。</p>
<p>设计InnoDB的大叔设计了一个名为<code>Log Sequeue Number</code>的<code>全局变量</code>(<code>日志序列号</code>，简称<code>lsn</code>)，用来记录当前总共已经写入的redo日志量。 不过不像人一出生的年龄是0岁，设计InnoDB的大叔规定初始的lsn值为8704(人家就这么规定的,也就是一条redo日志也没写入时，lsn的值就是8704)。</p>
<p>我们知道在向<code>log buffer</code>中写入<code>redo日志</code>时不是一条一条写入的，而是以<code>mtr</code>生成的<code>一组redo日志</code>为单位进行写入的。而且实际上是把日志内容写在了<code>log blcok body</code>处。<br>但是在统计<code>lsn</code>的增⻓量时，是按照实际写入的日志量加上占用的<code>log block header</code>和<code>log block trailer</code>来计算的。我们来看一个例子:</p>
<ul>
<li>系统第一次启动后初始化<code>log buffer</code>时，<code>buf_free</code>(就是标记下一条redo日志应该写入到log buffer的位置的变量) 就会指向第一个block的偏移量为12字节(log block header的大小)的地方，那么lsn值也会跟着增加12:<blockquote>
<img src="/images/MySQL/21/6.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></blockquote>
</li>
<li>如果某个mtr产生的一组redo日志占用的存储空间比较小，也就是待插入的block剩余空闲空间能容纳这个mtr提交的日志时，lsn增⻓的量就是该mtr生成的redo日志占用的字节数， 就像这样<blockquote>
<img src="/images/MySQL/21/7.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
我们假设上图中mtr_1产生的redo日志量为200字节，那么lsn就要在8716的基础上增加200，变为8916。</blockquote>
</li>
<li>如果某个mtr产生的一组redo日志占用的存储空间比较大，也就是待插入的block剩余空闲空间不足以容纳这个mtr提交的日志时，lsn增⻓的量就是该mtr生成的redo日志占用的字节数加上额外占用的<code>log block header</code>和<code>log block trailer</code>的字节数，就像这样:<blockquote>
<img src="/images/MySQL/21/8.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
我们假设上图中mtr_2产生的redo日志量为1000字节，为了将mtr_2产生的redo日志写入log buffer，我们不得不额外多分配两个block，所以lsn的值需要在8916的基础上增加 1000 + 12×2 + 4 × 2 = 1032。</blockquote>
</li>
</ul>
<p>从上边的描述中可以看出来，<strong>每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</strong></p>
<h1 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h1><p><code>redo日志</code>是先写到<code>Log buffer</code>中，之后才会被刷新到磁盘的<code>redo日志文件</code>中。所以设计InnoDB的大叔提出了一个名为<code>buf_next_to_write</code>的全局变量，用来标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。如下图:</p>
<blockquote>
<img src="/images/MySQL/21/9.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
</blockquote>
<p>我们前边说<code>lsn</code>是表示当前系统中写入的redo日志量，这包括了写到log buffer而没有刷新到磁盘的日志。<br>相应的，设计InnoDB的大叔提出了一个表示刷新到磁盘中的redo日志量的全局变量，名为<code>flushed_to_disk_lsn</code>。 </p>
<p>系统第一次启动时，该变量的值和初始的lsn值是相同的，都是8704。<br>随着系统的运行，<code>redo日志</code>被不断写入<code>log buffer</code>，但是并不会立即刷新到磁盘，<code>lsn</code>的值 就和 <code>flushed_to_disk_lsn</code> 的值拉开了差距。我们演示一下:</p>
<ul>
<li>系统第一次启动后，向log buffer中写入了 mtr_1、mtr_2、mtr_3这三个mtr产生的redo日志，假设这三个mtr开始和结束时对应的lsn值分别是: <code>mtr_1:8716 ~ 8916</code>、 <code>mtr_2:8916 ~ 9948</code>、 <code>mtr_3:9948 ~ 10000</code><br>此时的lsn已经增⻓到了10000，但是由于没有刷新操作，所以此时flushed_to_disk_lsn的值仍为8704，如图:<blockquote>
<img src="/images/MySQL/21/10.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></blockquote>
</li>
<li>随后进行将log buffer中的block刷新到redo日志文件的操作，假设将mtr_1和mtr_2的日志刷新到磁盘，那么flushed_to_disk_lsn就应该增⻓mtr_1和mtr_2写入的日志量，所以flushed_to_disk_lsn的值增⻓到了9948， 如图:<blockquote>
<img src="/images/MySQL/21/11.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></blockquote>
</li>
</ul>
<p>综上所述，当有新的redo日志写入到log buffer时，首先lsn的值会增⻓，但flushed_to_disk_lsn不变，随后随着不断有log buffer中的日志被刷新到磁盘上，flushed_to_disk_lsn的值也跟着增⻓。如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。</p>
<h1 id="lsn值和redo日志文件偏移量的对应关系"><a href="#lsn值和redo日志文件偏移量的对应关系" class="headerlink" title="lsn值和redo日志文件偏移量的对应关系"></a>lsn值和redo日志文件偏移量的对应关系</h1><p>因为lsn的值是代表系统写入的redo日志量的一个总和，一个mtr中产生多少日志，lsn的值就增加多少(当然有时候要加上log block header和log block trailer的大小)，这样mtr产生的日志写到磁盘中时，很容易计算某一个lsn值在redo日志文件组中的偏移量，如图:</p>
<blockquote>
<img src="/images/MySQL/21/12.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
初始时的LSN值是8704，对应文件偏移量2048，之后每个mtr向磁盘中写入多少字节日志，lsn的值就增⻓多少。
</blockquote>
<h1 id="flush链表中的LSN"><a href="#flush链表中的LSN" class="headerlink" title="flush链表中的LSN"></a>flush链表中的LSN</h1><p>我们知道一个mtr代表一次对底层⻚面的原子访问，在访问过程中可能会产生一组不可分割的redo日志，在mtr结束时，会把这一组redo日志写入到<code>log buffer</code>中。除此之外，在mtr结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的⻚面加入到Buffer Pool的flush链表。</p>
<blockquote>
<p>为了防止大家早已忘记flush链表是个啥，我们再看一下图:<br><img src="/images/MySQL/21/13.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/><br>当第一次修改某个缓存在Buffer Pool中的⻚面时，就会把这个⻚面对应的控制块插入到flush链表的头部，之后再修改该⻚面时由于 它已经在flush链表中了，就不再次插入了。也就是说flush链表中的脏⻚是按照⻚面的第一次修改时间从大到小进行排序的。在这个过程中会在缓存⻚对应的控制块中记录两个关于⻚面何时修改的属性:</p>
<ul>
<li><code>oldest_modification</code>：如果某个⻚面被加载到Buffer Pool后进行第一次修改，那么就将修改该⻚面的mtr开始时对应的lsn值写入这个属性。</li>
<li><code>newest_modification</code>：每修改一次⻚面，都会将修改该⻚面的mtr结束时对应的lsn值写入这个属性。也就是说该属性表示⻚面最近一次修改后对应的系统lsn值。</li>
</ul>
</blockquote>
<blockquote>
<p>我们接着上边唠叨flushed_to_disk_lsn的例子看一下:</p>
<ul>
<li>假设mtr_1执行过程中修改了⻚a，那么在mtr_1执行结束时，就会将⻚a对应的控制块加入到flush链表的头部。并且将mtr_1开始时对应的lsn，也就是8716写入⻚a对应的控制块的oldest_modification属性中，把mtr_1结束时对应的lsn，也就是8404写入⻚a对应的控制块的newest_modification属性中。<br>画个图表示一下(为了让图 片美观一些，我们把oldest_modification缩写成了o_m， 把newest_modification缩写成了n_m):<img src="/images/MySQL/21/14.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></li>
<li>接着假设mtr_2执行过程中又修改了⻚b和⻚c两个⻚面，那么在mtr_2执行结束时，就会将⻚b和⻚c对应的控制块都加入到flush链表的头部。并且将mtr_2开始时对应的lsn，也就是8404写入⻚b和⻚c对应的控制块的oldest_modification属性中，把mtr_2结束时对应的lsn，也就是9436写入⻚b和⻚c对应的控制块的newest_modification属性中。<br>画个图表示一下:<img src="/images/MySQL/21/15.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/>
从图中可以看出来，每次新插入到flush链表中的节点都是被放在了头部，也就是说flush链表中前边的脏⻚修改的时间比较晚，后边的脏⻚修改时间比较早。</li>
<li>接着假设mtr_3执行过程中修改了⻚b和⻚d，不过⻚b之前已经被修改过了，所以它对应的控制块已经被插入到了flush链表，所以在mtr_3执行结束时，只需要将⻚d对应的控制块都加入到flush链表的头部即可。所以需要将mtr_3开始时对应的lsn，也就是9436写入⻚c对应的控制块的oldest_modification属性中，把mtr_3结束时对应的lsn，也就是10000写入⻚c对应的控制块的newest_modification属性中。另外，由于⻚b在mtr_3执行过程中又发生了一次修改，所以需要更新⻚b对应的控制块中newest_modification的值为10000。<br>画个图表示一下:<img src="/images/MySQL/21/16.png" width="500" style="margin-left:0px;border: 1px solid #ccc;border-radius: 5px;"/></li>
</ul>
</blockquote>
<p>总结一下上边说的，就是:flush链表中的脏⻚按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的⻚面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</p>

        
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>



    <nav id="page-nav">

<span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
</nav>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> 最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/25/TCP/05.%E6%94%AF%E6%92%91TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%9F%B3--%E5%89%96%E6%9E%90%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/">05.支撑 TCP 协议的基石 —— 剖析首部字段</a>
          </li>
        
          <li>
            <a href="/2022/01/24/TCP/04.%E6%9D%A5%E8%87%AA%20Google%20%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%B5%8B%E8%AF%95%E7%A5%9E%E5%99%A8%20packetdrill/">04.来自 Google 的协议栈测试神器 —— packetdrill</a>
          </li>
        
          <li>
            <a href="/2022/01/23/TCP/03.TCP%E6%A6%82%E8%BF%B0%20--%20%E5%8F%AF%E9%9D%A0%E7%9A%84%E3%80%81%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%81%E5%9F%BA%E4%BA%8E%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%85%A8%E5%8F%8C%E5%B7%A5%E7%9A%84%E5%8D%8F%E8%AE%AE/">03.TCP概述 -- 可靠的、面向连接的、基于字节流、全双工的协议</a>
          </li>
        
          <li>
            <a href="/2022/01/22/TCP/02.TCP%E3%80%81IP%20%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/">02.TCP/IP 历史与分层模型</a>
          </li>
        
          <li>
            <a href="/2022/01/21/TCP/01.%E7%8E%AF%E5%A2%83/">01. 环境</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CAS/" style="font-size: 10px;">CAS</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/MySQL/" style="font-size: 20px;">MySQL</a> <a href="/tags/TCP/" style="font-size: 17.5px;">TCP</a> <a href="/tags/%E4%B8%8D%E8%A6%81-select/" style="font-size: 12.5px;">不要 select*</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> 分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">0</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">MySQL 读书笔记</a><span class="category-list-count">58</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSO/">SSO</a><span class="category-list-count">0</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">TCP 读书笔记</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">0</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">0</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> 归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022年</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年</a><span class="archive-list-count">58</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/" rel="tag">CAS</a><span class="tag-list-count">0</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">58</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8D%E8%A6%81-select/" rel="tag">不要 select*</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">0</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">0</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">网站地图</a>
        <span> | </span><a href="/atom.xml">订阅本站</a>
        <span> | </span><a href="/about/">联系博主</a>
      </p>
      
      <p>
        <span>Copyright &copy; 2024 Rymuscle.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>




<script src="/js/script.js"></script>












  



  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>
  <script src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async type="text/javascript"></script>

</body>
</html>