[{"title":"二叉树遍历","date":"2020-10-27T13:52:36.000Z","path":"2020/10/27/data-structure-algorithm/10-3.binary-tree/","text":"到目前为止，我们的二叉树从下层的物理结构角度来看, 仍然是使用链表这种最基本的的数据结构进行的存储，因此其遍历方式仍是通过指针逐个访问节点。 然而，从上层的逻辑角度来看，二叉树是一种非线性数据结构，这就使得树的遍历要比遍历链表更加复杂，需要借助搜索算法来实现。 二叉树常见的遍历方式包括 层序遍历、前序遍历、中序遍历 和 后序遍历 等。 「层序遍历 level-order traversal」原理从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。层序遍历本质上属于 「广度优先遍历 breadth-first traversal」 ，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。 代码广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。 1 前序遍历中序遍历后序遍历参考文献 hello-algo 《数据结构与算法之美》王争y_tree.png” width&#x3D;”450px” style&#x3D;”margin-left:0px;”&#x2F;&gt; 前序遍历中序遍历后序遍历参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"常见二叉树类型","date":"2020-10-27T13:23:19.000Z","path":"2020/10/27/data-structure-algorithm/10-2.binary-tree/","text":"「完美二叉树 perfect binary tree」所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 0，其余所有节点的度都为 2；若树高度为 h，则节点总数为 $2^{h+1}-1$ 。呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。 「完全二叉树 complete binary tree」只有最底层的节点未被填满，且最底层节点尽量靠左填充。 「完满二叉树 full binary tree」除了叶节点之外，其余所有节点都有两个子节点 「平衡二叉树 balanced binary tree」任意节点的左子树和右子树的高度之差的绝对值不超过 1 二叉树的退化当二叉树的每层节点都被填满时，达到 完美二叉树，完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。而当所有节点都偏向一侧时，二叉树退化为 链表，链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n)。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「二叉树 binary tree」","date":"2020-10-27T12:15:32.000Z","path":"2020/10/27/data-structure-algorithm/10-1.binary-tree/","text":"认识二叉树 「二叉树 binary tree」是一种非线性数据结构，体现着“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。 常见术语12345678根节点 root node」：位于二叉树顶层的节点，没有父节点。「叶节点 leaf node」：没有子节点的节点，其两个指针均指向。「边 edge」：连接两个节点的线段，即节点引用（指针）。节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。节点的「深度 depth」：从根节点到该节点所经过的边的数量。节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。 二叉树 (链表存储) 基本操作初始化二叉树 从二叉树的结构图来看，它的节点和链表的节点非常像，因此用链表来存储二叉树也挺顺理成章的 😝。 其实初始化二叉树的过程和初始化一个链表没什么区别(将一些节点用指针串联起来)。只不过串联的逻辑稍有不同。 1234567891011// 初始化节点TreeNode n1 = new TreeNode(1);TreeNode n2 = new TreeNode(2);TreeNode n3 = new TreeNode(3);TreeNode n4 = new TreeNode(4);TreeNode n5 = new TreeNode(5);// 构建引用指向（即指针）n1.left = n2;n1.right = n3;n2.left = n4;n2.right = n5; 这棵二叉树的逻辑结构如下： 当然，对于上面的多个节点，你有多种不同的连接方式，将它们连成多种不同的二叉树： 插入、删除 节点与链表类似， 在二叉树中 插入、删除节点 ，可以通过修改指针来实现 123456TreeNode P = new TreeNode(0);// 在 n1 -&gt; n2 中间插入节点 Pn1.left = P;P.left = n2;// 删除节点 Pn1.left = n2; 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构分类","date":"2020-10-11T12:15:32.000Z","path":"2020/10/11/data-structure-algorithm/01.dataStructure-type/","text":"数据结构分类数据结构可以从两个维度分为： 逻辑结构 和 物理结构。 逻辑结构 揭示了数据元素之间的逻辑关系，是抽象意义上的结构（也是我们后面重点关注和讨论的）； 物理结构 则反映了 按一定逻辑结构组成的数据元素 在计算机内存中真正的存储结构；在算法运行过程中，相关数据都存储在内存中, 这些数据的存储方式可分为 连续空间存储（数组） 和 分散空间存储（链表） 逻辑结构 逻辑结构 又可被分为 线性 和 非线性 两大类 线性结构比较直观，指数据在逻辑关系上呈线性排列；如：数组、链表、栈、队列、哈希表。 非线性结构则相反，呈非线性排列。如：树、堆、图、哈希表。 所有数据结构都是基于 数组、链表 或二者的组合实现的，例如 基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度&gt;&#x3D;3的数组）等。基于链表可实现：栈、队列、哈希表、树、堆、图等。 lant: 数组 和 链表这两种逻辑数据结构，对应了内存上的两个最基本的物理存储结构 连续存储、分散存储，因此 数组 和 链表是最基本的逻辑数据结构，其他更为复杂的逻辑数据结构要使用哪种物理结构进行存储时，都需要基于这两个最基础的逻辑数据结构进行选择。 可以简单认为，对于一组数据，无论它们逻辑上是用哪种结构组合起来的。它们最终在物理介质上都是两种存储方式 连续存储、分散存储。 而这两种物理存储方式对应了最基础的两个数据结构 数组、链表。 所以无论你的数据是哪种逻辑结构的组合，最终也要选择基于什么样的物理结构进行存储，而 数组 和 链表 这两种基础数据结构分别对应了不同的物理存储结构。 如，下图中对于 堆 这种数据结构(逻辑上的)，可以采用 链表 或 数组 两种不同的 数据结构(物理上的) 进行存储。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}]