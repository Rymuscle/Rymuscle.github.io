[{"title":"二叉查找树","date":"2020-10-28T13:35:43.000Z","path":"2020/10/28/data-structure-algorithm/10-5.bst/","text":"前言说到二叉查找树，从名字你也能看出这种数据结构是用二叉树来做快速查找的。 事实上二叉搜索树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。而我们之前学过的散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。既然有了这么高效的散列表，还要二叉查找树干啥？有没有哪些地方是散列表做不了，必须要用二叉查找树来做的呢？ 带着这些问题，我们就来学习今天的内容，二叉查找树！ 二叉搜索树 binary search tree」","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"用数组表示(存储)二叉树","date":"2020-10-28T12:57:19.000Z","path":"2020/10/28/data-structure-algorithm/10-4.binary-tree/","text":"之前我们的二叉树是使用链表这种最基本的数据结构来存储的（链式存储）。 而本篇我们将使用数组这种最基本的结构来存储二叉树（顺序存储）。 尝试用数组存储一棵二叉树 如果将根节点A存储在下标 i = 1 的位置，那左子节点B会存储在下标 2 * i = 2 的位置，右子节点C会存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点D会存储在 2 * i = 2 * 2 = 4 的位置，右子节点E存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。……最终的二叉树和数组的对应关系如下图:总结一下，就是，如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是它的左子节点，下标为 2 * i + 1 的位置存储的就是它的右子节点。反过来，下标为 i&#x2F;2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。 比较遗憾的是，刚刚我们举的例子是将一棵完全二叉树存储到了数组中，为了方便通过下标计算树中各节点位置，所以“浪费”了一个下标为 0 的存储位置。但如果我们往数组中存储的是一棵非完全二叉树，那就会浪费比较多的数组存储空间了。 可以看到，我们为了使 根节点下标为i, 左子节点下标为2 * i, 右子节点下标为 2 * i + 1 这个公式来仍然生效(方便计算各节点位置从而串起整棵树)，就不得不将一些None节点的位置也在数组中留出来。 这样就会浪费比较多的数组存储空间。 以下代码实现了一个基于数组表示的二叉树，包括以下几种操作 给定某节点，获取它的值、左（右）子节点、父节点。 获取前序遍历、中序遍历、后序遍历、层序遍历序列。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 数组表示下的二叉树类 */class ArrayBinaryTree &#123; private List&lt;Integer&gt; tree; /* 构造方法 */ public ArrayBinaryTree(List&lt;Integer&gt; arr) &#123; tree = new ArrayList&lt;&gt;(arr); &#125; /* 节点数量 */ public int size() &#123; return tree.size(); &#125; /* 获取索引为 i 节点的值 */ public Integer val(int i) &#123; // 若索引越界，则返回 null ，代表空位 if (i &lt; 0 || i &gt;= size()) return null; return tree.get(i); &#125; /* 获取索引为 i 节点的左子节点的索引 */ public Integer left(int i) &#123; return 2 * i + 1; &#125; /* 获取索引为 i 节点的右子节点的索引 */ public Integer right(int i) &#123; return 2 * i + 2; &#125; /* 获取索引为 i 节点的父节点的索引 */ public Integer parent(int i) &#123; return (i - 1) / 2; &#125; /* 层序遍历 */ public List&lt;Integer&gt; levelOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 直接遍历数组 for (int i = 0; i &lt; size(); i++) &#123; if (val(i) != null) res.add(val(i)); &#125; return res; &#125; /* 深度优先遍历 */ private void dfs(Integer i, String order, List&lt;Integer&gt; res) &#123; // 若为空位，则返回 if (val(i) == null) return; // 前序遍历 if (order == &quot;pre&quot;) res.add(val(i)); dfs(left(i), order, res); // 中序遍历 if (order == &quot;in&quot;) res.add(val(i)); dfs(right(i), order, res); // 后序遍历 if (order == &quot;post&quot;) res.add(val(i)); &#125; /* 前序遍历 */ public List&lt;Integer&gt; preOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(0, &quot;pre&quot;, res); return res; &#125; /* 中序遍历 */ public List&lt;Integer&gt; inOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(0, &quot;in&quot;, res); return res; &#125; /* 后序遍历 */ public List&lt;Integer&gt; postOrder() &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(0, &quot;post&quot;, res); return res; &#125;&#125; lant: 所以，其实二叉树中，也就完全二叉树比较适合用 数组来存储。 因为如果一棵二叉树是一棵完全二叉树，那它用数组存储就会非常节省空间，它不需要像链式存储那样要存储额外的左右子节点的指针。这也是为什么完全二叉树要求最后一层的子节点都靠左的原因，因为右边的None节点会一起排在数组的末尾，可以直接省略，也不影响 数组存储二叉树的公式 计算。 优势与局限性二叉树的数组表示主要有以下优点： 数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。 不需要存储指针，比较节省空间。 允许随机访问节点。 然而，数组表示也存在一些局限性： 数组存储需要连续内存空间，因此不适合存储数据量过大的树。 增删节点需要通过数组插入与删除操作实现，效率较低。 当二叉树中存在大量None时，数组中包含的节点数据比重较低，空间利用率较低。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二叉树遍历","date":"2020-10-27T13:52:36.000Z","path":"2020/10/27/data-structure-algorithm/10-3.binary-tree/","text":"到目前为止，我们的二叉树从下层的物理结构角度来看, 仍然是使用链表这种最基本的的数据结构进行的存储，因此其遍历方式仍是通过指针逐个访问节点。 然而，从上层的逻辑角度来看，二叉树是一种非线性数据结构，这就使得二叉树(在应用层逻辑上)的遍历要比遍历链表更加复杂，需要借助搜索算法来实现。 二叉树常见的遍历方式包括 层序遍历、前序遍历、中序遍历 和 后序遍历 等。 广度优先遍历 – 「层序遍历 level-order traversal」原理从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。层序遍历本质上属于 「广度优先遍历 breadth-first traversal」 ，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。 代码仔细看上图的 广度优先遍历 方式，你会发现它遍历节点时，节点出现的方式 和 队列的“先进先出”规则很像，因此广度优先遍历也通常借助“队列”来实现 1234567891011121314151617/* 层序遍历 */List&lt;Integer&gt; levelOrder(TreeNode root) &#123; // 初始化队列，加入根节点 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); // 初始化一个列表，用于保存遍历序列 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); // 队列出队 list.add(node.val); // 保存节点值 if (node.left != null) queue.offer(node.left); // 左子节点入队 if (node.right != null) queue.offer(node.right); // 右子节点入队 &#125; return list;&#125; 时间复杂度O(n)：所有节点被访问一次，使用 O(n) 时间，其中 n 为节点数量。空间复杂度O(n)：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 (n+1)/2 个节点，占用 O(n) 空间。二叉树的层数越往下，每层的节点越多，所以 只有二叉树是满二叉树时，最底层的节点数会达到最大。此时，当最底层节点(叶子节点)全部放入队列时，也是队列占用空间最大时。此时叶子结点数量为 (n+1)/2 深度优先遍历 - 前、中、后 序遍历原理 “前序”、”中序”、”后序” 是基于遍历时 “根节点” 的顺序来说的。前序：根在前；中序：根在中；后序：根在后; 代码1234567891011121314151617181920212223242526272829/* 前序遍历 */void preOrder(TreeNode root) &#123; if (root == null) return; // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树 list.add(root.val); preOrder(root.left); preOrder(root.right);&#125;/* 中序遍历 */void inOrder(TreeNode root) &#123; if (root == null) return; // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树 inOrder(root.left); list.add(root.val); inOrder(root.right);&#125;/* 后序遍历 */void postOrder(TreeNode root) &#123; if (root == null) return; // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点 postOrder(root.left); postOrder(root.right); list.add(root.val);&#125; 时间复杂度 O(n)：所有节点被访问一次，使用 O(n) 时间。空间复杂度 O(n)：在最差情况下，即树退化为链表时，递归深度达到 n，系统占用 O(n) 栈帧空间。 lant:到目前为止，我们的二叉树都还只是自己手动将一些 数据节点 随意串连起来的，父子节点之间也没什么大小顺序之分，节点们的组合还没什么规律可言。我们也只是在串连时尽量保证它们连起来像一棵二叉树，尽量完全 或 完美。 但即便我们好手动连出了一棵完美二叉树，由于各节点之间并没有什么规则，这棵树貌似既不能帮我们完成排序，也无法帮我们完成某种快速检索。 貌似还没什么用…… 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"常见二叉树类型","date":"2020-10-27T13:23:19.000Z","path":"2020/10/27/data-structure-algorithm/10-2.binary-tree/","text":"「完美二叉树 perfect binary tree」所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 0，其余所有节点的度都为 2；若树高度为 h，则节点总数为 $2^{h+1}-1$ 。呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。 「完全二叉树 complete binary tree」只有最底层的节点未被填满，且最底层节点尽量靠左填充。 「完满二叉树 full binary tree」除了叶节点之外，其余所有节点都有两个子节点 「平衡二叉树 balanced binary tree」任意节点的左子树和右子树的高度之差的绝对值不超过 1 二叉树的退化当二叉树的每层节点都被填满时，达到 完美二叉树，完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。而当所有节点都偏向一侧时，二叉树退化为 链表，链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n)。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"「二叉树 binary tree」","date":"2020-10-27T12:15:32.000Z","path":"2020/10/27/data-structure-algorithm/10-1.binary-tree/","text":"认识二叉树 「二叉树 binary tree」是一种非线性数据结构，体现着“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。 常见术语12345678根节点 root node」：位于二叉树顶层的节点，没有父节点。「叶节点 leaf node」：没有子节点的节点，其两个指针均指向。「边 edge」：连接两个节点的线段，即节点引用（指针）。节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。节点的「深度 depth」：从根节点到该节点所经过的边的数量。节点的「高度 height」：从距离该节点最远的叶节点到该节点所经过的边的数量。 二叉树 (链式存储) 基本操作初始化二叉树 从二叉树的结构图来看，它的节点和链表的节点非常像，因此用链表来存储二叉树也挺顺理成章的 😝。而且链式存储也比较简单、直观，很方便地通过节点的左右指针就能将整棵树串起来，大部分二叉树代码都是通过这种结构来实现的。 其实初始化二叉树的过程和初始化一个链表没什么区别(将一些节点用指针串联起来)。只不过串联的逻辑稍有不同。 1234567891011// 初始化节点TreeNode n1 = new TreeNode(1);TreeNode n2 = new TreeNode(2);TreeNode n3 = new TreeNode(3);TreeNode n4 = new TreeNode(4);TreeNode n5 = new TreeNode(5);// 构建引用指向（即指针）n1.left = n2;n1.right = n3;n2.left = n4;n2.right = n5; 这棵二叉树的逻辑结构如下： 当然，对于上面的多个节点，你有多种不同的连接方式，将它们连成多种不同的二叉树： 插入、删除 节点与链表类似， 在二叉树中 插入、删除节点 ，可以通过修改指针来实现 123456TreeNode P = new TreeNode(0);// 在 n1 -&gt; n2 中间插入节点 Pn1.left = P;P.left = n2;// 删除节点 Pn1.left = n2; 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构分类","date":"2020-10-11T12:15:32.000Z","path":"2020/10/11/data-structure-algorithm/01.dataStructure-type/","text":"数据结构分类数据结构可以从两个维度分为： 逻辑结构 和 物理结构。 逻辑结构 揭示了数据元素之间的逻辑关系，是抽象意义上的结构（也是我们后面重点关注和讨论的）； 物理结构 则反映了 按一定逻辑结构组成的数据元素 在计算机内存中真正的存储结构；在算法运行过程中，相关数据都存储在内存中, 这些数据的存储方式可分为 连续空间存储（数组） 和 分散空间存储（链表） 逻辑结构 逻辑结构 又可被分为 线性 和 非线性 两大类 线性结构比较直观，指数据在逻辑关系上呈线性排列；如：数组、链表、栈、队列、哈希表。 非线性结构则相反，呈非线性排列。如：树、堆、图、哈希表。 所有数据结构都是基于 数组、链表 或二者的组合实现的，例如 基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度&gt;&#x3D;3的数组）等。基于链表可实现：栈、队列、哈希表、树、堆、图等。 lant: 数组 和 链表这两种逻辑数据结构，对应了内存上的两个最基本的物理存储结构 连续存储、分散存储，因此 数组 和 链表是最基本的逻辑数据结构，其他更为复杂的逻辑数据结构要使用哪种物理结构进行存储时，都需要基于这两个最基础的逻辑数据结构进行选择。 可以简单认为，对于一组数据，无论它们逻辑上是用哪种结构组合起来的。它们最终在物理介质上都是两种存储方式 连续存储、分散存储。 而这两种物理存储方式对应了最基础的两个数据结构 数组、链表。 所以无论你的数据是哪种逻辑结构的组合，最终也要选择基于什么样的物理结构进行存储，而 数组 和 链表 这两种基础数据结构分别对应了不同的物理存储结构。 如，下图中对于 堆 这种数据结构(逻辑上的)，可以采用 链表 或 数组 两种不同的 数据结构(物理上的) 进行存储。 参考文献 hello-algo 《数据结构与算法之美》王争","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://rymuscle.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}]